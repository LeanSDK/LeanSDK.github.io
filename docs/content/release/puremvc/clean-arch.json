{"data":{"type":"contents","id":"puremvc/clean-arch","attributes":{"content":"![Clean Architecture](/images/puremvc/gestalt/clean_architecture.jpg)\n\n<b>The Clean Architecture</b> описывает основные общие правила построения архитектуры приложения.\nКак сделать разработку тестируемой, удобной, понятной, а части системы взаимозаменяемыми.\n\nЗа последние несколько лет было предложено множество идей построения архитектуры.\n\nНапример:\n\n* [Hexagonal Architecture](http://alistair.cockburn.us/Hexagonal+architecture)\n(или Ports and Adapters) от Alistair Cockburn адаптированная Steve Freeman\nи Nat Pryce в их замечательной книге Growing Object Oriented Software\n* [Onion Architecture](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) от Jeffrey Palermo\n* [Screaming Architecture](https://8thlight.com/blog/uncle-bob/2011/09/30/Screaming-Architecture.html) из блога Robert Martin\n* [DCI](http://www.amazon.com/Lean-Architecture-Agile-Software-Development/dp/0470684208/) от James Coplien и Trygve Reenskaug.\n* [BCE](http://www.amazon.com/Object-Oriented-Software-Engineering-Approach/dp/0201544350) от Ivar Jacobson из его книги Object Oriented Software Engineering: A Use-Case Driven Approach\n\nНесмотря на то, что детали, предложенные в этих архитектурах сильно варьируются,\nвсе же, они очень похожи.\n\nВсе они разбивают проблему на схожие задачи. Они все добиваются этого разделения\nразложением кода на слои. Каждая имеет как минимум один слой для бизнес логики\nи другой - для интерфейсов.\n\nКаждая из этих архитектур создает систему, которая:\n\n1. Независимость от фреймворка. Архитектура не должна зависеть от какого-либо\nфреймворка или библиотеки, релиазующей какую-либо фичу. Такой подход позволяет\nиспользовать фреймворки как инструмент, нежели, подгонять ваш код под возможности фреймворка.\n2. Тестируемость. Бизнес-логика должна быть тестируема без UI, баз данных,\nвеб-сервисов и прочих сторонник элементов.\n3. Независимость от UI. Должна быть возможность легко изменить UI без затрагивания\nдругих частей системы. Веб интерфейс может быть заменен на консольный без изменения бизнес-логики.\n4. Независимость от Базы Данных. Должна быть возможность заменить Oracle или\nSQL Server на Mongo, BigTable, CouchDB или что-либо еще. Бизнес-логика не зависит от Базы Данных\n5. Независимость от внешних сервисов. Бизнес-логика просто не знает о существовании чего-либо во внешнем мире.\n\nНа диаграме представлена попытка изобразить общую концепцию представленных архитектур.\n\n## Правило зависимости (Dependency rule)\nКаждый слой на диаграме представляет разный слой кода. В целом, чем глубже\nвы двигаетесь внутрь диаграмы, тем на более высокий уровень абстракции попадаете.\nВнешние слои это реализация, внутренние - правила.\n\nОсновное правило, благодаря которому эта архитектура работает - Правило Зависимости.\nПравило звучит так: внешние слои знают о внутренних, но не наоборот. Н\nичего из внутреннего слоя не должно знать о существовании внешнего.\nВ частности, имена, объявленные во внешних слоях не должны даже упоминаться во\nвнутренних. Это касается функций, классов, переменных и любых других сущностей.\n\nТочно также, форматы данных, используемые во внешних слоях не должны быть\nиспользованы где-либо во внутренних слоях. Особенно, если эти данные\nсгенерированы фреймворком, используемым во внешних слоях. Мы не хотим никаким\nобразом влиять на внутренние слои из внешних.\n\n## Слои\n\n### Entities\nEntities содержат бизнес-логику используемую во всем приложении. Entities может\nбыть объектом с методами или может быть просто набором структур данных и функций.\nНе имеет значения, в каком виде представлена Entity, пока она может быть\nиспользована различными модулями проекта.\n\nЕсли вы разрабатываете одно небольшое приложение, то Entities являются\nбизнес-объектами этого приложения. Они содержат в себе основную высокоуровневую\nлогику. При каких-либо внешних изменениях, Entities - последнее, чего могут\nкоснуться эти изменения. Например, изменения навигации или настроек безопасности\nникак не должны повлиять на них. Ни одно изменение модуля приложения не должно\nзатронуть Entities.\n\n### Use Cases\nКод этого уровня содержит бизнес-правила конкретного приложения. Он содержит и\nреализовывает все возможные варианты использования системы. Use cases отвечают за\nпоток данных в/из Entities и используют Entities для выполнения необходимых действий.\n\nИзменения этого слоя не должны влиять на Entities. Также, изменения внених слоев,\nтаких как, Базы Данных, никак не должны влиять на Use Cases.\n\nОднако, код Use Cases будет изменен при изменении логики работы приложения. Если\nизменится какой-либо случай использования приложения, эти изменения будут\nреализованы в этом слое.\n\n### Interface Adapters\nЭтот слой представляет из себя набор адаптеров, которые конвертируют данные, из\nформата, который удобен для использования в Entities и Use Cases в формат, более\nудобный для внешних сервисов, таких как Базы Данных или Web-сервисы. Например,\nв этом слое должен содержаться полностью весь GUI MVC. Контроллеры, Презентеры,\nПредставления, все находится здесь. Модели, пожалуй, это всего лишь структуры\nданных, которые передаются из Контролеров в Use Cases и обратно из Use Cases в\nПредставления и Презентеры.\n\nПо аналогии, в этом слое данные должны быть конвертированы из формата, удобного\nдля использования в Entities и Use Cases в форматы, удобные для хранения, например\nв Базах Данных. Код изнутри этого слоя не должен что-либо знать о Базах Данных.\nЕсли используется SQL база данных, то все SQL запросы должны быть обработаны именно\nна уровне этого слоя.\n\nТакже, в этом слое должны находиться все другие возможные адаптеры, конвертирующие\nданные в формат удобный для использования в любых других внешних сервисах и\nнаоборот в форматы, используемые в Entities и Use Cases.\n\n### Frameworks and Drivers\nСамый дальний, внешний слой, состоящий из фреймворков и различных инструментов,\nтаких как Базы Данных, Web-сервисы. В общем, вы не должны писать здесь много кода,\nкроме связующего кода с внутренними слоями.\n\nНа этом слое реализованы все детали. Связь с Web-сервисами - это детали. Базы\nДанных - это детали. Мы оставили все это снаружи, чтобы не причинять вреда внутренним слоям.\n\n## И это все?\nНет. Эти слои - схематичны. Вероятно, вам понадобится что-либо, не вписывающие\nв эти четыре слоя. Нет такого правила, которое говорит, что вы должны использовать\nтолько эти четыре слоя. Однако, Правило Зависимостей (Dependency Rule) должно\nвыполняться всегда. Исходный код на любом слое должны ссылаться на внутренний.\nПри движение вовнутрь, уровень абстракции увеличивается. Внешний слой - низкоуровневая\nреализация деталей. Чем дальше вы продвигаетесь вовнутрь, тем более абстрактным\nстановится код и более высокоуровневую логику реализовывает. Самый внутренний слой\nотвечает за общую логику.\n\n## Пересечение границ слоев\nНа диаграмме справа-снизу представлено, как можно пересечь границы слоя. Там показано,\nкак Контроллеры и Представления общаются с Use Cases. Обратите внимание на поток\nуправления. Он начинается в Контроллере, проходит через Use Case и заканчивается\nв Презентере. Также обратите внимание на зависимости исходного кода. Каждый из них\nуказывает на Use Case.\n\nОбычно мы решает это противоречие при помощи Принципа Инверсии Зависимостей.\nВ таких языках, как Java, мы должны настроить интерфейсы и наследования, так,\nчтобы зависимости исходного кода были противоположны потоку управления в точках\nпересечения границ слоев.\n\nДопустим, Use Case должен обратиться к Презентеру. Это обращение не должно быть\nреализовано напрямую, чтобы не нарушать Правило Зависимостей (Dependency Rule):\nвнутренние слои не должны знать о реализации внешних. В таком случае, Use Case\nобратится к интерфейсу (изображено на диаграмме как Use Case Output Port) внутреннего\nслоя, а Презентер из внешнего слоя должен его реализовать.\n\nПодобная техника используется для пересечения остальных границ архитектуры.\nМы используем преумещества динамического полиморфизма, чтобы зависимости исходного\nкода были противоположны потоку управления. Таким образом мы не нарушаем правило\nзависимостей (Dependency Rule) вне зависимости от направления потока управления.\n\n## Какие данные должны пересекать границы\nОбычно, данные, пересекаемые границы, являются обычными структурами данных.\nВы можете пользоваться основными структурами или Data Transfer объектами. Или\nданные могут быть аргументами вызова функций. Или вообще можно представлять данные\nв виде hashmap или засунуть в объект. Важно, чтобы данные, пересекаемые границы,\nбыли простыми и изолированными. Мы же не хотим читерить и передавать Entities или\nстроки из Базы Данных. Также передаваемые данные не должны иметь какие-либо\nзависимости и нарушать правило зависимостей (Dependency Rule).\n\nНапример, множество фреймворков возвращает из Базы Данных данные в очень удобном\nформате. Назовем это RowStructure. Однако нельзя передавать RowStructure через\nграницы слоев. Это нарушает правило зависимостей (Dependency Rule) потому что\nтаким образом мы можем дать внутреннему слою информацию о реализации и структуре\nиспользуемых данных внешнего.\n\nВ общем, при передаче данных через границу, они должны быть представлены в формате,\nнаиболее удобном для использования во внутреннем слое.\n\n## В нашем случае\nСледовать этим простым правилам не так сложно, однако это сохранит вас от головной\nболи в будущем. Разделением кода на слои и следованием правилу зависимостей\n(Dependency Rule) можно создать систему, которая будет действительно тестируемой\nсо всеми вытекающими из этого плюсами. Если какая-то внешняя часть системы устареет\n(например, База Данных или фреймворк), заменить его будет достаточно легко без каких-либо проблем.\n\nНа первый взгляд, <em>Clean Architecture</em> – довольно простой набор рекомендаций\nк построению приложений. Но и я, и многие мои коллеги, осознали эту архитектуру не сразу.\n<b>Ниже мы попытаемся лучше понять Clean Architecture и избавиться от распространенных заблуждений</b>.\n\nСразу хочу оговориться, заблуждения – это дело личное. Каждый в праве заблуждаться.\nИ если это его устраивает, то я не хочу мешать. Но всегда хорошо услышать мнения других людей,\nа зачастую люди не знают даже мнений тех, кто стоял у истоков.\n\n### Истоки\n\nВ 2011 году [Robert C. Martin](https://en.wikipedia.org/wiki/Robert_C._Martin),\nтакже известный как Uncle Bob, опубликовал статью [Screaming Architecture](https://8thlight.com/blog/uncle-bob/2011/09/30/Screaming-Architecture.html),\nв которой говорится, что архитектура должна «кричать» о самом приложении, а не о том,\nкакие фреймворки в нем используются. Позже вышла [статья](https://8thlight.com/blog/uncle-bob/2011/11/22/Clean-Architecture.html),\nв которой Uncle Bob даёт отпор высказывающимся против идей чистой архитектуры.\nА в 2012 году он опубликовал статью «[The Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)»,\nкоторая и является основным описанием этого подхода. Кроме этих статей я также\nочень рекомендую посмотреть видео выступления Дяди Боба.\n\n\nОригинальная схема из статьи, которая первой всплывает в голове разработчика,\nкогда речь заходит о Clean Architecture представлена под заголовком страницы.\n\nВ Android-сообществе Clean стала быстро набирать популярность после статьи\n[Architecting Android...The clean way?](https://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/),\nнаписанной Fernando Cejas. В этой статье Fernando приводит такую схему слоёв:\n\n![android-the-clean-way](/images/puremvc/clean-arch/9ac65cf9ba3849db8532914040bd89b8.png)\n\nТо, что на этой схеме другие слои, а в domain слое лежат ещё какие-то Interactors\nи Boundaries, сбивает с толку. Оригинальная картинка тоже не всем понятна.\nВ статьях многое неоднозначно или слегка абстрактно. А видео не все смотрят\n(обычно из-за недостаточного знания английского). И вот, из-за недопонимания,\nлюди начинают что-то выдумывать, усложнять, заблуждаться...\n\n## Давайте разбираться!\n\nClean Architecture объединила в себе идеи нескольких других архитектурных подходов,\nкоторые сходятся в том, что архитектура должна:\n\n* быть тестируемой;\n* не зависеть от UI;\n* не зависеть от БД, внешних фреймворков и библиотек.\n\nЭто достигается разделением на слои и следованием Dependency Rule (правилу зависимостей).\n\n## Dependency Rule\n\n<b>Dependency Rule говорит нам, что внутренние слои не должны зависеть от внешних</b>.\nТо есть наша бизнес-логика и логика приложения не должны зависеть от презентеров, UI,\nбаз данных и т.п. На оригинальной схеме это правило изображено стрелками, указывающими внутрь.\n\nВ статье сказано: имена сущностей (классов, функций, переменных, чего угодно),\nобъявленных во внешних слоях, не должны встречаться в коде внутренних слоев.\n\nЭто правило позволяет строить системы, которые будет проще поддерживать, потому\nчто изменения во внешних слоях не затронут внутренние слои.\n\n## Слои\n\nUncle Bob выделяет 4 слоя:\n\n* Entities. Бизнес-логика общая для многих приложений.\n* Use Cases (Interactors). Логика приложения.\n* Interface Adapters. Адаптеры между Use Cases и внешним миром. Сюда попадают\nPresenter'ы из MVP, а также Gateways (более популярное название репозитории).\n* Frameworks. Самый внешний слой, тут лежит все остальное: UI, база данных, http-клиент, и т.п.\n\nПодробнее, что из себя представляют эти слои, мы рассмотрим по ходу. А пока остановимся на передаче данных между ними.\n\n## Переходы\n\n<b>Переходы между слоями осуществляются через Boundaries</b>, то есть через два\nинтерфейса: один для запроса и один для ответа. Их можно увидеть справа на\nоригинальной схеме (Input/OutputPort). Они нужны, чтобы внутренний слой не\nзависел от внешнего (следуя Dependency Rule), но при этом мог передать ему данные.\n\n![Flow of control](/images/puremvc/clean-arch/afbef2e40b7b4f87939dcde0b1ab6bae.png)\n\nОба интерфейса относятся к внутреннему слою (обратите внимание на их цвет на картинке).\n\nСмотрите, Controller вызывает метод у InputPort, его реализует UseCase, а затем\nUseCase отдает ответ интерфейсу OutputPort, который реализует Presenter. То есть\nданные пересекли границу между слоями, но при этом все зависимости указывают\nвнутрь на слой UseCase'ов.\n\n<em>Чтобы зависимость была направлена в сторону обратную потоку данных</em>, применяется\n[принцип инверсии зависимостей](https://en.wikipedia.org/wiki/Dependency_inversion_principle)\n(буква D из аббревиатуры [SOLID](https://en.wikipedia.org/wiki/SOLID)). То есть, вместо\nтого чтобы UseCase напрямую зависел от Presenter'a (что нарушало бы Dependency Rule),\nон зависит от интерфейса в своём слое, а Presenter должен этот интерфейс реализовать.\n\nТочно та же схема работает и в других местах, например, при обращении UseCase к\nGateway/Repository. Чтобы не зависеть от репозитория,\nвыделяется интерфейс и кладется в слой UseCases.\n\nЧто же касается данных, которые пересекают границы, то это должны быть <b>простые структуры</b>.\nОни могут передаваться как [DTO](https://en.wikipedia.org/wiki/Data_transfer_object)\nили быть завернуты в HashMap, или просто быть аргументами при вызове метода.\nНо они обязательно должны быть в форме более удобной для внутреннего слоя (лежать во внутреннем слое).\n\n## Особенности мобильных приложений\n\nНадо отметить, что <b>Clean Architecture была придумана с немного иным типом\nприложений на уме</b>. Большие серверные приложения для крупного бизнеса, а не\nмобильные клиент-серверные приложения средней сложности, которые не нуждаются\nв дальнейшем развитии (конечно, бывают разные приложения, но согласитесь, в\nбольшей массе они именно такие). Непонимание этого может привести к [overengineering'у](https://en.wikipedia.org/wiki/Overengineering).\n\nНа оригинальной схеме есть слово Controllers. Оно появилось на схеме из-за\nfrontend'a, в частности из Ruby On Rails. Там зачастую разделяют Controller,\nкоторый обрабатывает запрос и отдает результат, и Presenter, который выводит\nэтот результат на View. Многие не сразу догадываются,\nно <em>в android-приложениях Controllers не нужны</em>.\n\nЕщё в статье Uncle Bob говорит, что <em>слоёв</em> не обязательно <em>должно быть 4</em>.\nМожет быть любое количество, но Dependency Rule должен всегда применяться.\n\nГлядя на схему из статьи Fernando Cejas, можно подумать, что автор воспользовался\nкак раз этой возможностью и уменьшил количество слоев до трёх. Но это не так.\nЕсли разобраться, то в Domain Layer у него находятся как Interactors (это другое\nназвание UseCase'ов), так и Entities.\n\nВсе мы благодарны Fernando за его статьи, которые дали хороший толчок развитию\nClean в Android-сообществе, но его схема также породила и заблуждение.\n\n## Слои и линейность\n\nСравнивая оригинальную схему от Uncle Bob'a и cхему Fernando Cejas'a многие начинают\nпутаться. Линейная схема воспринимается проще, и люди начинают неверно понимать\nоригинальную. А не понимая оригинальную, начинают неверно толковать и линейную.\nКто-то думает, что расположение надписей в кругах имеет сакральное значение,\nили что надо использовать Controller, или пытаются соотнести названия слоёв на\nдвух схемах. <b>Смешно и грустно, но основные схемы стали основными источниками заблуждения</b>!\n\nПостараемся это исправить. Для начала давайте <em>очистим основную схему</em>,\nубрав из нее лишнее для нас. И переименуем Gateways в Repositories,\nт.к. это более распространенное название этой сущности.\n\n![cicles schema](/images/puremvc/clean-arch/42cf44b37d614d2785444057af7273e8.png)\n\nСтало немного понятнее. Теперь мы сделаем вот что: <em>разрежем слои на части</em> и превратим\nэту схему в блочную, где цвет будет по-прежнему обозначать принадлежность к слою.\n\n![cicles-liner schema](/images/puremvc/clean-arch/fe8c82a32b1548b1a297187e24ae755a.png)\n\nКак я уже сказал выше, цвета обозначают слои. А стрелка внизу обозначает Dependency Rule.\n\nНа получившейся схеме уже проще представить себе течение данных от UI к БД или серверу\nи обратно. Но давайте сделаем еще один шаг к линейности, расположив слои <em>по категориям</em>:\n\n![liner schema](/images/puremvc/clean-arch/9869dbe34b5649e28be40bff6bee3147.png)\n\nЯ намеренно не называю это разделение слоями, в отличие от Fernando Cejas. Потому что\nмы и так делим слои. Я называю это категориями или частями. Можно назвать как угодно,\nно повторно использовать слово «слои» не стоит.\n\nА теперь давайте сравним то, что получилось, со схемой Fernando.\n\n![two liner schemas](/images/puremvc/clean-arch/cbe3fdad2be24de3bd4dda6c66d56d76.png)\n\nНадеюсь теперь вcё начало вставать на свои места. Выше я говорил, что, по моему мнению,\nу Fernando всё же 4 слоя. Думаю теперь это тоже стало понятнее. В Domain части\nу нас находятся и UseCases и Entities.\n\n\nТакая схема воспринимается проще. Ведь обычно события и данные в наших приложениях\nходят от UI к backend'у или базе данных и обратно. Давайте изобразим этот процесс:\n\n![both schema](/images/puremvc/clean-arch/53104c89d9cf44a59c95e351b7485574.png)\n\nКрасными стрелками показано <em>течение данных</em>.\n\nСобытие пользователя идет в Presenter, тот передает в Use Case. Use Case делает\nзапрос в Repository. Repository получает данные где-то, создает Entity, передает\nего в UseCase. Так Use Case получает все нужные ему Entity. Затем, применив их и\nсвою логику, получает результат, который передает обратно в Presenter. А тот, в\nсвою очередь, отображает результат в UI.\n\nНа переходах между слоями (не категориями, а слоями, отмеченными разным цветом)\nиспользуются Boundaries, описанные ранее.\n\nТеперь, когда мы <b>поняли, как соотносятся две схемы</b>, давайте рассмотрим\nследующее заблуждение.\n\n## Слои, а не сущности\n\nКак понятно из заголовка, кто-то думает, что на схемах изображены сущности (особенно\nэто затрагивает UseCases и Entities). Но это не так.\n\n<b>На схемах изображены слои, в них может находиться много сущностей</b>. В них будут\nнаходиться интерфейсы для переходов между слоями (Boundaries), различные DTO, основные\nклассы слоя (Interactors для слоя UseCases, например).\n\n\nНе будет лишним взглянуть на схему, собранную из частей, показанных в видео выступления\nUncle Bob'a. На ней изображены <em>классы и зависимости</em>:\n\n![classes and dependencies](/images/puremvc/clean-arch/bb3430769e6c4e8fbca757a8bc071f2e.png)\n\nВидите двойные линии? Это границы между слоями. Разделение между слоями Entities\nи UseCases не показаны, так как в видео основной упор делался на том, что вся\nлогика (приложения и бизнеса) отгорожена от внешнего мира.\n\nC Boundaries мы уже знакомы, интерфейс Gateway – это то же самое.\nRequest/ResponseModel – просто DTO для передачи данных между слоями. По правилу\nзависимости они должны лежать во внутреннем слое, что мы и видим на картинке.\n\nПро Controller мы тоже уже говорили, он нас не интересует. Его функцию у нас\nвыполняет Presenter.\n\nА ViewModel на картинке – это не ViewModel из [MVVM](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel)\nи не ViewModel из [Architecture Components](https://developer.android.com/topic/libraries/architecture/viewmodel.html).\nЭто просто DTO для передачи данных View, чтобы View была тупой и просто сетила\nсвои поля. Но это уже детали реализации и будет зависеть от выбора презентационного\nпаттерна и личных подходов.\n\nВ слое UseCases находятся не только Interactor'ы, но также и Boundaries для работы\nс презентером, интерфейс для работы с репозиторием, DTO для запроса и ответа.\n<em>Отсюда можно сделать вывод, что на оригинальной схеме отражены всё же слои</em>.\n\n## Entities\n\n<em>Entities по праву занимают первое место по непониманию.</em>\n\nМало того, что почти никто (включая меня до недавнего времени) не осознает,\nчто же это такое на самом деле, так их ещё и путают с DTO.\n\n```\nОднажды в чате возник спор, в котором оппонент доказывал, что Entity – это объекты,\nполученные после парсинга JSON в data-слое, а DTO – объекты, которыми оперируют Interactor'ы...\n```\n\nПостараемся хорошо разобраться, чтобы таких заблуждений больше не было ни у кого.\n\nЧто же такое Entities?\n\nЧаще всего они воспринимаются как POJO-классы, с которыми работают Interactor'ы.\nНо это не так. По крайней мере не совсем.\n\nВ статье Uncle Bob говорит, что <b>Entities инкапсулируют логику бизнеса</b>,\n<em>то есть всё то, что не зависит от конкретного приложения, а будет общим для многих</em>.\nНо если у вас отдельное приложение и оно не заточено под какой-то существующий бизнес,\nто Entities будут являться <em>бизнес-объектами приложения, содержащими самые\nобщие и высокоуровневые правила</em>.\n\nЯ думаю, что именно фраза: «Entities это бизнес объекты», – запутывает больше всего.\nКроме того, на приведенной выше схеме из видео Interactor получает Entity из Gateway.\nЭто также подкрепляет ощущение, что это просто POJO объекты.\n\nНо в статье также говорится, что <em>Entity может быть объектом с методами или\nнабором структур и функций</em>. То есть упор делается на то, что важны методы, а не данные.\n\nЭто также подтверждается в [разъяснении](https://groups.google.com/forum/#!topic/clean-code-discussion/mvP_NR2MUPc)\nот Uncle Bob'а, которое я нашел недавно:\n\nUncle Bob говорит, что для него Entities содержат бизнес-правила, независимые от приложения.\nИ они <em>не просто объекты с данными. Entities могут содержать ссылки на объекты\nс данными, но основное их назначение в том, чтобы реализовать методы бизнес-логики,\nкоторые могут использоваться в различных приложениях</em>.\n\nА по-поводу того, что Gateways возвращают Entities на картинке, он поясняет следующее:\n\nРеализация Gаteway получает данные из БД, и использует их, чтобы создать структуры\nданных, которые будут переданы в Entities, которые Gateway вернет. Реализовано это может быть композицией\n\n```java\nclass MyEntity { private MyDataStructure data;}\n```\n\nили наследованием\n\n```java\nclass MyEntity extends MyDataStructure {...}\n```\n\nИ в конце ответа фраза, которая меня очень порадовала:\n\n```\nAnd remember, we are all pirates by nature; and the rules I'm talking about here\nare really more like guidelines...\n(И запомните: мы все пираты по натуре, и правила, о которых я говорю тут,\nна самом деле, скорее рекомендации...)\n```\n\nДействительно, не надо слишком буквально всё воспринимать, надо искать компромиссы и не делать лишнего. Все-таки любая архитектура призвана помогать, а не мешать.\n\nИтак, <b>слой Entities содержит</b>:\n\n* Entities – функции или объекты с методами, которые реализуют логику бизнеса, общую для многих приложений (а если бизнеса нет, то самую высокоуровневую логику приложения);\n* DTO, необходимые для работы и перехода между слоями.\n\nКроме того, когда приложение отдельное, то надо стараться находить и выделять в Entities высокоуровневую логику из слоя UseCases, где зачастую она оседает по ошибке.","description":"The Clean Architecture описывает основные общие правила построения архитектуры приложения. Как сделать разработку тестируемой, удобной, понятной, а части системы взаимозаменяемыми. \n\nЗа последние несколько лет было предложено множество идей построения..."}}}