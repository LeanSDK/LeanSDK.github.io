Вообще говоря, паттерн <em>Прокси</em> (<em>Proxy</em>, далее <em>Прокси</em>) используется для
обеспечения хранения любого объекта в целях контроля доступа к нему. В
приложениях, основанных на PureMVC, класс <em>Proxy</em> используется
специально для управления частями <em>Модели Данных</em> приложения.

<em>Прокси</em> могут управлять доступом к созданным локально структурам
данных произвольной сложности. Они называются <em>Объектами Данных</em>
<em>Прокси</em> (<em>Proxy’s Data Object</em>).

В этом случае, идиома для взаимодействия с <em>Прокси</em> связана с синхронной
установкой (setting) и получением (getting) данных. <em>Объекты Данных</em> могут
подвергаться полному или частичному обновлению свойств, или же может
меняться ссылка на сам <em>Объект Данных</em>. Когда выполняются методы для
обновления данных, <em>Прокси</em> может отправлять <em>Оповещение</em> в остальную
часть системы, что его данные изменились.

<em>Прокси Удаленного Сервиса</em> (<em>Remote Proxy</em>, далее <em>Прокси Удаленного
Сервиса</em>) используется для инкапсуляции взаимодействия с удаленными
сервисами, для сохранения или получения данных. <em>Прокси</em> может хранить
объект, который взаимодействует с удаленным сервисом, а также
контролировать доступ к данным, переданным и полученным от этого
сервиса.

Таким образом, можно просто устанавливать данные или же вызывать
методы <em>Прокси</em> и дожидаться асинхронного <em>Оповещения</em>, отправляемого
<em>Прокси</em> когда данные от удаленного сервиса получены.

## Обязанности конкретного Прокси
<em>Конкретные Прокси</em> позволяют нам инкапсулировать фрагменты модели
данных, независимо откуда они получены и их типа, а так же необходимы
для управления <em>Объектами Данных</em> и организации доступа приложения к
ним.

Реализация класса <em>Прокси</em>, который входит в PureMVC, является простым
контейнером для <em>Объектов Данных</em>, и может быть зарегистрирована в
<em>Модели</em>.

Чтобы полностью использовать возможности в данной форме, мы, обычно,
создаем подкласс класса <em>Proxy</em> и добавляем функциональность,
характерную для конкретного <em>Прокси</em>.

Общие варианты использования <em>Прокси</em> включают в себя:

* <em>Прокси Удаленного Сервиса</em> - данные, управляемые конкретным
<em>Прокси</em>, находится на удаленном сервере, и могут быть доступны
через удаленный сервис.
* <em>Прокси</em> и <em>Делегат</em> (Proxy and Delegate) - доступ к объекту,
обеспечивающему удаленный доступ, должен быть распределен
между несколькими <em>Прокси</em>. Класс <em>Делегат</em> поддерживает объект
удаленного доступа и контролирует доступ к нему, обеспечивая
передачу ответов тем, кто послал запрос.
* <em>Защищенный Прокси</em> (Protection Proxy) - используется когда игроки
системы должны иметь разные права доступа к <em>Объекту Данных</em>.
* <em>Виртуальный Прокси</em> - создает <em>Объекты Данных</em> по запросу.
* <em>Умный Прокси</em> - загружает объекты данных в память при первом
доступе, осуществляет ведение учета ссылок, позволяет блокировать
объект, чтобы другой объект не смог изменить его.

## Неявное приведение типа объекта данных
Реализация базового класса <em>Proxy</em>, которая поставляется с PureMVC
принимает имя <em>Прокси</em> и основной <em>Объект Данных</em> в качестве аргумента
конструктора. Вы можете динамически устанавливать <em>Объект
Данных</em> <em>Прокси</em> после того, как он создан, вызывая метод setData.

Как и в случае с <em>Медиатором</em> и его <em>Компонентом Представления</em>, вы будете
часто приводить <em>Объект Данных</em> к фактическому типу, для того, чтобы
получить доступ к свойствам и методам, которые он предоставляет; это
утомительная и однообразная практика, но следование идиомам позволяют
открывать больше о реализации <em>Объекта Данных</em>, чем это может
потребоваться.

Кроме того, поскольку <em>Объект Данных</em> обычно имеет сложную структуру,
часто необходимо иметь под рукой ссылки на несколько частей структуры,
в дополнении к приведенной к типу ссылки на всю структуру.

В языке JavaScript функции называемые геттерами (getters) и
сеттерами (setter) оказываются очень полезными в решении приведения
типа и устранении проблем неуместного применения типов.

Полезная практика - использовать в <em>конкретном Прокси</em> getter,
который возвращает <em>Объект Данных</em> фактического типа и имеет
осмысленное название.

Дополнительно, вы можете указать несколько геттеров, возвращающих
определенные части <em>Объекта Данных</em>.

Например:

```js
@property get searchResultAC(): ArrayCollection {
  return this.getData();
}

@method resultEntry(index: number): SearchResultVO {
  return this.searchResultAC[index];
}
```

В каком-то Медиаторе вам пришлось бы делать так:

```js
const data: ArrayCollection = searchProxy.getData();
const item: SearchResultVO = data[1];
```

Однако, используя практику, описанную выше, можно сделать так:

```js
const item: SearchResultVO = searchProxy.resultEntry(1);
```

## Запрет на привязку к медиаторам
У <em>Прокси</em> не запрашивают список интересующих его <em>Оповещений</em> как у
<em>Медиатора</em>, да он и не получает <em>Оповещений</em>, потому что он не должен
заботиться о состоянии <em>Вида</em>. Вместо этого <em>Прокси</em> предоставляет методы и
свойства, позволяющие другим участникам манипулировать им.

<em>Конкретный Прокси</em> не должен извлекать и использовать <em>Медиаторы</em> для
того, чтобы информировать систему об изменении своего <em>Объекта Данных</em>.

Вместо этого <em>Прокси</em> должен отправлять <em>Оповещения</em>, которые получат
<em>Команды</em> или <em>Медиаторы</em>. От <em>Прокси</em> не должно зависеть, как эти
<em>Оповещения</em> повлияют на систему.

В связи с тем, что уровень <em>Модели Данных</em> не содержит каких-либо знаний
о системе реализации, уровни <em>Представления</em> и <em>Контроллера</em> могут быть
отрефакторены без вмешательства в уровень <em>Модели Данных</em>.

Обратное не совсем верно. Очень трудно изменить уровень <em>Модели
Данных</em>, не изменяя уровень <em>Представления</em> и, скорее всего, уровень
<em>Контроллера</em>. В конце концов, эти уровни существуют только чтобы
позволить пользователю взаимодействовать с уровнем <em>Модели Данных</em>.

## Инкапсуляция предметной области в прокси
Изменения на уровне <em>Модели Данных</em> почти всегда приводит к некоторому
рефакторингу уровней <em>Контроллера</em> и <em>Представления</em>.

Мы увеличили разделение между уровнем <em>Модели Данных</em> и общих
интересов уровней <em>Представления</em> и <em>Контроллера</em> путем максимального
перемещения предметной области в <em>Прокси</em>.

<em>Прокси</em> может использоваться не только для контроля доступа к данным, но
и выполнять операции над данными, которые могут быть необходимы для
поддержания некоторого их валидного состояния.

Например, расчет налога с продаж является функцией предметной области
и поэтому она должна находится в <em>Прокси</em>, а не в <em>Медиаторе</em> или <em>Команде</em>.

Несмотря на то, что эта функция может быть реализована в любом из этих
мест, размещение её в <em>Прокси</em> не только логично, но и облегчает другие
уровни и упрощает рефакторинг.

<em>Медиатор</em> может получить <em>Прокси</em>; вызвать функцию вычисления налога с
продаж, и возможно, поместить результат в какую-либо форму. Но
размещение фактического расчета в <em>Медиаторе</em> реализует в нем, с точки
зрения уровня, <em>Предметную Область</em>. Вычислений налога является
правилом относящемся к <em>Предметной Области</em>. <em>Представлению</em> оно может
быть известно как свойство <em>Предметной Области</em>, доступное, если
соответствующий <em>Объект Данных</em> присутствует.

Представьте, что вы в настоящее время работаете над RIA приложением
для запуска в размерах рабочего стола персонального компьютера. Новая
версия должна запускаться на КПК с соответствующим разрешением с
сокращением сценариев использования, но по-прежнему использовать
полную <em>Модель Данных</em> существующего приложения.

При правильном разделении интересов, мы можем использовать уровень
<em>Модели Данных</em> во всей ее полноте и просто подгонять новые уровни
<em>Представления</em> и <em>Контролера</em> к нему.

Размещение фактического расчета налога с продаж в <em>Медиаторе</em> может
показаться эффективным и простым в момент реализации; например, вы
только что получили данные из формы, и вы хотите рассчитать налог с
продаж, и отправить его в <em>Модель</em> уже вычисленным.

Однако в каждой версии своего приложения вам теперь придется
дублировать ваши усилия или копировать код вычисления налога с продаж
в новый, совершенно другой уровень <em>Представления</em>, хотя эта логика могла
бы появляться автоматически, как часть вашей <em>Модели Данных</em>.

## Взаимодействие с Прокси Удаленного Сервиса
<em>Прокси Удаленного Сервиса</em> - это обычный <em>Прокси</em>, который получает свои
<em>Объекты Данных</em> из удаленного местоположения. Это значит, что мы
взаимодействуем с ним в асинхронном режиме.

Каким образом <em>Прокси</em> получает данные - зависят от платформы клиента,
реализации удаленного взаимодействия, а также предпочтений
разработчиков. Mы можем использовать XMLHttpRequest, WebSocket, fetch(), ... для осуществления
запросов из <em>Прокси</em>.

В зависимости от потребностей, <em>удаленный Прокси</em> может направлять
запросы динамически, в ответ на вызов сеттеров или методов; или же
может делать единственный запрос во время создания и обеспечивать
доступ к данным впоследствии.

Есть ряд оптимизаций, которые могут быть применены в <em>Прокси</em> для
повышения эффективности взаимодействия с удаленной службой.

Прокси может кешировать данные, и, таким образом, сократить количество
запросов в сеть, или же отсылать обновления только тех частей структуры
данных, которые были изменены, уменьшая сетевой трафик.

Если запрос динамически вызывается на <em>Прокси Удаленного Сервиса</em>
другим игроком в системе, <em>Прокси</em> необходимо отправить <em>Оповещение</em>,
когда будет получен ответ.

Заинтересованным в получении <em>Оповещения</em> может быть или не быть тот
же игрок, что и инициировал запрос.

Например, для осуществления процесса поиска, происходящего на
удаленном сервере и отображения результатов, возможна следующая
последовательность действия:

* <em>Представление</em> инициирует поиск вызовом события (Event).
* Его <em>Медиатор</em> получает соответствующий <em>удаленный прокси</em> и
устанавливает свойство "критерии поиска".
* Свойство "критерий поиска" в <em>Прокси</em> - это на самом деле неявный
сеттер, который сохраняет значение и инициирует поиск запросом
через внутренний fetch().
* Затем <em>Прокси</em> отправляет <em>Оповещение</em>, информирующее об успехе
поиска и содержащее ссылку на свой <em>Объект Данных</em> в качестве
тела <em>Оповещения</em>.
* Другой <em>Медиатор</em>, выразивший заинтересованность в этом
<em>Оповещении</em>, и, соответственно, принимающий его, устанавливает
тело <em>Оповещения</em> как dataProvider своего <em>Компонента Представления</em>.

Или же рассмотрим LoginProxy, который содержит LoginVO (Value Object;
простой класс-контейнер данных).

LoginProxy содержит методы для установления полномочий, входа и выхода
пользователя, и получения метки авторизации, которая будет включена в
последующие удаленные вызовы для опознания пользователя в данной
конкретной схеме аутентификации.

Подробные примеры будут в следующих разделах.
