{"data":{"type":"contents","id":"puremvc/index","attributes":{"content":"![Schema](/images/puremvc/gestalt/schema.jpg)\n\nФреймворк PureMVC преследует очень узкую цель. Она в том, чтобы помочь\nвам разделить интересы кода вашего приложения на три отдельных уровня:\n<em>Модель</em> (Model), <em>Представление</em> (View) и <em>Контроллер</em> (Controller).\n\nДля создания масштабируемых и легко поддерживаемых приложений\nвысоким приоритетом являются разделение интересов, а так же\nгерметичность и направление связей между уровнями MVC\n\nВ данной реализации классического мета-паттерна MVC эти три уровня\nприложения управляются тремя синглтонами (классами, для которых\nвозможно существование одного и только одного экземпляра), называемыми\nпросто: <em>Модель</em> (Model), <em>Представление</em> (View) и <em>Контроллер</em> (Controller). Все\nвместе они называются <em>Базовыми классами</em> (Core actors).\n\nЧетвертый синглтон, <em>Фасад</em> (Facade), упрощает разработку, предоставляя\nединый интерфейс для сообщения с <em>Базовыми классами</em>.\n\n## Оказали влияние\n![Design patterns book](/images/puremvc/gestalt/design_patterns_book.jpg)\n\nPureMVC — это фреймворк, основанный на шаблонах\nпроектирования. Он появился из насущной необходимости\nпроектирования высокопроизводительных RIA-клиентов.\nСейчас он уже портирован на другие языки и платформы,\nвключая серверные среды.\n\nХотя интерпретация и реализация имеют свои особенности\nдля каждой поддерживаемой\nPureMVC платформы, используемые паттерны описаны в\nизвестной книге ‘Gang of Four’: Design Patterns: Elements\nof Reusable Object-Oriented Software (GoF)\n(ISBN 0-201-63361-2)\n\n![Clean Architecture](/images/puremvc/gestalt/clean_architecture.jpg)\n\nThe Clean Architecture описывает основные общие правила построения архитектуры приложения.\nКак сделать разработку тестируемой, удобной, понятной, а части системы взаимозаменяемыми.\n[Оригинал статьи](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)\n\n![SOLID](/images/puremvc/gestalt/solid.jpg)\n\nПри создании программных систем использование принципов SOLID способствует созданию\nтакой системы, которую будет легко поддерживать и расширять в течение долгого времени.\nПринципы SOLID — это руководства, которые также могут применяться во время работы\nнад существующим программным обеспечением для его улучшения, например,\nдля удаления «дурно пахнущего кода».\n[Wiki](https://en.wikipedia.org/wiki/SOLID)\n\n![InversifyJS](/images/puremvc/gestalt/inversifyjs.jpg)\n\n[InversifyJS](https://github.com/inversify/InversifyJS) —\nэто [IoC](https://en.wikipedia.org/wiki/Inversion_of_control)-контейнер.\nМы можем использовать IoC-контейнер для внедрения значений в компоненты,\nне передавая их явно через каждый компонент и не используя контекст.\nInversifyJS поддерживает два вида внедрений:\n\n* внедрение через constructor\n* внедрение через свойство\n\nОднако LeanES фреймворк не является эталонной реализацией спецификации PureMVC на\nязыке JavaScript. Наша команда портировала спецификацию PureMVC фреймворка в LeanES\nв качестве отдельного слоя. Несомненно это самый важный слой LeanES, т.к. предоставляет\nпрограммисту основные идиомы, с помощью которых можно построить любое приложение.\n\nОднако нужно отметить несколько отличий от спецификации PureMVC:\n\n* Добавлены короткие алиасы для основных методов в акторах PureMVC (Model, View,\nController, Mediator, Proxy, Command) для написания более компактного кода.\nЭталонные названия методов сохранены для обратной совместимости или для легкой миграции\nпрограммиста с другой платформы или языка программирования, где он уже использовал PureMVC.\n* Классы SimpleCommand и MacroCommand объединены в один класс Command, по существу с сохранением\nвсей функциональности это MacroCommand, но если переопределить в унаследованном классе\nметод execute() - это будет просто SimpleCommand.\n* Добавлены отсутствующие методы для безопасного удаления созданных сингелтонов в случае, когда\nмультитон удаляется. В оригинальной спецификации предусмотрено только создание мультитонов,\nно не их удаление.\n* Интегрированы дополнительные сущности и методы для работы с ними через <em>Фасад</em>\nв рамках концепции \"Clean Architecture\" by Robert C. Martin (Uncle Bob).\nЭти сущности <em>Кейс</em> (Case), <em>Сьюит</em> (Suite) и <em>Адаптер</em> (Adapter)\nтолько расширяют уровни абстракций в составе PureMVC с сохранением обратной совместимости\nс эталонной спецификацией.\n* В базовые классы ядра (Model, View, Controller, Facade) интегрирована библиотека InversifyJS.\nНе смотря на то, что <em>Фасад</em> по существу реализует возможность для инъекции\nзависимостей через вызов метода `this.facade.retrieveProxy()` или `this.facade.retrieveMediator()`,\nоднако в этом случае конкретные классы <em>Медиатора</em>, <em>Команды</em> и <em>Прокси</em> становятся зависимы\nот самого Фасада - что является примером антипатерна <em>Сервис-локатор</em> (Service Locator).\nПоэтому в состав LeanES на уровне PureMVC интегрирована библиотека InversifyJS, которая\nпредоставляет возможность описания в классах <em>Медиаторов</em>, <em>Команд</em>\nи <em>Прокси</em> а так же в <em>Кейсов</em>, <em>Сьюитов</em> и <em>Адаптеров</em>\n\"классической\" инъекции зависимостей, т.е. через конструктор или через проперти.\nПодробнее об этом можно прочитать в разделе \"Инверсия зависимости\".\n\nНаша команда выражает благодарность создателям PureMVC за возможность портирования\nих решения в наш фреймворк LeanES. Ниже приводим сноску из оригинальной документации\nPureMVC:\n\n```\nPureMVC является бесплатным фреймворком с открытым кодом от Futurescale, Inc.\nCopyright © 2006-09. Некоторые права защищены. Использование ограничено лицензией\nCreative Commons 3.0. Документация, обучающие материалы и примеры кода с сайта\nFuturescale's предоставляются «как есть», без всяких гарантий и включая, но,\nне ограничиваясь ими, подразумеваемые гарантии пригодности для целей, или гарантий\nненарушения прав. Implementation Idioms & Best Practices.doc\n```\n\nВся нижеследующая документация для сущностей PureMVC в большей степени базируется на\nоригинальной документации PureMVC. Однако примеры кода и отличительные особенности\nпортированной версии описываются в нижеследующей документации в соответствие с\nреальной имплементацией в LeanES фремворке, в том числе и мплементация всех базовых\nклассов PureMVC.\n\n## Модель и Прокси (Model & Proxies)\n<em>Модель</em> просто кэширует именованные ссылки к <em>Прокси</em>. Код <em>Прокси</em>\nманипулирует моделью данных, связываясь с удаленными сервисами, если\nнужно сохранить или запросить данные.\nТаким образом, <em>Модель</em> данных изолирована от контроллеров и\nпредставления. Это приводит к переносимому коду <em>Модели</em>.\n\n## Представление и Медиаторы (View & Mediators)\n<em>Представление</em> в первую очередь кэширует именованные ссылки на\n<em>Медиаторы</em>. Код <em>Медиатора</em> обслуживает компонент(ы) <em>Представления</em>,\nдобавляя к ним <em>Слушателей событий</em> и от их имени отправляя и получая\nоповещения к и от остальной системы, при этом непосредственно управляя\nих состоянием.\nЭто отделяет определение <em>Вида</em> от управляющей им логики.\n\n## Контроллер и Команды (Controller & Commands)\n<em>Контроллер</em> кеширует ссылки на классы <em>Команд</em>, создавая экземпляры\nкласса команды в тот момент, когда возникает необходимость выполнения\nэтой команды и уничтожая после выполнения.\n\nКоманды могут запрашивать <em>Прокси</em> и взаимодействовать с ними,\nотправлять <em>Оповещения</em>, выполнять другие <em>Команды</em>, и часто используются\nдля <em>дирижирования</em> сложными, охватывающими всю или почти всю систему\nдействиями, такими, как запуск или остановка приложения. Это альмаматер бизнес-логики вашего приложения.\n\n## Фасад и Ядро (Facade & Core)\n<em>Фасад</em> (Facade), еще один синглтон, инициализирует <em>Базовые классы</em>\n(Модель, Представление и Контроллер) и предоставляет единую точку\nдоступа ко всем их публичным методам.\n\nРасширяя <em>Фасад</em>, ваше приложение получает в распоряжение весь\nфункционал <em>Базовых классов</em> без необходимости их импорта и прямой\nработы с ними. Вы реализуете конкретный <em>Фасад</em> в своем приложении\nтолько один раз, и это делается очень просто.\n\n<em>Прокси</em>, <em>Медиаторы</em> и <em>Команды</em> могут использовать <em>конкретный\nФасад</em> вашего приложения для того, чтобы получать доступ и связываться\nдруг с другом.\n\n## Наблюдатели и Оповещения (Observers & Notifications)\nPureMVC-приложения могут выполняться в различных средах,\nтак что фреймворк реализует схему оповещений\n<em>Наблюдатель</em> (Observer) для сообщения между <em>Базовыми классами</em> MVC и\nдругими частями системы в манере слабого связывания.\n\nВам не нужно беспокоиться о деталях реализации\n<em>Наблюдателя/Оповещения</em> (Observer/Notification) в PureMVC; это\nвнутренняя часть фреймворка. Вам нужно только использовать простой\nметод для отправки <em>Оповещений</em> от <em>Прокси</em>, <em>Медиаторов</em>, <em>Команд</em> и <em>Фасада</em>,\nкоторый даже не требует создавать экземпляр <em>Оповещения</em>.\n\n## Оповещения можно использовать для запуска Команд\n<em>Команды</em> связаны с именами <em>Оповещений</em> в вашем конкретном <em>Фасаде</em> и\nавтоматически выполняются <em>Контроллером</em>, когда отправляются\nназначенные им <em>Оповещения</em>. <em>Команды</em> обычно дирижируют сложным\nвзаимодействием между интересами <em>Представления</em> и <em>Модели</em>, при этом\nзная о них настолько мало, насколько это возможно.\n\n## Медиаторы отправляют и получают Оповещения, а так же заявляют о заинтересованности в них\nПри регистрации в <em>Представлении</em> <em>Медиаторы</em> опрашиваются на предмет их\nзаинтересованности в <em>Оповещениях</em>, для чего вызывается метод\nlistNotifications, и должны возвращать массив имен <em>Оповещений</em>, в которых\nони заинтересованы.\n\nПозже, когда кто-то в системе отправляет одноименное <em>Оповещение</em>,\nзаинтересованные <em>Медиаторы</em> будут оповещены через вызов их метода\nhandleNotification, которому будет передана ссылка на <em>Оповещение</em>.\n\n## Прокси отправляют, но не получают Оповещений\n<em>Прокси</em> могут отправлять <em>Оповещения</em> по различным поводам. Например,\n<em>Прокси</em> для удаленного сервиса может оповестить систему о том, что он\nполучил результат с сервера. Или другой <em>Прокси</em> может оповестить систему\nо том, что изменились его данные.\n\nДля <em>Прокси</em> слушать <em>Оповещения</em> — это слишком сильное связывание с\nуровнями <em>Вида</em> и <em>Контроллера</em>.\n\nЭти уровни обязаны слушать <em>Оповещения</em> от <em>Прокси</em>, так как их функция\nзаключается в визуальном представлении и обеспечении взаимодействия\nпользователя с данными <em>Модели</em>, за которые отвечают <em>Прокси</em>.\n\nТем не менее, уровни <em>Вида</em> и <em>Контроллера</em> должны иметь возможность\nизменений, не влияющих на уровень <em>Модели данных</em>.\n\nНапример, административное приложение и связанное с ним\nпользовательское приложение могут иметь общие классы уровня <em>Модели</em>.\nЕсли отличаются только сценарии использования, то эти отличия можно\nреализовать за счет различных комбинаций <em>Представления</em> и <em>Контроллера</em>,\nработающих с одной и той же <em>Моделью</em>.","description":"Фреймворк PureMVC преследует очень узкую цель. Она в том, чтобы помочь вам разделить интересы кода вашего приложения на три отдельных уровня: Модель (Model), Представление (View) и Контроллер (Controller). \n\nДля создания масштабируемых и легко..."}}}