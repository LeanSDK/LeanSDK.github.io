{"data":{"type":"contents","id":"puremvc/dependency-inversion","attributes":{"content":"Попытки разобраться с принципом ООП <b>Инверсия зависимостей (Dependency Inversion Principle)</b>\nпривели к статье Мартина Фаулера \"Inversion of Control Containers and the\nDependency Injection pattern\" оригинал которой доступен [здесь](http://martinfowler.com/articles/injection.html).\nПеревод на русский язык можно найти [здесь](http://yugeon-dev.blogspot.com/2010/07/inversion-of-control-containers-and_21.html).\nВ данном разделе будут представлены выдержки из этого перевода  соответствие с реалиями фреймворка LeanES.\n\n## Inversion of Control Containers and the Dependency Injection pattern.\n\n<em>В сообществе Java-разработчиков был пик легких контейнеров, которые помогали\nсобирать компоненты из множества проектов в единое приложение. В основе этих\nконтейнеров лежит паттерн, известный также под общим названием \"Inversion of\nControl\" (Инверсия управления).  В этой статье я разберусь как этот паттерн\nработает, под более конкретным названием \"Dependency Injection\" (Внедрение зависимости),\nа так же сравню его с альтернативой в виде Service Locator. Выбор между ними менее\nважен чем принцип разделения конфигурирования от использования.</em>\n\nОдна из замечательных вещей в мире корпоративной Java-разработки это стремление\nк разработке открытых альтернатив господствующим технологиям J2EE. Многие эти решения\nявляются реакцией на тяжеловесные решения J2EE, также значительная часть направлена\nна альтернативные решения, что способствует генерации творческих идей. Общая проблема\nв том, как связать вместе различные элементы: как связать вместе эту веб-архитектуру\nс этим интерфейсом базы данных, которые были разработаны разными командами с плохим\nзнанием друг о друге. Несколько фреймворков приняли удар на себя и расширились,\nчто бы предоставить единую возможность сборки компонентов из различных слоев.\nОни часто упоминаются как легкие контейнеры, примерами могут быть\n[PicoContainer](http://www.picocontainer.org/) и [Spring](http://www.springframework.org/).\nВ основе этих контейнеров лежит ряд интересных принципов проектирования, вещи которые\nвыходят за рамки этих двух конкретных контейнеров и даже за рамки платформы Java\nв целом. Примеры будут написаны на Java, но, принципы применимы и к другим ОО средам.\n\n## Компоненты и Сервисы\n\nТема связывания элементов вместе отсылает к терминам <em>компонент</em> и <em>сервис</em>. Вы с\nлегкостью найдете длинные и противоречивые статьи с определением этих терминов.\nДля целей этой статьи дадим следующие определения этим терминам.\n\nПод компонентом мы имеем ввиду программное обеспечение, которое предполагается\nдля использования как есть, т.е. без возможности изменения, т.к. приложение написано\nсторонними лицами и не подлежит нашему контролю. Под \"без возможности изменения\"\nмы подразумаем что использование этого компонента не требует изменения исходного\nкода компонента, так же мы предполагаем, что авторы этого компонента могут изменить\nего исходный код в одностороннем порядке.\n\nСервис похож на компонент в том, что он используется другими приложениями. Главное\nотличие в том, что компонент используется локально (например jar-файл, dll и т.д).\nСервис используется удаленно, через некоторый удаленный интерфейс в синхронном\nили асинхронном режиме (например веб-сервис, система обмена сообщениями, RPC или сокет).\n\nВ основном в этой статье мы используем термин <em>сервис</em>, хотя большая часть\nприменима и к понятию локального компонента. В самом деле, частенько требуется\nкакой-то локальный компонент для легкого доступа к удаленному сервису. Но постоянно\nписать \"компонент или сервис\" утомительно, тем более термин сервис более современное\nпонятие в данный момент.\n\n## Простой пример\n\nЧто бы разговор был более конкретным мы будем его строить в рамках этого примера.\nЭтот один из тех супер простых примеров, который достаточно мал что бы быть реальным,\nно достаточный, что бы показать все что происходит, не впадая в болото реальности.\n\nВ этом примере мы напишем компонент, который предлагает список фильмов,\nсрежиссированных конкретным режиссером. Эта потрясающе полезная функция реализована\nодним методом:\n\n```java\nclass MovieLister...\n    public Movie[] moviesDirectedBy(String arg) {\n        List allMovies = finder.findAll();\n        for (Iterator it = allMovies.iterator(); it.hasNext();) {\n            Movie movie = (Movie) it.next();\n            if (!movie.getDirector().equals(arg)) it.remove();\n        }\n        return (Movie[]) allMovies.toArray(new Movie[allMovies.size()]);\n    }\n```\n\nРеализация этой функции примитивна, она просит объект поиска (до которого мы доберемся\nчерез мгновение) вернуть список всех известных ему фильмов. Затем отсеиваем этот\nсписок по конкретному режиссеру.\n\nОсновная цель этой статьи это объект поиска, точнее как мы связываем объект список\nс этим объектом поиска. Причина почему это интересно в том, что мы хотим чтобы\nпрекрасный метод moviesDirectedBy был полностью независим от того, как этот список\nхранится. Итак, все что метод делает, это ссылается на объект поиска, в свою\nочередь все что делает объект поиска - это знает как реагировать на метод findAll.\nМы можем вынести эту зависимость из метода путем определения интерфейса для поиска.\n\n```java\npublic interface MovieFinder {\n    List findAll();\n}\n```\n\nТеперь все это замечательно разнесено, но в какой то момент, нам потребуется реальный\nкласс, который знает как на самом деле хранятся фильмы. Для этого мы укажем его\nв конструкторе класса MovieListner\n\n```java\nclass MovieLister...  \n  private MovieFinder finder;  \n  public MovieLister() {  \n    finder = new ColonDelimitedMovieFinder(\"movies1.txt\");  \n  }\n```\n\nИмя реализующего класса основано на том факте, что мы получаем список из текстового\nфайла с разделителями. Мы не будем вдаваться в детали, главное что есть какая то реализация.\n\nИтак, если мы используем этот класс только для себя, то все замечательно.  Но что\nслучится когда наши друзья проникнутся этой великолепной функциональностью и\nпопытаются скопировать это решение к себе? Если они хранят списки фильмов в текстовом\nфайле с разделителями под именем \"movies1.txt\" то все нормально. Если у них просто\nфайл называется по другому, то все что нужно вынести имя файла в свойства файла.\nНо что если они имеют совершенно другую форму хранения списка фильмов: SQL-база,\nXML-файл, веб-сервис или какой другой формат текстового файла? В этом случае мы\nнуждаемся в другом классе для захвата данных. Теперь, поскольку мы выделили\nMovieFinder интерфейс, это не изменит нашего метода moviesDirectedBy, но мы все\nравно нуждаемся в каком-либо способе получить экземпляр нужного класса,\nреализующего объект поиска.\n\n![Зависимости, с использованием простого создания в классе списка.](/images/puremvc/dependency-inversion/figure1.jpeg)\n\nРисунок показывает зависимости для этой ситуации. Класс MovieLister зависит как\nот интерфейса, так и от реализации. Было бы лучше, если бы зависимость была\nтолько от интерфейса, но тогда как заставить работать реализацию?\n\nКласс реализующий поиск не связывается во время компиляции, так как мы не знаем\nкакую реализацию предпочтут использовать наши друзья. Вместо этого мы хотим что бы\nнаш список работал с любой реализацией, а конкретную реализацию подключали\nсобственноручно позже в какой то момент работы. Проблема в том, как связать наш\nкласс списка, который не знает о реализации поиска, но все еще знает как\nвзаимодействовать с ним что бы выполнить свою работу.\n\nВ реальных системах, мы можем иметь десятки таких сервисов и компонентов. В каждом\nслучае мы можем абстрагироваться от них, через общение посредством интерфейса\n(или использовать адаптер, если компонент не спроектирован с учетом нашего интерфейса).\nНо если мы хотим развернуть эту систему в другом месте, мы будем вынуждены использовать\nплагины для взаимодействия с этими сервисами так что мы можем использовать различную\nреализацию в зависимости от окружения.\n\nИтак, ключевая проблема как собрать эти плагины в приложении? Это одна из главных\nпроблем которую эти легковесные контейнеры решают через универсальные механизмы,\nиспользуя Inversion of Control.\n\n## Inversion of Control (Инверсия управления)\n\n[Inversion of control](http://martinfowler.com/bliki/InversionOfControl.html)\nэто общая характеристика фреймворков, поэтому сказать что эти легковесные контейнеры\nтакие особые, подобно тому что сказать мой автомобиль особенный, так как имеет колеса.\n\nВопрос такой, какой аспект управления они обращают? Мы впервые столкнулись с инверсией\nуправления в управлении пользовательским интерфейсом. Ранние пользовательские\nинтерфейсы находились под управлением самой прикладной программы. Вы можете иметь\nпоследовательность команд, на подобии: \"Введите имя\", \"введите адрес\" и ваша программа\nбудет ездить по экрану и забирать ответы на каждый вопрос. В графических интерфейсах\n(или даже screen-based) UI фреймворк будет содержать этот основной цикл и вашей\nпрограмме взамен будут предоставлены события для различных полей на экране.\nОсновное управление программы будет инвертировано, перемещения по экрану отошли\nот вас к фреймворку.\n\nДля этих контейнеров нового поколения инверсия заключается в том, как они видят\nреализацию плагина. В нашем простеньком примере список получает реализацию поиска\nнепосредственно инстанцируя его. Этот подход не дает нам право называть средство\nпоиска - [плагином](http://martinfowler.com/eaaCatalog/plugin.html). Подход,\nкогда использование таких контейнеров гарантирует, что любой пользователь плагина,\nпридерживающийся некоторых соглашений, позволяет отдельному сборщику модулей\nвнедрить реализацию в список.\n\nВ результате, мы нуждаемся в более конкретном названии для этого шаблона.\nInversion of Control слишком общий термин, который может сбить людей с толку.\nКак результат, в следствии продолжительных дискуссий со сторонниками IoC мы\nостановились на названии Dependency Injection (Внедрение зависимости).\n\nНачнем с разговора о различных формах внедрения зависимости, но следует учесть,\nчто это не единственный способ устранения зависимости между классом приложения\nи реализацией плагина. Другой паттерн, которым вы можете воспользоваться это\nService Locator, о котором мы расскажем после того как объясним Dependency Injection.\n\n## Формы Dependency Injection\n\nОсновная идея Dependency Injection заключается в наличии отдельного объекта -\nсборщика (Assembler), который подставляет в поле в классе списка реализацию\nсогласно интерфейсу поиска, результат зависимостей показан на рисунке\n\n[Зависимости для Dependency Injector](/images/puremvc/dependency-inversion/figure2.jpeg)\n\nМожно выделить три основных стиля внедрения зависимости под следующими названиями:\nConstructor Injection, Setter Injection, и Interface Injection. Если в ходе текущей\nдискуссии вы читали материал об [Inversion of Control](http://martinfowler.com/bliki/InversionOfControl.html)\nони упоминаются как тип 1 IoC (interface injection), тип 2 IoC (setter injection)\nи тип 3 IoC (constructor injection).\n\n### Constructor Injection в PicoContainer\n\nНачнем описание того, как это внедрение происходит с помощью легкого контейнера\nпод названием [PicoContainer](http://www.picocontainer.org/).\n\nPicoContainer использует конструктор что бы решить как внедрить реализацию средства\nпоиска в класс списка фильмов. Что бы это осуществилось, классу списка фильмов\nеобходимо объявить конструктор который включает все необходимое для инъекции.\n\n```java\nclass MovieLister...\n    public MovieLister(MovieFinder finder) {\n        this.finder = finder;       \n    }\n```\n\nСредство поиска также будет управляться PicoConctainer'ом, и таким  же образом\nбудет внедряться название текстового файла с данными.\n\n```java\nclass ColonMovieFinder...\n    public ColonMovieFinder(String filename) {\n        this.filename = filename;\n    }\n```\n\nЗатем, необходимо сказать PicoContainer'у какой класс реализации связать с\nкаждым интерфейсом, а также какую строку внедрить в класс средства поиска.\n\n```java\nprivate MutablePicoContainer configureContainer() {      \n    MutablePicoContainer pico = new DefaultPicoContainer();\n    Parameter[] finderParams =  {new ConstantParameter(\"movies1.txt\")};\n    pico.registerComponentImplementation(MovieFinder.class, ColonMovieFinder.class, finderParams);\n    pico.registerComponentImplementation(MovieLister.class);\n    return pico;\n}\n```\n\nЭтот конфигурационный код обычно устанавливается в другом классе. В нашем примере,\nкаждый из друзей, кто захочет использовать наш список,  может написать свой\nконфигурационный код по своему усмотрению. Конечно, общие настройки можно вынести\nв отдельный конфигурационный файл. Вы можете написать класс, который будет\nсчитывать конфигурационный файл и соответствующим образом настраивать контейнер.\nХотя PicoContainer не поддерживает такую функциональность, существует тесный проект,\nпод названием NanoContainer, который предоставляет соответствующую оболочку позволяющую\nиметь настройки в виде XML-файла. Этот NanoContainer парсит XML-файл и соответсвующим\nобразом настраивает PicoContainer. Философия этого проекта отделить файл настроек\nот основного механизма.\nДля использования контейнера необходимо написать код, подобный этому:\n\n```java\npublic void testWithPico() {\n    MutablePicoContainer pico = configureContainer();\n    MovieLister lister = (MovieLister) pico.getComponentInstance(MovieLister.class);\n    Movie[] movies = lister.moviesDirectedBy(\"Sergio Leone\");\n    assertEquals(\"Once Upon a Time in the West\", movies[0].getTitle());\n}\n```\n\nНесотря на то, что в этом примере мы использовали Construction Injection,\nPicoContainer так же поддерживает Setter Injection, хотя разработчиками этого\nконтейнера предпочтение отдается именно иньякциям с помощью конструктора.\n\n### Setter Injection в Spring\n\n[Spring framework](http://www.springframework.org/) это всеобъемлющий фреймворк\nв мире корпоративной разработки на Java. Он включает в себя слои абстаркций для\nтранзакции, сохранения, разработки веб-приложения и JDBC. Подобно PicoContainer'у\nон поддерживает как инъекции с помощью конструктора, так и с помощью set-методов,\nправда его разработчики предпочитают setter-инъекции, что делает его подходящим\nвыбором для данного примера.\n\nЧто бы принять инъекцию в наш список фильмов, мы определяем set-метод:\n\n```java\nclass MovieLister...\n    private MovieFinder finder;\n    public void setFinder(MovieFinder finder) {\n      this.finder = finder;\n    }\n```\n\nАналогично, мы определяем set-метод для имени файла:\n\n```java\nclass ColonMovieFinder...\n    public void setFilename(String filename) {\n        this.filename = filename;\n    }\n```\n\nТретий шаг - создание конфигурационного файла. Spring поддерживает конфигурирование\nкак через XML-файлы, так и через код, правда предпочтительней делать это через XML.\n\n```xml\n<beans>\n    <bean id=\"MovieLister\" class=\"spring.MovieLister\">\n        <property name=\"finder\">\n            <ref local=\"MovieFinder\"/>\n        </property>\n    </bean>\n    <bean id=\"MovieFinder\" class=\"spring.ColonMovieFinder\">\n        <property name=\"filename\">\n            <value>movies1.txt</value>\n        </property>\n    </bean>\n</beans>\n```\n\nПротестировать все это можно следующим образом:\n\n```java\npublic void testWithSpring() throws Exception {\n    ApplicationContext ctx = new FileSystemXmlApplicationContext(\"spring.xml\");\n    MovieLister lister = (MovieLister) ctx.getBean(\"MovieLister\");\n    Movie[] movies = lister.moviesDirectedBy(\"Sergio Leone\");\n    assertEquals(\"Once Upon a Time in the West\", movies[0].getTitle());\n}\n```\n\n### Interface Injection\n\nТретья техника внедрения определяет и использует интерфейс. Фреймворк [Avalon](http://avalon.apache.org/) и\nспользует как раз такой подход.\n\nВ рамках этой техники, сначала мы объявляем интерфейс, через который будет происходить\nинъекция.  \n\nВот сам интерфейс для внедрения средства поиска фильмов в объект.\n\n```java\npublic interface InjectFinder {\n    void injectFinder(MovieFinder finder);\n}\n```\n\nЭтот интерфейс будет объявляться теми, кто поддерживает интерфейс MovieFinder.\nТакже интерфейс должен быть реализован всеми классами, которые хотят использовать\nсредство поиска фильмов, например наш список.\n\n```java\nclass MovieLister implements InjectFinder...\n    public void injectFinder(MovieFinder finder) {\n        this.finder = finder;\n    }\n```\n\nМы используем аналогичный подход что бы внедрить имя файла в реализации средства поиска фильмов.\n\n```java\npublic interface InjectFinderFilename {\n    void injectFilename (String filename);\n}\nclass ColonMovieFinder implements MovieFinder, InjectFinderFilename......\n    public void injectFilename(String filename) {\n        this.filename = filename;\n    }\n```\n\nЗатем, как обычно, нам требуется настроить окружение, что бы связать реализации.\nДля простоты мы сделаем это прямо в коде.\n\n```java\nclass Tester...\n    private Container container;\n\n     private void configureContainer() {\n       container = new Container();\n       registerComponents();\n       registerInjectors();\n       container.start();\n    }\n```\n\nЭта настройка состоит из двух частей. Первая - это регистрация компонентов,\nчерез соответствие ключ - значение, этот этап похож на предыдущие примеры.\n\n```java\nclass Tester...\n  private void registerComponents() {\n    container.registerComponent(\"MovieLister\", MovieLister.class);\n    container.registerComponent(\"MovieFinder\", ColonMovieFinder.class);\n  }\n```\n\nИ новый этап, это регистрация инжекторов, которые будут \"внедрять\" зависимые компоненты.\nКаждый интерфейс инжектора требует немного кода для внедрения в зависимые объекты.\nЗдесь мы достигаем это, за счет регистрации объектов-инжекторов в контейнере\n\n```java\nclass Tester...\n  private void registerInjectors() {\n    container.registerInjector(InjectFinder.class, container.lookup(\"MovieFinder\"));\n    container.registerInjector(InjectFinderFilename.class, new FinderFilenameInjector());\n  }\n```\n\nКаждый объект-инжектора реализует интерфейс инжектора.\n\n```java\npublic interface Injector {\n  public void inject(Object target);\n}\n```\n\nКогда зависимость - это класс написанный для этого контейнера, то имеет смысл\nдля компонента реализовать интерфейс-инжектора непосредственно, как мы делаем здесь\nс средством поиска фильмов. Для общих классов, таких как строка, мы используем\nвнутренний класс, в пределах конфигурационного кода.\n\n```java\nclass ColonMovieFinder implements Injector......\n  public void inject(Object target) {\n    ((InjectFinder) target).injectFinder(this);        \n  }\nclass Tester...\n  public static class FinderFilenameInjector implements Injector {\n    public void inject(Object target) {\n      ((InjectFinderFilename)target).injectFilename(\"movies1.txt\");      \n    }\n  }\n```\n\nПример когда используем контейнер.\n\n```java\nclass IfaceTester...\n    public void testIface() {\n      configureContainer();\n      MovieLister lister = (MovieLister)container.lookup(\"MovieLister\");\n      Movie[] movies = lister.moviesDirectedBy(\"Sergio Leone\");\n      assertEquals(\"Once Upon a Time in the West\", movies[0].getTitle());\n    }\n```\n\nКонтейнер использует объявленные интерфейсы инъекции что бы выяснить зависимости,\nа так же инжекторы, что бы внедрить правильные зависимости. (Реализация указанного\nконтейнера, которую мы сделали, не так важна для этой техники, поэтому мы не будуем\nее демонстрировать, тем более увидев ее вы рассмеетесь.)\n\n## Использование Service Locator\n\nГлавное преимущество Dependency Injector в том, что убирается зависимость\nкласса MovieLiester от конкретной реализации средства поиска MovieFinder.\nЭто позволяет нам дать список фильмов друзьям, которые могут использовать\nсвою реализацию в зависимости от своего окружения. Инъекции - не единственный\nспособ разорвать эту зависимость, другой способ - это использовать\n[service locator](http://java.sun.com/blueprints/corej2eepatterns/Patterns/ServiceLocator.html).\n\nОсновная идея локатора сервисов заключена в объекте, который знает как получить\nвсе сервисы, в котором нуждается приложение. Таким образом, сервис локатор для\nданного приложения, располагает методом, который возвращает средство поиска фильмов,\nкогда это средство потребуется. Конечно, это всего лишь немного сдвигает бремя,\nнам все еще необходимо получить локатор в списке фильмов. Зависимости показаны на рисунке\n\n[Зависимости для сервис локатора](/images/puremvc/dependency-inversion/figure3.jpeg)\n\nВ этом случае, мы будем использовать локатор сервисов, как одиночку\n[Registry](http://martinfowler.com/eaaCatalog/registry.html).\nНаш список затем может использовать его, что бы получить средство поиска.\n\n```java\nclass MovieLister...\n    MovieFinder finder = ServiceLocator.movieFinder();\nclass ServiceLocator...\n    public static MovieFinder movieFinder() {\n        return soleInstance.movieFinder;\n    }\n    private static ServiceLocator soleInstance;\n    private MovieFinder movieFinder;\n```\n\nКак и в случае с использованием внедрений, мы должны настроить локатор сервисов.\nЗдесь мы делаем это прямо в коде, но не так уж и трудно использовать механизм,\nкоторый будет считывать соответствующие данные из конфигурационного файла.\n\n```java\nclass Tester...\n    private void configure() {\n        ServiceLocator.load(new ServiceLocator(new ColonMovieFinder(\"movies1.txt\")));\n    }\nclass ServiceLocator...\n    public static void load(ServiceLocator arg) {\n        soleInstance = arg;\n    }\n\n    public ServiceLocator(MovieFinder movieFinder) {\n        this.movieFinder = movieFinder;\n    }\n```\n\nВот, тестовый код:\n\n```java\nclass Tester...\n    public void testSimple() {\n        configure();\n        MovieLister lister = new MovieLister();\n        Movie[] movies = lister.moviesDirectedBy(\"Sergio Leone\");\n        assertEquals(\"Once Upon a Time in the West\", movies[0].getTitle());\n    }\n```\n\nМы часто слышим жалобы, что эти локаторы сервисов - плохая штука, потому что они\nне тестируемые, т.к. невозможно подменить реализацию. Конечно, вы можете спроектировать\nих так ужасно что бы попасть в эту передрягу, а можете и не попасть. Для этого\nэкземпляр локатора сервисов должен быть простым контейнером данных. Тогда мы легко\nможем создать локатор, с тестовой реализацией для моих сервисов.\n\nДля более изощренных локаторов мы можем создать подкласс локатора сервисов и\nпоместить его в реестр. Мы можем изменить статические методы вызвав доступные методы\nна целевом экземпляре напрямую. Мы можем предоставить набор конкретных локаторов,\nиспользуя набор конкретных хранилищ. Все это может быть сделано без изменения\nклиентов локатора сервисов.\n\nЗадуматься об этой проблеме стоит тогда, когда локатор сервисов это реестр,  \nно не одиночка. Шаблон одиночка предлагает простой способ реализации реестра,\nхотя это решение легко изменить.\n\n### Использование принципа отделения интерфейса для локатора\n\nОдна из проблем, с подходом, описанным ранее, это то, что MovieLister зависит\nот целого класса сервис локатора, несмотря на то что использует только один сервис.\nМы можем избавиться от этого, используя принцип\n[отделения интерфейса](http://www.objectmentor.com/resources/articles/isp.pdf).\nТаким образом, вместо полного использования интерфейса сервис локатора,\nнаш список может объявить только ту часть, в которой он нуждается.\n\n```java\npublic interface MovieFinderLocator {\n    public MovieFinder movieFinder();\n```\n\nЗатем, локатору необходимо реализовать этот интерфейс, что бы обеспечить доступ\nк средству поиска.\n\n```java\nMovieFinderLocator locator = ServiceLocator.locator();\n    MovieFinder finder = locator.movieFinder();\n    public static ServiceLocator locator() {\n        return soleInstance;\n    }\n    public MovieFinder movieFinder() {\n        return movieFinder;\n    }\n    private static ServiceLocator soleInstance;\n    private MovieFinder movieFinder;\n```\n\nВы наверно заметили, что поскольку мы используем интерфейс, мы больше не можем\nобращаться к статическим методам для доступа к сервису. Мы должны использовать\nкласс, для получения экземпляра локатора, и только потом, можем использовать его,\nдля получения всего необходимого.\n\n### Динамический Service Locator\n\nПриведенный выше пример был статический, так как класс локатора сервисов имеет\nстатические методы для всех необходимых нам служб. Это не единственный способ,\nвы также можете сделать динамический локатор сервисов, который позволяет размещать\nлюбой сервис в себе прямо во время выполнения.\n\nВ этом случае, локатор сервисов использует карту вместо статических полей для каждого\nсервиса и предоставляет общие методы для получения и загрузки сервисов.\n\n```java\nclass ServiceLocator...\n    private static ServiceLocator soleInstance;\n    public static void load(ServiceLocator arg) {\n        soleInstance = arg;\n    }\n    private Map services = new HashMap();\n    public static Object getService(String key){\n        return soleInstance.services.get(key);\n    }\n    public void loadService (String key, Object service) {\n        services.put(key, service);\n    }\n```\n\nКонфигурация включает загрузку сервиса с соответствующим ключем.\n\n```java\nclass Tester...\n    private void configure() {\n        ServiceLocator locator = new ServiceLocator();\n        locator.loadService(\"MovieFinder\", new ColonMovieFinder(\"movies1.txt\"));\n        ServiceLocator.load(locator);\n    }\n```\n\nМы используем сервис, используя ту же самую ключевую строку.\n\n```java\nclass MovieLister...\n    MovieFinder finder = (MovieFinder) ServiceLocator.getService(\"MovieFinder\");\n```\n\nВ целом, такой подход хорош. Хотя, это безусловно гибко, но не очень явно.\nЕдинственный способ добраться до сервиса через текстовые ключи. Мы предпочитаем\nявные методы, так как их проще найти, глядя на объявленный интерфейс.\n\n### Использование и локатора и инжектирования\n\nDependency Injection и Service Locator не являются взаимозаменяемыми. Хороший пример\nиспользования обоих представлен в Avalon фреймворке. Avalon использует локатор\nсервисов, в то же время он использует инжектирование, что бы сообщить компонентам где найти локатор.\n\nПростой пример с использованием такого подхода.\n\n```java\npublic class MyMovieLister implements MovieLister, Serviceable {\n    private MovieFinder finder;\n\n    public void service( ServiceManager manager ) throws ServiceException {\n        finder = (MovieFinder)manager.lookup(\"finder\");\n    }\n```\n\nМетод service - пример интерфейса инжектора, позволяющего контейнеру внедрить\nв MyMovieLister менеджера сервисов. ServiceManager - пример ServiceLocator'а.\nВ этом примере, список не хранит менеджера у себя, вместо этого он непосредственно\nиспользует его для нахождения средства поиска, который и сохраняет у себя.\n\n## Решение, какой вариант использовать\n\nДо сих пор мы сосредотачивались на обзоре. Теперь поговорим об их преимуществах и\nнедостатках, что бы помочь выяснить какие использовать и когда.\n\n### Service Locator vs Dependency Injection\n\nОсновной выбор между Service Locator и Dependency Injection. Первый момент\nзаключается в том, что в обоих случаях код приложения не зависит от конкретных\nреализаций интерфейса сервиса. Основное различие этих двух решений, в том, как\nэта реализация предоставляется прикладному классу. В случае локатора сервиса,\nприкладной класс просит реализацию явно. В случае в внедрением, нет никакого\nявного запроса, сервис \"впрыскивается\" в прикладной класс - отсюда инверсия управления.\n\nИнверсия управления - общая черта фреймворков, но за это надо платить. Как правило\nценой понимания происходящего, что ведет к проблемам при отладке. В целом, мы пытаемся\nизбегать этого подхода, если это действительно не нужно явно. Это не значит что\nэтот способ плох, просто его применение должно быть оправдано перед более простыми вариантами.\n\nКлючевое различие в том, что с Service Locator каждый пользователь сервиса зависит\nот локатора. Локатор может скрывать зависимость от других реализаций, но ваша\nреализация должна знать о локаторе. Таким образом решение между локатором и внедрением\nсводится к тому, где именно эта зависимость становится проблемой.\n\nИспользование внедрения зависимости может облегчить видимость, каковы составляющие\nзависимости. С внедрением зависимости вы можете просто взглянуть на механизм внедрения,\nтакой как конструктор и увидеть зависимости. С сервис локатором, вы должны отыскать\nисточник вызова локатора. Современные среды разработки могут облегчить нахождение,\nно это все равно не так просто, как взглянуть на конструктор или set-методы.\n\nМного из этого зависит от природы пользователя сервиса. Если вы создаете приложение\nс различными классами, использующими сервис, тогда зависимость прикладных классов\nот локатора не так уж велика. В нашем случае, предоставление списка фильмов друзьям\nотлично будет работать с сервис локатором. Все что им потребуется это настроить\nлокатор на нужную реализацию, либо прямо в коде, либо через конфигурационный файл.\n\nДругой вариант, если наш список фильмов является компонентом для разработчиков\nдругих приложений. В этом случае, мы ничего не знаем об API локатора сервисов,\nкоторый наши клиенты собираются использовать. У каждого клиента могли бы быть свои\nсобственные, не совместимые локаторы сервисов. Мы можем обойти часть ограничений\nпосредством отдельного интерфейса. Каждый клиент для своего локатора может написать\nадаптер, согласно нашему интерфейсу, но в любом случае, мы нуждаемся в доступности\nпервого локатора, для поиска нашего конкретного интерфейса. И как только появляется\nадаптер, тогда простота прямого доступа к локатору начинает пробуксовывать.\n\nТак как с инжектором, у вас нет зависимости от компонента-инжектора, то компонент\nне может получить дополнительные услуги от инжектора, так как он уже был настроен.\n\nОбщая причина, почему люди предпочитают внедрение зависимости в том, что этот подход\nделает тестирование проще. Дело в том, что при тестировании необходимо легко\nподменять реальную реализацию сервисов с помощью заглушек или mock-объектов.\nОднако, на самом деле здесь нет никакой разницы между внедрением зависимости и\nсервис локатором: оба очень хорошо поддаются подмене. Я подозреваю, что эта критика\nисходит из тех проектов, в которых люди не уделяют достаточного внимания тому,\nчто локатор сервисов может легко подменяться. В этом случае помогает постоянное\nтестирование, если вы не можете легко подменить сервис для тестирования, тогда это\nозначает что у вас серьезные проблемы с вашим дизайном.\n\nКонечно, проблему тестирования усугубляют среды, которые достаточно навязчивые,\nнапример Java EJB фреймворк. Подобные фреймворки должны сводить к минимуму свое\nвлияние на прикладной код, и в частности не должны делать вещи, которые приводят\nк замедлению цикла edit-execute. Использование расширений для замены тяжеловесных\nкомпонентов должно способствовать этому процессу, который является жизненно важным\nдля таких практик как разработка через тестирование (TDD).\n\nТак что главная проблема в людях, которые пишут код, который впоследствии используется\nв приложениях им не подконтрольных. В этом случае даже минимальное предположение\nо Service Locator это проблема.\n\n### Сравнение внедрение посредством конструктора и set-методов\n\nДля объединения сервисов, у вас всегда должно быть какое-либо соглашение. Преимущество\nинжектирования прежде всего в том, что оно нуждается в простом соглашении, по-крайней\nмере для инъекции через конструктор и set-методы. Вы не должны делать ничего\nособенного с вашим компонентом и при этом его достаточно просто настроить.\n\nВнедрение посредством интерфейса более затратно, потому что вам необходимо\nнаписать множество интерфейсов. Для небольшого набора интерфейсов требуется контейнер,\nна подобии подхода как в Avalon, это не так уж и плохо. Правда сборка компонентов и\nзависимостей достаточно затратна, поэтому современные контейнеры в основном делают\nс использованием внедрений через конструктор или set-методы.\n\nВыбор между внедрением зависимостей через конструктор или set-методы более интересен,\nт.к.отражает общую проблему объектно-ориентированного программирования - должны\nли вы устанавливать поля через конструктор или отдать предпочтение set-методам.\n\nМы довольно давно работаем с объектами и стараемся по возможности создавать их\nполностью через конструктор. Этот совет приводит нас к Кент Беку\n[Smalltalk Best Practice Patterns](http://www.amazon.com/exec/obidos/ASIN/013476904X):\nConstructor Method and Constructor Parameter Method. Конструкторы с параметрами позволяют\nвам создавать валидные объекты очевидным способом. Если существует несколько способов\nсоздания правильного объекта, сделайте множество конструкторов с различной комбинацией параметров.\n\nЕще одно преимущество инициализации объекта в конструкторе это прозрачно проинициализировать\nскрытые неизменяемые поля без предоставления set-методов. Это очень важно - если\nникто не должен изменять эти поля, то это действительно должно быть так. Если вы\nиспользуете set-методоты то это может привести к беде.\n\nНо в любой ситуации есть исключения. Если у вас много параметров в конструкторе\nэто может выглядить пошло, особенно в языках без ключевых параметров. С другой\nстороны, часто длинные конструкторы свидетельствуют о перегруженности объекта и\nдолжны быть разбиты, хотя бывает что это действительно оправдано.\n\nЕсли у вас существует несколько способов инициализации валидного объекта, то\nтрудно все это отобразить в конструкторах, т.к. конструкторы могут различаться\nтолько числом параметров и их типом. В этом случае предпочтительней использовать\nфабричные методы (Factory Methods), которые могут комбинировать различные конструкторы\nи set-методы для инициализации объекта. Проблема с классическими фабричными методами\nдля связывания компонентов заключена в том, что они обычно рассматриваются как\nстатические методы и вы не можете иметь их на интерфейсах. Вы можете создать фабричный класс.\nФабричный сервис часто неплохая тактика, но фабрику все еще надо проинициализировать,\nиспользуя одну из приведенных техник.\n\nКонструкторы так же страдают, если у вас имеются простые параметры, типа строк.\nС использованием set-методов, вы можете каждому методу дать понятное название,\nпоясняющее что он делает. С конструкторами вы только полагаетесь на позицию,\nза которой труднее следить.\n\nЕсли у вас несколько конструкторов и есть наследование, то все может стать довольно\nзапутанным. Для правильно порядка вы вызываете конструкторы суперклассов попутно\nдобавляя новые параметры. Это может привести к еще большему нагромождению конструкторов.\n\nНесмотря на недостатки мы предпочитаем внедрять зависимости через конструктор,\nно будьте готовы перейти к инъекциям через set-методы, как только вышеизложенные\nпроблемы начнут появляться.\n\n### Настройка в коде или в конфигурационном файле\n\nОтдельный, но часто связанный вопрос заключается в том, использовать ли конфигурационные\nфайлы или код на основе API для связывания сервисов. Для большинства приложений,\nкоторые могут быть развернуты где угодно, применение отдельного конфигурационного\nфайла более предпочтительно. Практически всегда это XML-файл, что естественно.\nХотя существуют случаи когда для связывания сервисов проще использовать программный код.\nОдин из таких случаев, когда у вас простое приложение, которое не имеет множества\nразличных вариантов развертывания. В этом случае код может быть понятнее, чем отдельный XML файл.\n\nПротивоположный вариант, когда связывание довольно сложное, включающее условные шаги.\nКак только начинаются ограничения связанные с языком XML, то лучше использовать\nреальный язык, с полным набором синтаксиса. Затем вы можете написать класс сборщик,\nкоторый делает связывание. Если у вас есть различные сценарии сборки вы можете\nпредоставить несколько классов сборщиков и использовать простой конфигурационный\nфайл для навигации между ними.\n\nЛюди рвутся определять конфигурационные файлы. Хотя программный язык делает конфигурирование\nболее мощным и гибким. Современные языки могут компилировать небольшие сборщики,\nкоторые могут использоваться для сборки дополнений для больших систем. Если компиляция\nзатратна, тогда есть скриптовые языки, которые так же хороши.\n\nЧасто говорят, что конфигурационные файлы не должны использовать языки программирования\nпоскольку они должны быть адаптированы к не программистам. Но как часто такое случается?\nВы действительно думаете, что далекие от программирования люди будут изменять server-side приложения?\nКонфигурации без языковых конструкций работают хорошо пока они просты.\nИначе следует серьезно задуматься о применении соответствующего языка программирования.\n\nЛучше всегда предоставлять способ сделать всю конфигурацию проще, используя\nпрограммный интерфейс и затем обращаться к отдельной конфигурации, как к дополнительной\nфункции. Вы можете легко встроить обработку файла конфигурации используя программный\nинтерфейс. Если вы пишите компонент, то оставьте право выбора пользователю использовать\nпрограммный интерфейс, формат вашего конфигурационного файла или написать свой\nсобственный вариант формата конфигурационного файла и подсунуть используя программный интерфейс.\n\n### Разделение конфигурирования от использования\n\nВажный момент, что бы конфигурирование сервиса было отделено от его использования.\nДействительно, это является основополагающим принципом проектирования, который\nзаключается в отделении интерфейса от реализации. Это то, что мы наблюдаем в\nобъектно-ориентированных программах, когда условная логика решает какой класс\nинстанцировать, что бы затем в будущем вычислить какое условие сработало на основе\nполиморфизма, а не дублирования кода условия.\n\nЭто разделение особенно полезно, когда вы используете внешние элементы, такие как\nкомпоненты и сервисы. Первый вопрос - желаете ли в отложить выбор класса реализации\nв зависимости от конкретного развертывания? Если да, то необходима некая реализация дополнений.\nЭтот конфигурационный механизм может в последствии настроить локатор сервисов или\nиспользовать внедрение для настройки объектов напрямую.\n\n## Некоторые дополнительные вопросы\n\nВ данном разделе мы рассмотрели основные вопросы организации Инверсии управления\nчерез Инверсию зависимости (инъекцию) и Сервис локатор. Это в большей степени\nтеоретическая глава, примеры кода даны только чтобы раскрыть идею.\nВ следующей главе мы рассмотрим более практичные вопросы применительно нашего\nфреймворка LeanES.","description":"Попытки разобраться с принципом ООП Инверсия зависимостей (Dependency Inversion Principle) привели к статье Мартина Фаулера \"Inversion of Control Containers and the Dependency Injection pattern\" оригинал которой доступен здесь. Перевод на русский язык можно..."}}}