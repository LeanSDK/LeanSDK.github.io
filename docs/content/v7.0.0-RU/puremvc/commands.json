{"data":{"type":"contents","id":"puremvc/commands","attributes":{"content":"Определенный <em>Фасад</em> инициализирует <em>Контроллер</em>, передавая <em>Командам</em>\nсвязанные с ними <em>Оповещения</em> необходимые для старта приложения.\n\nДля каждой связки (Mapping), <em>Контроллер</em> регистрируется как <em>Наблюдатель</em>\nнад данным <em>Оповещением</em>. Когда происходит <em>Оповещение</em>, <em>Контроллер</em>\nсоздает экземпляр соответствующей <em>Команды</em>. И, наконец, <em>Контроллер</em>\nвызывает у созданной команды метод execute(), передавая в него данное\n<em>Оповещение</em>.\n\nКоманды единоразовы; они создаются по требованию (приходит\n<em>Оповещение</em>), и после их исполнения (вызов метода execute) они должны\nудаляться. В связи с чем, важно не создавать экземпляры и не хранить ссылки\nна <em>Команды</em> в объектах, которые будет использоваться в течении долго срока\nв вашем приложении.\n\n## Использование Макро- и Простых команд\nКоманды, как и все классы фреймворка PureMVC, реализовывают\nинтерфейс, а именно интерфейс ICommand. PureMVC содержит две\nреализацию ICommand интерфейса для Макро-команды которую вы можете с легкостью расширять.\n\nКласс Command (Макрокоманда) позволяет выполнять несколько\nподкоманд последовательно, каждой из которых будет после создания\nпередан экземпляр текущего Оповещения.\n\nКласс Command из конструктора вызывает свой метод\ninitializeSubCommands. Вы должны переопределить его в своем классе\nмакрокоманды, для вызова метода addSubCommand для каждой команды,\nкоторую вы ходите добавить в макрокоманду. Вы можете добавлять любые\n<em>Команды</em> или <em>Макрокоманды</em>.\n\nДля того, чтобы кастомная команда была \"Простой\", достаточно переопределить метод\nexecute, который принимает в качестве параметра экземпляр INotification.\nВписываете вашу функциональность в метод execute и все готово к работе.\n\n## Слабое связывание Команд с Медиаторами и Прокси\n<em>Команды</em> выполняются <em>Контроллером</em> в результате отправки <em>Оповещения</em>.\n<em>Команды</em> не должны быть созданы и выполнены никем кроме <em>Контроллера</em>.\n\nЧтобы общаться и взаимодействовать с другими частями системы, <em>Команды</em>\nмогут:\n\n* Регистрировать, удалять или проверять существуют ли <em>Медиаторы</em>,\n<em>Прокси</em> и <em>Команды</em>.\n* Посылать <em>Оповещения</em>, для получения ответной реакции от других\nкоманд или <em>Медиаторов</em>.\n* Получать экземпляры <em>Прокси</em> и <em>Медиаторов</em> и управлять ими\nнапрямую.\n\n<em>Команды</em> позволяют нам легко переключать элементы <em>Представления</em>\nмежду различными состояниями (через <em>Медиаторы</em>), или передавать\nданные к различным частям этих элементов.\n\nОни могут быть использованы для осуществления транзакционного\nвзаимодействия с <em>Моделью</em>, которую охватывают несколько <em>Прокси</em>,\nтребовать отправки <em>Оповещения</em> по окончанию транзакции, или\nобрабатывать непредвиденные ситуации (exceptions) и принимать\nсоответствующие действия.\n\n## Взаимодействие сложных действий и бизнес-логики\nместах вашего приложения, где вы могли бы разместить код (<em>Команд</em>,\n<em>Медиаторов</em> и <em>Прокси</em>) неизбежно и периодически будет возникать вопрос:\n\nКакой код и где писать? Что конкретно должна делать <em>Команда</em>?\n\nПервое разделение логики в вашем приложении коснется бизнес-логики и\nлогики предметной области.\n\nВ командах находится бизнес-логика нашего приложения; ожидается, что\nтехническая реализация сценариев использования нашего приложения\nбудет выполняться на уровне модели предметной области (Domain Model).\nЭто подразумевает координацию <em>Модели</em> и состояниями <em>Представления</em>.\n\nМодель поддерживает свою целостность, используя <em>Прокси</em>, которые\nразмещены в логике предметной области (Domain Logic), открывая API для\nработы с объектами данных. Они инкапсулируют весь доступ к моделям\nданных, находящимся на клиенте или на сервере, для того чтобы остальная\nчасть приложения которая работает с данными, могли иметь к ним\nсинхронный или асинхронный доступ.\n\n<em>Команды</em> могут быть использованы для управления рядом действий в\nсистеме, которые должны происходить в определенном порядке, с\nвозможностью того что результат предыдущего действия может быть\nиспользован для последующего.\n\n<em>Медиаторы</em> и <em>Прокси</em> должны предоставлять крупномодульные интерфейсы\n<em>Командам</em> (и наоборот), которые скрывают реализацию объектов данных и\nкомпонентов представления, которыми они управляют.\n\nЗаметьте, что когда мы говорим про компонент представления, мы имеем в\nвиду кнопку или виджет, с которым непосредственно взаимодействует\nпользователь. Когда мы говорим об объекте данных, то подразумеваем\nпроизвольные структуры данных, а также удаленные сервисы, которые\nмогут быть использованы для хранения или получения данных.\n\n<em>Команды</em> взаимодействуют с <em>Медиаторами</em> и <em>Прокси</em>, но должны быть\nизолированы от граничных реализаций. Вот пример того как <em>Команда</em>\nиспользуется для подготовки приложения к работе:\n\n```js\nimport type { NotificationInterface } from '../interfaces/NotificationInterface';\n\nexport default (Module) => {\n  const {\n    STARTUP, STARTUP_COMPLETE,\n    Command,\n    PrepareControllerCommand,\n    PrepareModelCommand,\n    PrepareViewCommand,\n    initialize, partOf, meta, method, nameBy\n  } = Module.NS;\n\n  @initialize\n  @partOf(Module)\n  class StartupCommand extends Command {\n    @nameBy static  __filename = __filename;\n    @meta static object = {};\n\n    @method initializeSubCommands(): void {\n      this.addSubCommand(PrepareControllerCommand);\n      this.addSubCommand(PrepareModelCommand);\n      this.addSubCommand(PrepareViewCommand);\n    }\n\n    @method execute<T = ?any>(note: NotificationInterface<T>): void {\n      super.execute(note);\n      this.facade.removeCommand(STARTUP);\n      this.send(STARTUP_COMPLETE);\n    }\n  }\n}\n```\n\nЭто <em>макрокоманда</em>, которая содержит три подкоманды, которые при вызове\nмакрокоманды исполняются в порядке очереди (FIFO).\n\nЭто создает 'очередь' верхнего уровня из действий, которые должны быть\nвыполнены на старте приложения. Но что конкретно должны мы сделать, и\nв каком порядке?\n\nПрежде чем пользователь увидит или сможет взаимодействовать с\nприложением и его данными, <em>Модель</em> должна быть надлежащим образом\nподготовлена. Как только это сделано, <em>Представление</em> может быть\nподготовлено для отображения данных <em>Модели</em> и позволить пользователю\nвзаимодействовать с ними.\n\nСледовательно, процесс старта обычно состоит из трех обширных групп\nопераций — подготовка <em>Контроллер</em>, <em>Модели</em>, и последующая подготовка\n<em>Представления</em>.\n\n```js\nimport type { NotificationInterface } from '../interfaces/NotificationInterface';\n\nexport default (Module) => {\n  const {\n    MSG_FROM_CONSOLE, CLEAR_CONSOLE,\n    Command,\n    initialize, partOf, meta, method, nameBy\n  } = Module.NS;\n\n  @initialize\n  @partOf(Module)\n  class PrepareControllerCommand extends Command {\n    @nameBy static  __filename = __filename;\n    @meta static object = {};\n\n    @method execute<T = ?any>(note: NotificationInterface<T>): void {\n      this.facade.addCommand(MSG_FROM_CONSOLE, 'SimpleCommand');\n      this.facade.addCommand(CLEAR_CONSOLE, 'SimpleScript');\n    }\n  }\n}\n```\n\nПодготовка <em>Контроллера</em>, обычно, является простым созданием и регистрацией\nвсех <em>Команд</em>, в которых приложение будет нуждаться при запуске.\n\nПример команды PrepareControllerCommand, это Простая команда, которая\nподготавливает <em>Контроллер</em> к дальнейшей работе. Это первая из подкоманд\nмакрокоманды, и поэтому она будет выполнена первой.\n\nЧерез <em>конкретный Фасад</em>, она регистрирует те <em>Команды</em>, которые\nсистема будет использовать при запуске.\n\n```js\nimport type { NotificationInterface } from '../interfaces/NotificationInterface';\nimport type { ApplicationInterface } from '../interfaces/ApplicationInterface';\n\nexport default (Module) => {\n  const {\n    APPLICATION_PROXY, SIMPLE_PROXY,\n    Command,\n    initialize, partOf, meta, method, nameBy\n  } = Module.NS;\n\n  @initialize\n  @partOf(Module)\n  class PrepareModelCommand extends Command {\n    @nameBy static  __filename = __filename;\n    @meta static object = {};\n\n    @method execute<T = ?any>(note: NotificationInterface<T>): void {\n      const app: ApplicationInterface = note.getBody();\n      this.facade.addProxy(APPLICATION_PROXY, 'ApplicationProxy', app.initialState);\n      this.facade.addAdapter('SimpleAdapter');\n      this.facade.addProxy(SIMPLE_PROXY, 'SimpleProxy');\n    }\n  }\n}\n```\n\nПодготовка <em>Модели</em>, обычно, является простым созданием и регистрацией\nвсех <em>Прокси</em>, в которых приложение будет нуждаться при запуске.\n\nПример команды PrepareModelCommand, это Простая команда, которая\nподготавливает <em>Модель</em> к дальнейшей работе.\n\nЧерез <em>конкретный Фасад</em>, она создает и регистрирует те <em>Прокси</em>, которые\nсистема будет использовать при запуске. Заметьте, что <em>Команда</em> не делает\nникаких манипуляций или инициализаций с данными <em>Модели</em>. <em>Прокси</em>\nотвечает за любое получение данных, создание или инициализацию\nнеобходимых <em>Объектов Данных</em> для использования в системе.\n\n```js\nimport type { NotificationInterface } from '../interfaces/NotificationInterface';\nimport type { ApplicationInterface } from '../interfaces/ApplicationInterface';\n\nexport default (Module) => {\n  const {\n    APPLICATION_MEDIATOR, SHELL, LOGGER_MODULE, SIGNALS_GENERATOR,\n    Command,\n    initialize, partOf, meta, method, nameBy\n  } = Module.NS;\n\n  @initialize\n  @partOf(Module)\n  class PrepareViewCommand extends Command {\n    @nameBy static  __filename = __filename;\n    @meta static object = {};\n\n    @method execute<T = ?any>(note: NotificationInterface<T>): void {\n      console.log('PrepareViewCommand execute()');\n      const app: ApplicationInterface = note.getBody();\n\n      this.facade.addMediator(LOGGER_MODULE, 'LoggerModuleMediator');\n      this.facade.addMediator(SHELL, 'ShellJunctionMediator');\n      this.facade.addMediator(APPLICATION_MEDIATOR, 'ApplicationMediator', app);\n\n      this.facade.activateMediator(APPLICATION_MEDIATOR);\n      this.facade.activateMediator(LOGGER_MODULE);\n      this.facade.activateMediator(SHELL);\n\n      if (!app.isLightweight) {\n        this.facade.addMediator(SIGNALS_GENERATOR, 'SignalsMediator');\n        this.facade.activateMediator(SIGNALS_GENERATOR);\n        this.facade.addMediator('SimpleMediator');\n        this.facade.activateMediator('SimpleMediator');\n      }\n    }\n  }\n}\n```\n\nЭто простая <em>команда</em> которая подготавливает <em>Представление</em> для работы.\nЭто последняя из подкоманд <em>макрокоманды</em>, следовательно, будет\nвыполнена последней.\n\nОтметьте, что создается и регистрируется только <em>Медиатор</em>\nApplicationMediator, который обслуживает компонент представления\nприложения.\n\nВ дальнейшем, тело Оповещения передается в конструктор медиатора. Это\nссылка на приложение, переданная самим приложением вместе с\n<em>Оповещением</em>, когда первоначальное <em>Оповещение</em> STARTUP было послано.\n(Согласно предыдущему примеру приложения MyApp.)\n\nПриложение это в некоторой степени специальный компонент\n<em>Представления</em>, в котором реализуются и находятся в качестве потомков\nвсе другие компоненты <em>Представления</em>, которые инициализируются при\nзапуске приложения.\n\nДля взаимосвязи с остальной частью системы, компоненты <em>Представления</em>\nдолжны обладать <em>Медиаторами</em>. И создание этих <em>Медиаторов</em> требует\nссылку на компоненты <em>Представления</em>, с которыми они будут работать, а\nэто на данном этапе известно только приложению.\n\n<em>Медиатор</em> приложения - это единственный класс, которому допускается\nзнать все про реализацию <em>Представления</em> приложения, так что создание\nоставшихся <em>Медиаторов</em> будет размещена внутри его конструктора.\n\nИспользуя эти три команды, мы обеспечили последовательную\nинициализацию <em>Модели</em> и <em>Представления</em>. При этом <em>Команды</em> не должны\nзнать много о <em>Модели</em> или о <em>Представлении</em>.\n\nПри изменении <em>Модели</em> или реализации <em>Представления</em>, <em>Прокси</em> и\n<em>Медиаторы</em> должны быть изменены соответствующим образом.\nБизнес-логика внутри Команд не должна зависеть от изменений,\nпроисходящих в областях применения.\n\n<em>Модель</em> должна формировать «логику предметной области», поддерживая\nцелостность данных внутри <em>Прокси</em>. <em>Команды</em> выполняют\n«транзакционную» или «бизнес» логику в <em>Модели</em>, формируя координацию\nтранзакций <em>мульти-Прокси</em> или обрабатывая и сообщая об исключительных\nситуациях.","description":"Определенный Фасад инициализирует Контроллер, передавая Командам связанные с ними Оповещения необходимые для старта приложения. \n\nДля каждой связки (Mapping), Контроллер регистрируется как Наблюдатель над данным Оповещением. Когда происходит Оповещение..."}}}