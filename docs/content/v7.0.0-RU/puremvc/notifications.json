{"data":{"type":"contents","id":"puremvc/notifications","attributes":{"content":"В PureMVC реализован паттерн <em>Наблюдатель</em> (Observer) так, что <em>Базовые\nклассы</em> и взаимодействующие с ними классы могут общаться «слабо\nсцепленным» образом, и без привязок к платформе.\n\nJavaScript не предоставляет единообразную событийную модель, которая одинаково могла\nбыть использована как в браузере, так и на сервере.\n\nПоэтому используется внутренний механизм взаимодействия вместо привязки к\nреализации браузера или NodeJS.\n\nЭто не просто замена для <em>Событий</em> (Events). <em>Оповещения</em> (Notifications)\nработают в корне иначе, и органичное совмещение с <em>Событиями</em> (Events)\nпредоставляет возможность создавать компоненты <em>Представления</em> для\nмногократного использования, которые могут даже не знать о том, что они\nсвязаны с PureMVC приложением, если всё построено правильно.\n\n## События и Оповещения\n<em>События</em> излучаются из объектов DOM или любого использованного Frontend фреймворка,\nпредоставляющего UI компоненты, если конечное приложение работает в браузере;\nили же <em>Событие</em> может излучаються из лююбого доступного канала связи,\nшины данных или UNIX-сокета, если приложение работает на платформе NodeJS.\n\n<em>Событие</em> отлавливается <em>Конкретным Медиатором</em> в составе приложения,\nкоторый выступает посредником между внешним миром и \"черным ящиком\" приложения,\n<em>Медиатор</em> не обрабатывает <em>Событие</em> смостоятельно, он отсылает\n<em>Оповещение</em> об этом <em>Событии</em> подписанной на это <em>Оповещение</em> <em>Команде</em>.\n\n<em>Оповещения</em> рассылаются <em>Фасадом</em> и <em>Прокси</em>; слушаются и отсылаются\n<em>Медиаторами</em>; отправляются <em>Командам</em>, которые так же могут отправить\nследующее <em>Оповещение</em> заинтересованным <em>Наблюдателям</em>. Это механизм\nпубликации/подписки, посредством которого многие <em>Наблюдатели</em>\n(Observers) могут получать и обрабатывать одно и тоже <em>Оповещение</em>.\n\nОповещения могут иметь, если нужно, «тело», любой объект JavaScript.\n\nВ отличии от событий DOM или NodeJS's Events, создание специализированных классов\n<em>Оповещений</em>, требуется редко, потому может быть использовано прямо «из\nкоробки». Вы можете, конечно, создавать специализированные классы\n<em>Оповещений</em> для строгой типизации при взаимодействии с ними, но, нужно\nсоизмерять преимущества проверки времени компиляции (в частности для\n<em>Оповещений</em>) и накладных расходов по поддержки множественных классов\n<em>Оповещений</em>, так что это, скорее, вопрос стиля программирования.\n\n<em>Оповещения</em> также имеют опциональный «тип», который моет быть\nиспользован получателем для классификации.\n\nНапример, в приложении редактора документов, это может быть экземпляр\n<em>Прокси</em> для каждого документа, который открыт, и соответствующий\n<em>Медиатор</em> для компонента <em>Представления</em>, используемый для\nредактирования документа. <em>Прокси</em> и <em>Медиатор</em> могут совместно\nиспользовать уникальные ключ, который <em>Прокси</em> передаст как тип\n<em>Оповещения</em>.\n\nВсе экземпляры <em>Медиаторов</em> регистрируются для перехвата <em>Оповещений</em> от\n<em>Прокси</em>, используя тип <em>Оповещения</em> для принятия решения о его обработке.\n\n## Определение Оповещений и констант Событий\nМы видим, что конкретный <em>Фасад</em> это хорошее место для определения\nобщего в приложении, констант <em>Оповещений</em>. Поскольку это центральный\nмеханизм для взаимодействий с системой, все подписавшиеся на\nоповещения будут по умолчанию взаимодействовать с <em>Фасадом</em>.\n\nИногда для этих целей вместо определения констант в <em>Фасаде</em> приложения\nиспользуется отдельный класс “Констант Приложения”, в случае если эти\nконстанты должны быть доступны другому приложению.\n\nВ любом случае, централизованное определение констант для <em>Оповещений</em>\nгарантирует, что когда один из подписчиков должен сослаться к имени\n<em>Оповещения</em>, мы можем делать это безопасным образом, оставляя проверку\nмелких ошибок в синтаксисе компилятору.\n\nОднако не следует определять имена <em>Событий</em> в конкретном фасаде.\nОпределите их как статичные константы классов, которые их вызывают,\nили же в случае кастомных <em>Событий</em>, внутри классов этих <em>Событий</em>.\n\nРеализации частей Приложения, компонентов <em>Представления</em> и <em>Объектов\nДанных</em> могут оставаться многократно используемыми, если они\nвзаимодействуют со связанными <em>Медиаторами</em> и <em>Прокси</em> не через вызовы\nметодов а через отсылку <em>Оповещений</em>.\n\nЕсли компонент <em>Представления</em> либо <em>Объект Данных</em> вещает <em>Оповещение</em> в\nкотором заинтересован <em>Медиатор</em> или <em>Прокси</em>, то знание имени этого\nсобытия нужно только этой паре, всё остальное взаимодействие между\nслушателем и остальной частью PureMVC приложения может быть\nорганизовано посредством <em>Оповещений</em>.\n\nНесмотря на то, что отношения этих взаимодействующих пар\n(<em>Медиатор/Представление</em> и <em>Прокси/Объект Данных</em>) довольно близки, они\nостаются «слабо связанными» с остальными частями приложения; при\nжелании модифицировать пользовательский интерфейс либо модель\nданных могут быть легко подвергнуты рефакторингу.","description":"В PureMVC реализован паттерн Наблюдатель (Observer) так, что Базовые классы и взаимодействующие с ними классы могут общаться «слабо сцепленным» образом, и без привязок к платформе. \n\nJavaScript не предоставляет единообразную событийную модель, которая..."}}}