В PureMVC реализован паттерн <em>Наблюдатель</em> (Observer) так, что <em>Базовые
классы</em> и взаимодействующие с ними классы могут общаться «слабо
сцепленным» образом, и без привязок к платформе.

JavaScript не предоставляет единообразную событийную модель, которая одинаково могла
быть использована как в браузере, так и на сервере.

Поэтому используется внутренний механизм взаимодействия вместо привязки к
реализации браузера или NodeJS.

Это не просто замена для <em>Событий</em> (Events). <em>Оповещения</em> (Notifications)
работают в корне иначе, и органичное совмещение с <em>Событиями</em> (Events)
предоставляет возможность создавать компоненты <em>Представления</em> для
многократного использования, которые могут даже не знать о том, что они
связаны с PureMVC приложением, если всё построено правильно.

## События и Оповещения
<em>События</em> излучаются из объектов DOM или любого использованного Frontend фреймворка,
предоставляющего UI компоненты, если конечное приложение работает в браузере;
или же <em>Событие</em> может излучаються из лююбого доступного канала связи,
шины данных или UNIX-сокета, если приложение работает на платформе NodeJS.

<em>Событие</em> отлавливается <em>Конкретным Медиатором</em> в составе приложения,
который выступает посредником между внешним миром и "черным ящиком" приложения,
<em>Медиатор</em> не обрабатывает <em>Событие</em> смостоятельно, он отсылает
<em>Оповещение</em> об этом <em>Событии</em> подписанной на это <em>Оповещение</em> <em>Команде</em>.

<em>Оповещения</em> рассылаются <em>Фасадом</em> и <em>Прокси</em>; слушаются и отсылаются
<em>Медиаторами</em>; отправляются <em>Командам</em>, которые так же могут отправить
следующее <em>Оповещение</em> заинтересованным <em>Наблюдателям</em>. Это механизм
публикации/подписки, посредством которого многие <em>Наблюдатели</em>
(Observers) могут получать и обрабатывать одно и тоже <em>Оповещение</em>.

Оповещения могут иметь, если нужно, «тело», любой объект JavaScript.

В отличии от событий DOM или NodeJS's Events, создание специализированных классов
<em>Оповещений</em>, требуется редко, потому может быть использовано прямо «из
коробки». Вы можете, конечно, создавать специализированные классы
<em>Оповещений</em> для строгой типизации при взаимодействии с ними, но, нужно
соизмерять преимущества проверки времени компиляции (в частности для
<em>Оповещений</em>) и накладных расходов по поддержки множественных классов
<em>Оповещений</em>, так что это, скорее, вопрос стиля программирования.

<em>Оповещения</em> также имеют опциональный «тип», который моет быть
использован получателем для классификации.

Например, в приложении редактора документов, это может быть экземпляр
<em>Прокси</em> для каждого документа, который открыт, и соответствующий
<em>Медиатор</em> для компонента <em>Представления</em>, используемый для
редактирования документа. <em>Прокси</em> и <em>Медиатор</em> могут совместно
использовать уникальные ключ, который <em>Прокси</em> передаст как тип
<em>Оповещения</em>.

Все экземпляры <em>Медиаторов</em> регистрируются для перехвата <em>Оповещений</em> от
<em>Прокси</em>, используя тип <em>Оповещения</em> для принятия решения о его обработке.

## Определение Оповещений и констант Событий
Мы видим, что конкретный <em>Фасад</em> это хорошее место для определения
общего в приложении, констант <em>Оповещений</em>. Поскольку это центральный
механизм для взаимодействий с системой, все подписавшиеся на
оповещения будут по умолчанию взаимодействовать с <em>Фасадом</em>.

Иногда для этих целей вместо определения констант в <em>Фасаде</em> приложения
используется отдельный класс “Констант Приложения”, в случае если эти
константы должны быть доступны другому приложению.

В любом случае, централизованное определение констант для <em>Оповещений</em>
гарантирует, что когда один из подписчиков должен сослаться к имени
<em>Оповещения</em>, мы можем делать это безопасным образом, оставляя проверку
мелких ошибок в синтаксисе компилятору.

Однако не следует определять имена <em>Событий</em> в конкретном фасаде.
Определите их как статичные константы классов, которые их вызывают,
или же в случае кастомных <em>Событий</em>, внутри классов этих <em>Событий</em>.

Реализации частей Приложения, компонентов <em>Представления</em> и <em>Объектов
Данных</em> могут оставаться многократно используемыми, если они
взаимодействуют со связанными <em>Медиаторами</em> и <em>Прокси</em> не через вызовы
методов а через отсылку <em>Оповещений</em>.

Если компонент <em>Представления</em> либо <em>Объект Данных</em> вещает <em>Оповещение</em> в
котором заинтересован <em>Медиатор</em> или <em>Прокси</em>, то знание имени этого
события нужно только этой паре, всё остальное взаимодействие между
слушателем и остальной частью PureMVC приложения может быть
организовано посредством <em>Оповещений</em>.

Несмотря на то, что отношения этих взаимодействующих пар
(<em>Медиатор/Представление</em> и <em>Прокси/Объект Данных</em>) довольно близки, они
остаются «слабо связанными» с остальными частями приложения; при
желании модифицировать пользовательский интерфейс либо модель
данных могут быть легко подвергнуты рефакторингу.
