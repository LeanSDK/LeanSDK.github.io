{"data":{"type":"contents","id":"puremvc/clean-arch","attributes":{"content":"![Clean Architecture](/images/puremvc/gestalt/clean_architecture.jpg)\n\n<b>The Clean Architecture</b> описывает основные общие правила построения архитектуры приложения.\nКак сделать разработку тестируемой, удобной, понятной, а части системы взаимозаменяемыми.\n\nЗа последние несколько лет было предложено множество идей построения архитектуры.\n\nНапример:\n\n* [Hexagonal Architecture](http://alistair.cockburn.us/Hexagonal+architecture)\n(или Ports and Adapters) от Alistair Cockburn адаптированная Steve Freeman\nи Nat Pryce в их замечательной книге Growing Object Oriented Software\n* [Onion Architecture](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) от Jeffrey Palermo\n* [Screaming Architecture](https://8thlight.com/blog/uncle-bob/2011/09/30/Screaming-Architecture.html) из блога Robert Martin\n* [DCI](http://www.amazon.com/Lean-Architecture-Agile-Software-Development/dp/0470684208/) от James Coplien и Trygve Reenskaug.\n* [BCE](http://www.amazon.com/Object-Oriented-Software-Engineering-Approach/dp/0201544350) от Ivar Jacobson из его книги Object Oriented Software Engineering: A Use-Case Driven Approach\n\nНесмотря на то, что детали, предложенные в этих архитектурах сильно варьируются,\nвсе же, они очень похожи.\n\nВсе они разбивают проблему на схожие задачи. Они все добиваются этого разделения\nразложением кода на слои. Каждая имеет как минимум один слой для бизнес логики\nи другой - для интерфейсов.\n\nКаждая из этих архитектур создает систему, которая:\n\n1. Независимость от фреймворка. Архитектура не должна зависеть от какого-либо\nфреймворка или библиотеки, релиазующей какую-либо фичу. Такой подход позволяет\nиспользовать фреймворки как инструмент, нежели, подгонять ваш код под возможности фреймворка.\n2. Тестируемость. Бизнес-логика должна быть тестируема без UI, баз данных,\nвеб-сервисов и прочих сторонник элементов.\n3. Независимость от UI. Должна быть возможность легко изменить UI без затрагивания\nдругих частей системы. Веб интерфейс может быть заменен на консольный без изменения бизнес-логики.\n4. Независимость от Базы Данных. Должна быть возможность заменить Oracle или\nSQL Server на Mongo, BigTable, CouchDB или что-либо еще. Бизнес-логика не зависит от Базы Данных\n5. Независимость от внешних сервисов. Бизнес-логика просто не знает о существовании чего-либо во внешнем мире.\n\nНа диаграме представлена попытка изобразить общую концепцию представленных архитектур.\n\n## Правило зависимости (Dependency rule)\nКаждый слой на диаграме представляет разный слой кода. В целом, чем глубже\nвы двигаетесь внутрь диаграмы, тем на более высокий уровень абстракции попадаете.\nВнешние слои это реализация, внутренние - правила.\n\nОсновное правило, благодаря которому эта архитектура работает - Правило Зависимости.\nПравило звучит так: внешние слои знают о внутренних, но не наоборот. Н\nичего из внутреннего слоя не должно знать о существовании внешнего.\nВ частности, имена, объявленные во внешних слоях не должны даже упоминаться во\nвнутренних. Это касается функций, классов, переменных и любых других сущностей.\n\nТочно также, форматы данных, используемые во внешних слоях не должны быть\nиспользованы где-либо во внутренних слоях. Особенно, если эти данные\nсгенерированы фреймворком, используемым во внешних слоях. Мы не хотим никаким\nобразом влиять на внутренние слои из внешних.\n\n## Слои\n\n### Entities\nEntities содержат бизнес-логику используемую во всем приложении. Entities может\nбыть объектом с методами или может быть просто набором структур данных и функций.\nНе имеет значения, в каком виде представлена Entity, пока она может быть\nиспользована различными модулями проекта.\n\nЕсли вы разрабатываете одно небольшое приложение, то Entities являются\nбизнес-объектами этого приложения. Они содержат в себе основную высокоуровневую\nлогику. При каких-либо внешних изменениях, Entities - последнее, чего могут\nкоснуться эти изменения. Например, изменения навигации или настроек безопасности\nникак не должны повлиять на них. Ни одно изменение модуля приложения не должно\nзатронуть Entities.\n\n### Use Cases\nКод этого уровня содержит бизнес-правила конкретного приложения. Он содержит и\nреализовывает все возможные варианты использования системы. Use cases отвечают за\nпоток данных в/из Entities и используют Entities для выполнения необходимых действий.\n\nИзменения этого слоя не должны влиять на Entities. Также, изменения внених слоев,\nтаких как, Базы Данных, никак не должны влиять на Use Cases.\n\nОднако, код Use Cases будет изменен при изменении логики работы приложения. Если\nизменится какой-либо случай использования приложения, эти изменения будут\nреализованы в этом слое.\n\n### Interface Adapters\nЭтот слой представляет из себя набор адаптеров, которые конвертируют данные, из\nформата, который удобен для использования в Entities и Use Cases в формат, более\nудобный для внешних сервисов, таких как Базы Данных или Web-сервисы. Например,\nв этом слое должен содержаться полностью весь GUI MVC. Контроллеры, Презентеры,\nПредставления, все находится здесь. Модели, пожалуй, это всего лишь структуры\nданных, которые передаются из Контролеров в Use Cases и обратно из Use Cases в\nПредставления и Презентеры.\n\nПо аналогии, в этом слое данные должны быть конвертированы из формата, удобного\nдля использования в Entities и Use Cases в форматы, удобные для хранения, например\nв Базах Данных. Код изнутри этого слоя не должен что-либо знать о Базах Данных.\nЕсли используется SQL база данных, то все SQL запросы должны быть обработаны именно\nна уровне этого слоя.\n\nТакже, в этом слое должны находиться все другие возможные адаптеры, конвертирующие\nданные в формат удобный для использования в любых других внешних сервисах и\nнаоборот в форматы, используемые в Entities и Use Cases.\n\n### Frameworks and Drivers\nСамый дальний, внешний слой, состоящий из фреймворков и различных инструментов,\nтаких как Базы Данных, Web-сервисы. В общем, вы не должны писать здесь много кода,\nкроме связующего кода с внутренними слоями.\n\nНа этом слое реализованы все детали. Связь с Web-сервисами - это детали. Базы\nДанных - это детали. Мы оставили все это снаружи, чтобы не причинять вреда внутренним слоям.\n\n## И это все?\nНет. Эти слои - схематичны. Вероятно, вам понадобится что-либо, не вписывающие\nв эти четыре слоя. Нет такого правила, которое говорит, что вы должны использовать\nтолько эти четыре слоя. Однако, Правило Зависимостей (Dependency Rule) должно\nвыполняться всегда. Исходный код на любом слое должны ссылаться на внутренний.\nПри движение вовнутрь, уровень абстракции увеличивается. Внешний слой - низкоуровневая\nреализация деталей. Чем дальше вы продвигаетесь вовнутрь, тем более абстрактным\nстановится код и более высокоуровневую логику реализовывает. Самый внутренний слой\nотвечает за общую логику.\n\n## Пересечение границ слоев\nНа диаграмме справа-снизу представлено, как можно пересечь границы слоя. Там показано,\nкак Контроллеры и Представления общаются с Use Cases. Обратите внимание на поток\nуправления. Он начинается в Контроллере, проходит через Use Case и заканчивается\nв Презентере. Также обратите внимание на зависимости исходного кода. Каждый из них\nуказывает на Use Case.\n\nОбычно мы решает это противоречие при помощи Принципа Инверсии Зависимостей.\nВ таких языках, как Java, мы должны настроить интерфейсы и наследования, так,\nчтобы зависимости исходного кода были противоположны потоку управления в точках\nпересечения границ слоев.\n\nДопустим, Use Case должен обратиться к Презентеру. Это обращение не должно быть\nреализовано напрямую, чтобы не нарушать Правило Зависимостей (Dependency Rule):\nвнутренние слои не должны знать о реализации внешних. В таком случае, Use Case\nобратится к интерфейсу (изображено на диаграмме как Use Case Output Port) внутреннего\nслоя, а Презентер из внешнего слоя должен его реализовать.\n\nПодобная техника используется для пересечения остальных границ архитектуры.\nМы используем преумещества динамического полиморфизма, чтобы зависимости исходного\nкода были противоположны потоку управления. Таким образом мы не нарушаем правило\nзависимостей (Dependency Rule) вне зависимости от направления потока управления.\n\n## Какие данные должны пересекать границы\nОбычно, данные, пересекаемые границы, являются обычными структурами данных.\nВы можете пользоваться основными структурами или Data Transfer объектами. Или\nданные могут быть аргументами вызова функций. Или вообще можно представлять данные\nв виде hashmap или засунуть в объект. Важно, чтобы данные, пересекаемые границы,\nбыли простыми и изолированными. Мы же не хотим читерить и передавать Entities или\nстроки из Базы Данных. Также передаваемые данные не должны иметь какие-либо\nзависимости и нарушать правило зависимостей (Dependency Rule).\n\nНапример, множество фреймворков возвращает из Базы Данных данные в очень удобном\nформате. Назовем это RowStructure. Однако нельзя передавать RowStructure через\nграницы слоев. Это нарушает правило зависимостей (Dependency Rule) потому что\nтаким образом мы можем дать внутреннему слою информацию о реализации и структуре\nиспользуемых данных внешнего.\n\nВ общем, при передаче данных через границу, они должны быть представлены в формате,\nнаиболее удобном для использования во внутреннем слое.\n\n## В нашем случае\nСледовать этим простым правилам не так сложно, однако это сохранит вас от головной\nболи в будущем. Разделением кода на слои и следованием правилу зависимостей\n(Dependency Rule) можно создать систему, которая будет действительно тестируемой\nсо всеми вытекающими из этого плюсами. Если какая-то внешняя часть системы устареет\n(например, База Данных или фреймворк), заменить его будет достаточно легко без каких-либо проблем.\n\nНа первый взгляд, <em>Clean Architecture</em> – довольно простой набор рекомендаций\nк построению приложений. Но и я, и многие мои коллеги, осознали эту архитектуру не сразу.\n<b>Ниже мы попытаемся лучше понять Clean Architecture</b>.\n\n### Истоки\n\nВ 2011 году [Robert C. Martin](https://en.wikipedia.org/wiki/Robert_C._Martin),\nтакже известный как Uncle Bob, опубликовал статью\n[Screaming Architecture](https://8thlight.com/blog/uncle-bob/2011/09/30/Screaming-Architecture.html),\nв которой говорится, что архитектура должна «кричать» о самом приложении, а не о том,\nкакие фреймворки в нем используются. Позже вышла\n[статья](https://8thlight.com/blog/uncle-bob/2011/11/22/Clean-Architecture.html),\nв которой Uncle Bob даёт отпор высказывающимся против идей чистой архитектуры.\nА в 2012 году он опубликовал статью\n«[The Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)»,\nкоторая и является основным описанием этого подхода. Кроме этих статей также\nочень рекомендуется посмотреть видео выступления Дяди Боба.\n\nОригинальная схема из статьи, которая первой всплывает в голове разработчика,\nкогда речь заходит о Clean Architecture представлена под заголовком страницы.\n\n![Clean Architecture](/images/puremvc/gestalt/clean_architecture.jpg)\n\nВ Android-сообществе Clean стала быстро набирать популярность после статьи\n[Architecting Android...The clean way?](https://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/),\nнаписанной Fernando Cejas. В этой статье Fernando приводит такую схему слоёв:\n\n![android-the-clean-way](/images/puremvc/clean-arch/9ac65cf9ba3849db8532914040bd89b8.png)\n\nТо, что на этой схеме другие слои, а в domain слое лежат ещё какие-то Interactors\nи Boundaries, сбивает с толку. Оригинальная картинка тоже не всем понятна.\nВ статьях многое неоднозначно или слегка абстрактно. А видео не все смотрят\n(обычно из-за недостаточного знания английского). И вот, из-за недопонимания,\nлюди начинают что-то выдумывать, усложнять...\n\n## Давайте разбираться!\n\nClean Architecture объединила в себе идеи нескольких других архитектурных подходов,\nкоторые сходятся в том, что архитектура должна:\n\n* быть тестируемой;\n* не зависеть от UI;\n* не зависеть от БД, внешних фреймворков и библиотек.\n\nЭто достигается разделением на слои и следованием Dependency Rule (правилу зависимостей).\n\n## Dependency Rule\n\n<b>Dependency Rule говорит нам, что внутренние слои не должны зависеть от внешних</b>.\nТо есть наша бизнес-логика и логика приложения не должны зависеть от презентеров, UI,\nбаз данных и т.п. На оригинальной схеме это правило изображено стрелками, указывающими внутрь.\n\nВ статье сказано: имена сущностей (классов, функций, переменных, чего угодно),\nобъявленных во внешних слоях, не должны встречаться в коде внутренних слоев.\n\nЭто правило позволяет строить системы, которые будет проще поддерживать, потому\nчто изменения во внешних слоях не затронут внутренние слои.\n\n## Слои\n\nUncle Bob выделяет 4 слоя:\n\n* Entities. Бизнес-логика общая для многих приложений.\n* Use Cases (Interactors). Логика приложения.\n* Interface Adapters. Адаптеры между Use Cases и внешним миром. Сюда попадают\nPresenter'ы из MVP, а также Gateways (более популярное название репозитории).\n* Frameworks. Самый внешний слой, тут лежит все остальное: UI, база данных, http-клиент, и т.п.\n\nПодробнее, что из себя представляют эти слои, мы рассмотрим по ходу. А пока остановимся на передаче данных между ними.\n\n## Переходы\n\n<b>Переходы между слоями осуществляются через Boundaries</b>, то есть через два\nинтерфейса: один для запроса и один для ответа. Их можно увидеть справа на\nоригинальной схеме (Input/OutputPort). Они нужны, чтобы внутренний слой не\nзависел от внешнего (следуя Dependency Rule), но при этом мог передать ему данные.\n\n![Flow of control](/images/puremvc/clean-arch/afbef2e40b7b4f87939dcde0b1ab6bae.png)\n\nОба интерфейса относятся к внутреннему слою (обратите внимание на их цвет на картинке).\n\nСмотрите, Controller вызывает метод у InputPort, его реализует UseCase, а затем\nUseCase отдает ответ интерфейсу OutputPort, который реализует Presenter. То есть\nданные пересекли границу между слоями, но при этом все зависимости указывают\nвнутрь на слой UseCase'ов.\n\n<em>Чтобы зависимость была направлена в сторону обратную потоку данных</em>, применяется\n[принцип инверсии зависимостей](https://en.wikipedia.org/wiki/Dependency_inversion_principle)\n(буква D из аббревиатуры\n[SOLID](https://en.wikipedia.org/wiki/SOLID)). То есть, вместо\nтого чтобы UseCase напрямую зависел от Presenter'a (что нарушало бы Dependency Rule),\nон зависит от интерфейса в своём слое, а Presenter должен этот интерфейс реализовать.\n\nТочно та же схема работает и в других местах, например, при обращении UseCase к\nGateway/Repository. Чтобы не зависеть от репозитория, выделяется интерфейс и кладется\nв слой UseCases.\n\nЧто же касается данных, которые пересекают границы, то это должны быть <b>простые структуры</b>.\nОни могут передаваться как [DTO](https://en.wikipedia.org/wiki/Data_transfer_object)\nили быть завернуты в HashMap, или просто быть аргументами при вызове метода.\nНо они обязательно должны быть в форме более удобной для внутреннего слоя (лежать во внутреннем слое).\n\n## Особенности мобильных приложений\n\nНадо отметить, что <b>Clean Architecture была придумана с немного иным типом\nприложений на уме</b>. Большие серверные приложения для крупного бизнеса, а не\nмобильные клиент-серверные приложения средней сложности, которые не нуждаются\nв дальнейшем развитии (конечно, бывают разные приложения, но согласитесь, в\nбольшей массе они именно такие). Непонимание этого может привести к\n[overengineering'у](https://en.wikipedia.org/wiki/Overengineering).\n\nНа оригинальной схеме есть слово Controllers. Оно появилось на схеме из-за\nfrontend'a, в частности из Ruby On Rails. Там зачастую разделяют Controller,\nкоторый обрабатывает запрос и отдает результат, и Presenter, который выводит\nэтот результат на View. Многие не сразу догадываются,\nно <em>в android-приложениях Controllers не нужны</em>.\n\nЕщё в статье Uncle Bob говорит, что <em>слоёв</em> не обязательно <em>должно быть 4</em>.\nМожет быть любое количество, но Dependency Rule должен всегда применяться.\n\nГлядя на схему из статьи Fernando Cejas, можно подумать, что автор воспользовался\nкак раз этой возможностью и уменьшил количество слоев до трёх. Но это не так.\nЕсли разобраться, то в Domain Layer у него находятся как Interactors (это другое\nназвание UseCase'ов), так и Entities.\n\nВсе мы благодарны Fernando за его статьи, которые дали хороший толчок развитию\nClean в Android-сообществе, но его схема также породила и недопонимание.\n\n## Слои и линейность\n\nСравнивая оригинальную схему от Uncle Bob'a и cхему Fernando Cejas'a многие начинают\nпутаться. Линейная схема воспринимается проще, и люди начинают неверно понимать\nоригинальную. А не понимая оригинальную, начинают неверно толковать и линейную.\nКто-то думает, что расположение надписей в кругах имеет сакральное значение,\nили что надо использовать Controller, или пытаются соотнести названия слоёв на\nдвух схемах. <b>Смешно и грустно, но основные схемы стали основными источниками непонимания</b>!\n\nПостараемся это исправить. Для начала давайте <em>очистим основную схему</em>,\nубрав из нее лишнее для нас. И переименуем Gateways в Repositories,\nт.к. это более распространенное название этой сущности.\n\n![cicles schema](/images/puremvc/clean-arch/42cf44b37d614d2785444057af7273e8.png)\n\nСтало немного понятнее. Теперь мы сделаем вот что: <em>разрежем слои на части</em> и превратим\nэту схему в блочную, где цвет будет по-прежнему обозначать принадлежность к слою.\n\n![cicles-liner schema](/images/puremvc/clean-arch/fe8c82a32b1548b1a297187e24ae755a.png)\n\nКак уже сказано выше, цвета обозначают слои. А стрелка внизу обозначает Dependency Rule.\n\nНа получившейся схеме уже проще представить себе течение данных от UI к БД или серверу\nи обратно. Но давайте сделаем еще один шаг к линейности, расположив слои <em>по категориям</em>:\n\n![liner schema](/images/puremvc/clean-arch/9869dbe34b5649e28be40bff6bee3147.png)\n\nМы намеренно не называем это разделение слоями, в отличие от Fernando Cejas. Потому что\nмы и так делим слои. Мы называем это категориями или частями. Можно назвать как угодно,\nно повторно использовать слово «слои» не стоит.\n\nА теперь давайте сравним то, что получилось, со схемой Fernando.\n\n![two liner schemas](/images/puremvc/clean-arch/cbe3fdad2be24de3bd4dda6c66d56d76.png)\n\nНадеюсь теперь вcё начало вставать на свои места. Выше мы говорили, что\nу Fernando всё же 4 слоя. Теперь это тоже стало понятнее. В Domain части\nу нас находятся и UseCases и Entities.\n\nТакая схема воспринимается проще. Ведь обычно события и данные в наших приложениях\nходят от UI к backend'у или базе данных и обратно. Давайте изобразим этот процесс:\n\n![both schema](/images/puremvc/clean-arch/53104c89d9cf44a59c95e351b7485574.png)\n\nКрасными стрелками показано <em>течение данных</em>.\n\nСобытие пользователя идет в Presenter, тот передает в Use Case. Use Case делает\nзапрос в Repository. Repository получает данные где-то, создает Entity, передает\nего в UseCase. Так Use Case получает все нужные ему Entity. Затем, применив их и\nсвою логику, получает результат, который передает обратно в Presenter. А тот, в\nсвою очередь, отображает результат в UI.\n\nНа переходах между слоями (не категориями, а слоями, отмеченными разным цветом)\nиспользуются Boundaries, описанные ранее.\n\nТеперь, когда мы <b>поняли, как соотносятся две схемы</b>, давайте рассмотрим\nследующий момент.\n\n## Слои, а не сущности\n\nКак понятно из заголовка, кто-то думает, что на схемах изображены сущности (особенно\nэто затрагивает UseCases и Entities). Но это не так.\n\n<b>На схемах изображены слои, в них может находиться много сущностей</b>. В них будут\nнаходиться интерфейсы для переходов между слоями (Boundaries), различные DTO, основные\nклассы слоя (Interactors для слоя UseCases, например).\n\nНе будет лишним взглянуть на схему, собранную из частей, показанных в видео выступления\nUncle Bob'a. На ней изображены <em>классы и зависимости</em>:\n\n![classes and dependencies](/images/puremvc/clean-arch/bb3430769e6c4e8fbca757a8bc071f2e.png)\n\nВидите двойные линии? Это границы между слоями. Разделение между слоями Entities\nи UseCases не показаны, так как в видео основной упор делался на том, что вся\nлогика (приложения и бизнеса) отгорожена от внешнего мира.\n\nC Boundaries мы уже знакомы, интерфейс Gateway – это то же самое.\nRequest/ResponseModel – просто DTO для передачи данных между слоями. По правилу\nзависимости они должны лежать во внутреннем слое, что мы и видим на картинке.\n\nПро Controller мы тоже уже говорили, он нас не интересует. Его функцию у нас\nвыполняет Presenter.\n\nА ViewModel на картинке – это не ViewModel из [MVVM](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel)\nи не ViewModel из [Architecture Components](https://developer.android.com/topic/libraries/architecture/viewmodel.html).\nЭто просто DTO для передачи данных View, чтобы View была тупой и просто сетила\nсвои поля. Но это уже детали реализации и будет зависеть от выбора презентационного\nпаттерна и личных подходов.\n\nВ слое UseCases находятся не только Interactor'ы, но также и Boundaries для работы\nс презентером, интерфейс для работы с репозиторием, DTO для запроса и ответа.\n<em>Отсюда можно сделать вывод, что на оригинальной схеме отражены всё же слои</em>.\n\n## Entities\n\n<em>Entities по праву занимают первое место по непониманию.</em>\n\nМало того, что почти никто (включая меня до недавнего времени) не осознает,\nчто же это такое на самом деле, так их ещё и путают с DTO.\n\n```\nОднажды в чате возник спор, в котором оппонент доказывал, что Entity – это объекты,\nполученные после парсинга JSON в data-слое, а DTO – объекты, которыми оперируют Interactor'ы...\n```\n\nПостараемся хорошо разобраться, чтобы недопонимания больше не было ни у кого.\n\nЧто же такое Entities?\n\nЧаще всего они воспринимаются как POJO-классы, с которыми работают Interactor'ы.\nНо это не так. По крайней мере не совсем.\n\nВ статье Uncle Bob говорит, что <b>Entities инкапсулируют логику бизнеса</b>,\n<em>то есть всё то, что не зависит от конкретного приложения, а будет общим для многих</em>.\nНо если у вас отдельное приложение и оно не заточено под какой-то существующий бизнес,\nто Entities будут являться <em>бизнес-объектами приложения, содержащими самые\nобщие и высокоуровневые правила</em>.\n\nИменно фраза: «Entities это бизнес объекты», – запутывает больше всего.\nКроме того, на приведенной выше схеме из видео Interactor получает Entity из Gateway.\nЭто также подкрепляет ощущение, что это просто POJO объекты.\n\nНо в статье также говорится, что <em>Entity может быть объектом с методами или\nнабором структур и функций</em>. То есть упор делается на то, что важны методы, а не данные.\n\nЭто также подтверждается в [разъяснении](https://groups.google.com/forum/#!topic/clean-code-discussion/mvP_NR2MUPc)\nот Uncle Bob'а:\n\nUncle Bob говорит, что для него Entities содержат бизнес-правила, независимые от приложения.\nИ они <em>не просто объекты с данными. Entities могут содержать ссылки на объекты\nс данными, но основное их назначение в том, чтобы реализовать методы бизнес-логики,\nкоторые могут использоваться в различных приложениях</em>.\n\nА по-поводу того, что Gateways возвращают Entities на картинке, он поясняет следующее:\n\nРеализация Gаteway получает данные из БД, и использует их, чтобы создать структуры\nданных, которые будут переданы в Entities, которые Gateway вернет. Реализовано это может быть композицией\n\n```java\nclass MyEntity { private MyDataStructure data;}\n```\n\nили наследованием\n\n```java\nclass MyEntity extends MyDataStructure {...}\n```\n\nИ в конце ответа фраза:\n\n```\nAnd remember, we are all pirates by nature; and the rules I'm talking about here\nare really more like guidelines...\n(И запомните: мы все пираты по натуре, и правила, о которых я говорю тут,\nна самом деле, скорее рекомендации...)\n```\n\nДействительно, не надо слишком буквально всё воспринимать, надо искать компромиссы\nи не делать лишнего. Все-таки любая архитектура призвана помогать, а не мешать.\n\nИтак, <b>слой Entities содержит</b>:\n\n* Entities – функции или объекты с методами, которые реализуют логику бизнеса,\nобщую для многих приложений (а если бизнеса нет, то самую высокоуровневую\nлогику приложения);\n* DTO, необходимые для работы и перехода между слоями.\n\nКроме того, когда приложение отдельное, то надо стараться находить и выделять в\nEntities высокоуровневую логику из слоя UseCases, где зачастую она оседает по ошибке.\n\n## UseCase и/или Interactor\n\nМногие путаются в понятиях <em>UseCase</em> и <em>Interactor</em>. Мы ни раз слышали\nфразы типа: «Канонического определения Interactor нет». Или вопросы типа: «Мне\nделать это в Interactor'e или вынести в UseCase?».\n\nКосвенное определение Interactor'a встречается в статье, которая уже упомянута\nв самом начале. Оно звучит так:\n\n«...interactor object that implements the use case by invoking business objects.»\n\nТаким образом:\n\n<b>Interactor – объект, который реализует use case (сценарий использования),\nиспользуя бизнес-объекты (Entities)</b>.\n\nЧто же такое Use Case или сценарий использования?\nUncle Bob в видео выступлении говорит о книге «Object-Oriented Software Engineering:\nA Use Case Driven Approach», которую написал Ivar Jacobson в 1992 году, и о том,\nкак тот описывает Use Case.\n\n<em>Use case – это детализация, описание действия, которое может совершить\nпользователь системы</em>.\n\nВот пример, который приводится в видео:\n\n![usecase in video](/images/puremvc/clean-arch/87e46ddcbd124e14afb7e2a86bc4b0f2.png)\n\nЭто Use Case для создания заказа, причём выполняемый <em>клерком</em>.\n\nСперва перечислены входные данные, но не даётся никаких уточнений, что они из\nсебя представляют. Тут это не важно.\n\nПервый пункт – даже не часть Use Case'a, это его старт – клерк запускает команду\nдля создания заказа с нужными данными.\n\nДалее шаги:\n\n* Система валидирует данные. Не оговаривается как.\n* Система создает заказ и id заказа. Подразумевается использование БД, но это\nне важно пока, не уточняется. Как-то создает и всё.\n* Система доставляет id заказа клерку. Не уточняется как.\nЛегко представить, что id возвращается не клерку, а, например, выводится на\nстраницу сайта. То есть Use Case никак не зависит от деталей реализации.\n\nIvar Jacobson предложил реализовать этот Use Case в объекте, который назвал\nControlObject.\nНо Uncle Bob решил, что это плохая идея, так как путается с Controller из MVC\nи <b>стал называть такой объект Interactor</b>. И он говорит, что мог бы назвать его UseCase.\nЭто можно посмотреть примерно в этом [моменте видео](https://youtu.be/Nsjsiz2A9mg?t=15m2s).\n\nТам же он говорит, что Interactor реализует use case и имеет метод для запуска\nexecute() и получается, что это [паттерн Команда](https://en.wikipedia.org/wiki/Command_pattern). Интересно.\n\n<b>Когда кто-то говорит, что у Interactor'a нет четкого определения – он не прав</b>.\nОпределение есть и оно вполне четкое. Выше мы привели несколько источников.\n\nМногим нравится объединять Interactor'ы в один общий с набором методов,\nреализующих use case'ы.\nЕсли вам сильно не нравятся отдельные классы, можете так делать, это ваше\nрешение. Но <b>отдельные Interactor'ы</b> лучше, так как это даёт больше гибкости.\n\nА вот давать определение: «Интерактор – это набор UseCase'ов», – вот это уже\n<em>плохо</em>. А такое определение бытует. Оно ошибочно с точки зрения оригинального\nтолкования термина и вводит начинающих в непонимания, когда в коде\nполучается одновременно есть и UseCase классы и Interactor классы, хотя всё это\nодно и то же.\n\nМы призываем не вводить друг друга в заблуждения и использовать названия\nInteractor и UseCase, не меняя их изначальный смысл: Interactor/UseCase –\nобъект, реализующий use case (сценарий использования).\n\nЗа примером того, чем плохо, когда одно название толкуется по-разному, далеко\nходить не надо, такой пример рядом – паттерн Repository.\n\n## Доступ к данным\n\nДля доступа к данным удобно <b>использовать какой-либо паттерн, позволяющий скрыть\nпроцесс их получения</b>. Uncle Bob в своей схеме использует Gateway, но сейчас куда\nсильнее распространен Repository.\n\n## Repository\n\nА что из себя представляет паттерн Repository? Вот тут и возникает проблема, потому что\n<em>[оригинальное определение](https://martinfowler.com/eaaCatalog/repository.html)\nи то, как мы понимаем репозиторий сейчас (и как его описывает Fernando Cejas в своей [статье](https://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/)),\nфундаментально различаются</em>.\n\nВ оригинале Repository инкапсулирует набор сохраненных объектов в более\nобъектно-ориентированном виде. В нем собран код, создающий запросы, который\nпомогает минимизировать дублирование запросов.\n\nНо в Android-сообществе куда более распространено определение Repository\nкак объекта, <em>предоставляющего доступ к данным с возможностью выбора источника\nданных в зависимости от условий</em>.\n\nПодробнее об этом можно прочесть в\n[статье Hannes Dorfmann'а](http://hannesdorfmann.com/android/evolution-of-the-repository-pattern).\n\n## Gateway\n\nСначала мы тоже начали использовать Repository, но воспринимая слово «репозиторий»\nв значении хранилища, нам <em>не нравилось наличие там методов для работы с сервером\nтипа login()</em> (да, работа с сервером тоже идет через Repository, ведь в конце\nконцов для приложения сервер – это та же база данных, только расположенная удаленно).\n\nМы начали искать альтернативное название и узнали, что многие используют Gateway –\nслово более подходящее. А сам паттерн [Gateway](https://martinfowler.com/eaaCatalog/gateway.html)\nпо сути представляет собой разновидность фасада, где мы прячем сложное API за\nпростыми методами. Он в оригинале тоже не предусматривает выбор источников данных,\nно все же ближе к тому, как используем мы.\n\nА в обсуждениях все равно приходится использовать слово «репозиторий», всем так проще.\n\n## Доступ к Repository/Gateway только через Interactor?\n\nМногие настаивают, что это единственный правильный способ. И они правы!\n<b>В идеале использовать Repository нужно только через Interactor</b>.\n\nНо мы не видем ничего страшного, чтобы в простых случаях, когда не нужно никакой\nлогики обработки данных, вызывать Repository из Presenter'a, минуя Interactor.\n\nRepository и презентер находятся на одном слое, Dependency Rule не запрещает нам\nиспользовать Repository напрямую. Единственное но – возможное добавления логики\nв Interactor в будущем. Но добавить Interactor, когда понадобится, не сложно, а\nиметь множество proxy-interactor'ов, просто прокидывающих вызов в репозиторий,\nне всегда хочется.\n\nВ идеале надо делать запросы через Interactor, но в небольших проектах, где вероятность\nдобавления логики в Interactor ничтожно мала, <em>можно этим правилом поступиться</em>.\nВ качестве компромисса с собой.\n\n## Обязательность маппинга между слоями\n\nНекоторые утверждают, что маппить данные обязательно между всеми слоями. Но это\nможет породить большое количество дублирующихся представлений одних и тех же данных.\n\nА можно использовать DTO из слоя Entities везде во внешних слоях. Конечно, если\nте могут его использовать. Нарушения Dependency Rule тут нет.\n\nКакое решение выбрать – сильно зависит от предпочтений и от проекта. В каждом\nварианте есть свои плюсы и минусы.\n\n<b>Маппинг DTO на каждом слое</b>:\n\n* Изменение данных в одном слое не затрагивает другой слой;\n* Аннотации, нужные для какой-то библиотеки не попадут в другие слои;\n* Может быть много дублирования;\n* При изменении данных все равно приходится менять маппер.\n\n<b>Использование DTO из слоя Enitities</b>:\n\n* Нет дублирования кода;\n* Меньше работы;\n* Присутствие аннотаций, нужных для внешних библиотек на внутреннем слое;\n* При изменении этого DTO, возможно придется менять код в других слоях.\n\nХорошее рассуждение есть вот по этой [ссылке](https://softwareengineering.stackexchange.com/a/303480).\n\nС выводами автора ответа мы полностью согласены:\n\n<em>Если у вас сложное приложение с логикой бизнеса и логикой приложения, и/или\nразные люди работают над разными слоями, то лучше разделять данные между слоями\n(и маппить их). Также это стоит делать, если серверное API корявое. Но если вы\nработаете над проектом один, и это простое приложение, то <b>не усложняйте</b>\nлишним маппингом</em>.\n\n## Mаппинг в Interactor'e\n\nДа, такое существует. Приведем фразу из оригинальной\n[cтатьи](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html):\n<em>So when we pass data across a boundary, it is always in the form that is most\nconvenient for the inner circle.\n(Когда мы передаем данные между слоями, они всегда в форме более удобной для\nвнутреннего слоя)</em>\n\nПоэтому <b>в Interactor данные должны попадать уже в нужном ему виде</b>.\nМаппинг происходит в слое Interface Adapters, то есть в Presenter и Repository.\n\n## А где раскладывать объекты?\n\nС сервера нам приходят данные в разном виде. И иногда API навязывает нам странные\nвещи. Например, в ответ на login() может прийти объект Profile и объект OrderState.\nИ, конечно же, мы хотим сохранить эти объекты в разных Repository.\n\nТак где же нам разобрать LoginResponse и разложить Profile и OrderState по нужным\nрепозиториям, в Interactor'e или в Repository?\n\nМногие делают это в Interactor'e. Так проще, т.к. не надо иметь зависимости между\nрепозиториями и разрывать иногда возникающую кроссылочность.\n\nНо мы делаем это <b>в Repository. По двум причинам</b>:\n\n* Если мы делаем это в Interactor'e, значит мы должны передать ему LoginResponse\nв каком-то виде. Но тогда, чтобы не нарушать Dependency Rule, LoginResponse\nдолжен находиться в слое Interactor'a (UseCases) или Entities. А ему там не место,\nведь он им кроме как для раскладывания ни для чего больше не нужен.\n* Раскладывание данных – не дело для use case. Мы же не станем писать пункт в\nописании действия доступного пользователю: «Получить данные, разложить данные».\nСкорее мы напишем просто: «Получить нужные данные»,– и всё.\n\nЕсли вам удобно делать это в Interactor, то делайте, но считайте это компромиссом.\n\n## Можно ли объединить Interactor и Repository?\n\nНекоторым нравится объединять Interactor и Repository. В основном это вызвано\nжеланием избежать решения проблемы, описанной в пункте «Доступ к Repository/Gateway\nтолько через Interactor?».\n\nНо <b>в оригинале Clean Architecture эти сущности не смешиваются</b>.\nИ на это пара веских причин:\n\n* Они на разных слоях.\n* Они выполняют различные функции.\n\nА вообще, как показывает практика, в этом ничего страшного нет. Пробуйте и смотрите,\nособенно если у вас небольшой проект. Хотя мы рекомендуем разделять эти сущности.\n\n## Что лучше Clean Architecture или MVP?\n\nСмешно, да? А некоторые спрашивают такое в чатах.\nБыстро поясним:\n\n* Архитектура затрагивает всё ваше приложение. И Clean – не исключение.\n* А презентационные паттерны, например MVP, затрагивают лишь часть, отвечающую\nза отображение и взаимодействие с UI. Чтобы лучше понять эти паттерны, мы рекомендуем почитать\n[статью](https://habrahabr.ru/company/mobileup/blog/313538/) нашего коллеги\n[@dmdev](https://habrahabr.ru/users/dmdev/).\n\n## Clean Architecture в первых проектах\n\nВ последнее время архитектура приложений на слуху. Даже Google решили выпустить\nсвои Architecture Components.\n\nНо этот хайп заставляет молодых разработчиков пытаться затянуть какую-нибудь\nархитектуру в первые же свои приложения. А это <b>чаще всего плохая идея</b>.\nТак как на раннем этапе куда полезнее вникнуть в другие вещи.\n\nКонечно, если вам все понятно и есть на это время – то супер. Но если сложно,\nто не надо себя мучить, делайте проще, набирайтесь опыта.\n\nОднако до сих пор в этой главе документации описывались только концепции и идеомы\nиз Clean Architecture на уровне понимания самой идеи разделения на слои.\n\nКонечно же, если у программиста достаточно опыта - он может все сделать с нуля\nсамостоятельно своими руками. Однако мы изначально поставили перед собой задачу -\nсоздать удобный, эффективный, модульный фреймворк LeanES, чтобы воплотить в нем\nвесь наш накопленный опыт. Чтобы он помогал даже не опытным программистам создавать\nвысококачественные приложения, предоставляя свод правил, каркас приложения.\nА рамки дозволенного будут сдерживать программиста от заведомо неверных реализаций.\n\nРанее были описаны идеомы из спецификации PureMVC, которые были имплементированы\nв виде базовых классов в фреймворке в первую очередь. В последствие стало ясно,\nчто PureMVC является лишь ограниченной реализацией Clean Architecture с тремя\nвыделенными слоями:\n\n* слой Entities отсутствует, т.е. может быть реализован на усмотрение разработчика\n* слой UseCases представлен <em>Командами</em>\n* слой Interface Adapters представлен <em>Медиаторами</em> и <em>Прокси</em>\n* слой Frameworks представлен в виде viewComponent внутри <em>Медиатора</em> и dataObject внутри <em>Прокси</em>\n\nНо <em>Команды</em> в PureMVC все же не на 100% соответствуют концепции UseCases,\nт.к. инстанцируются и выполняются непосредственно в Controller классе (это не тот\nконтроллер который описывается на уровне Interface Adapters). Но главное, эти <em>Команды</em>\nпредназначены только для запуска через отправку <em>Оповещения</em>, но не для\nинъекции в качестве зависимости в другие сущности.\n\nКонечно произвести инъекцию и напрямую вызвать метот execute() нам явно не запрещено,\nно все же цель <em>Команды</em> в PureMVC быть вызванной для обработки <em>Оповещения</em>\nс одним единственным <em>Интерфейсом</em>.\n\nПоэтому в <em>Фасад</em> были интегрированы дополнительные сущности и методы для работы с ними\nв рамках концепции \"Clean Architecture\" by Robert C. Martin (Uncle Bob).\nЭти сущности <em>Кейс</em> (Case), <em>Сьюит</em> (Suite) и <em>Адаптер</em> (Adapter)\nтолько расширяют уровни абстракций в составе PureMVC с сохранением обратной совместимости\nс эталонной спецификацией.\n\n<em>Кейс</em> (Case) в явном виде говорит о том, что предназначен быть <em>Базовым\nклассом</em> для определения <em>конкретных UseCases</em> в приложении.\nИ конечно разработчик может объявить любые <em>Интерфейсы</em>, которые будут\nреализовывать его <em>конкретные UseCases</em>. Эти <em>Интерфейсы</em> он будет\nиспользовать при инъекции зависимостей в тех классах, в которые он будет инъектировать\nреализованные в приложении <em>Кейсы</em>.\n\nК сожалению <em>Сущность</em> (Entity) - слишком абстрактное название для класса\nи несмотря на вышеизложенные объяснения в Clean Architecture, закладывать <em>Базовый\nкласс</em> с таким именем в фреймворке слишком рискованно (эту документацию\nразработчики могут и не прочить вовсе, но использовать Entity сущность в своем\nприложении не по назначению). Поэтому <em>Сущность</em> в фреймворке реализуется\nчерез <em>Базовый класс</em> <em>Сьюит</em> (Suite) и полностью соответствует предназначению Entity.\n\nВсе необходимое для работы с данными в общем случае всегда может быть реализовано\nвнутри <em>Прокси</em>, однако ввиду распростаненности использования паттерна Repository\nмы решили реализовать дополнительный <em>Базовый класс</em> <em>Адаптер</em> (Adapter).\nРазработчик может определить <em>конкретный RepositoryProxy</em> в своем приложении,\nа так же набор <em>Адаптеров</em> для работы с разными данными и/или API серверами.\n\nВ итоге, фреймворк LeanES предоставляет разработчику все необходимые <em>Базовые классы</em>\nкак в рамках спецификации PureMVC, так и в рамках концепции Clean Architecture.\nИными словами: <em>Вам достаточно создавать наследники Базовых классов в нужным файлах и\nкаталогах, в соответствие с целями их проектов - Все остальное фреймворк сделает за Вас</em>.\n\n## Переосмысление Entities\n\nВозможно стоило бы это описать выше, но так вышло исторически, что более глубокое\nпонимание приходит значительно позже.\n\nИзначально было не понятно как \"так\" устроены Entities, чтобы <b>Dependency Rule</b>\nбыли направлены вовнутырь <em>Сущности</em> из <em>Кейса</em>. При том, что в описании\n<em>Сущности</em> передаются в <em>Кейс</em> якобы как \"данные\" - что только увеличивает\nзамешательство.\n\nОднако на верный ход мыслей натолкнула все та же схема:\n\n![Flow of control](/images/puremvc/clean-arch/afbef2e40b7b4f87939dcde0b1ab6bae.png)\n\nСледовательно, чтобы не нарушить <em>Поток управления</em>, <em>Кейсы</em> должны\nреализовывать такие интерфейсы, через которые они будут инъектироваться внутрь\n<em>Сущности</em>.\n\nЕще раз вспоминаем самый главный смысл <em>Сущности</em> - <b>функции или объекты\nс методами, которые реализуют логику бизнеса</b>, иыми словами <em>Сущность</em> (Entity) -\nэто буквально \"функция\" являющаяся композицией <em>Кейсов</em>, инъектированных в нее,\nвызовов методов этих <em>Кейсов</em>, удовлетворяющих указанным <em>Интерфейсам</em>, а так же\nоъединенным любыми другими логическими и промежуточными операциями.\n\nПо существу <em>Сущность</em> (Entity) - это такая <em>Макро команда</em> или\n<em>Объект с набором методов</em>, реализация которой фактически является Скриптом кода,\nсодержащим различного рода операции и оперирующего инъектированными <em>Кейсами</em>\nи их методами.\n\nНапример:\n\n```js\nimport type { FirstCaseInterface } from '../interfaces/FirstCaseInterface';\nimport type { SecondCaseInterface } from '../interfaces/SecondCaseInterface';\nimport type { ThirdCaseInterface } from '../interfaces/ThirdCaseInterface';\n\nexport default (Module) => {\n  const {\n    FIRST_CASE, SECOND_CASE, THIRD_CASE,\n    Suite,\n    initialize, partOf, meta, method, property, nameBy, inject,\n  } = Module.NS;\n\n  @initialize\n  @partOf(Module)\n  class CheckoutOrderSuite extends Suite {\n    @nameBy static  __filename = __filename;\n    @meta static object = {};\n\n    @inject(`Factory<${FIRST_CASE}>`)\n    @property _firstCaseFactory: () => FirstCaseInterface;\n    @property get _firstCase(): FirstCaseInterface {\n      return this._firstCaseFactory()\n    }\n\n    @inject(`Factory<${SECOND_CASE}>`)\n    @property _secondCaseFactory: () => SecondCaseInterface;\n    @property get _secondCase(): SecondCaseInterface {\n      return this._secondCaseFactory()\n    }\n\n    @inject(`Factory<${THIRD_CASE}>`)\n    @property _thirdCaseFactory: () => ThirdCaseInterface;\n    @property get _thirdCase(): ThirdCaseInterface {\n      return this._thirdCaseFactory()\n    }\n\n    @method async perform(): void {\n      if (await this._firstCase.isFirstUserPurchase()) {\n        await this._secondCase.makeGift()\n      }\n      await this._thirdCase.calculateDiscount()\n    }\n  }\n}\n```","description":"The Clean Architecture описывает основные общие правила построения архитектуры приложения. Как сделать разработку тестируемой, удобной, понятной, а части системы взаимозаменяемыми. \n\nЗа последние несколько лет было предложено множество идей построения..."}}}