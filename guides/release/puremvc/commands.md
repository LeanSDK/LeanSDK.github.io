Определенный <em>Фасад</em> инициализирует <em>Контроллер</em>, передавая <em>Командам</em>
связанные с ними <em>Оповещения</em> необходимые для старта приложения.

Для каждой связки (Mapping), <em>Контроллер</em> регистрируется как <em>Наблюдатель</em>
над данным <em>Оповещением</em>. Когда происходит <em>Оповещение</em>, <em>Контроллер</em>
создает экземпляр соответствующей <em>Команды</em>. И, наконец, <em>Контроллер</em>
вызывает у созданной команды метод execute(), передавая в него данное
<em>Оповещение</em>.

Команды единоразовы; они создаются по требованию (приходит
<em>Оповещение</em>), и после их исполнения (вызов метода execute) они должны
удаляться. В связи с чем, важно не создавать экземпляры и не хранить ссылки
на <em>Команды</em> в объектах, которые будет использоваться в течении долго срока
в вашем приложении.

## Использование Макро- и Простых команд
Команды, как и все классы фреймворка PureMVC, реализовывают
интерфейс, а именно интерфейс ICommand. PureMVC содержит две
реализацию ICommand интерфейса для Макро-команды которую вы можете с легкостью расширять.

Класс Command (Макрокоманда) позволяет выполнять несколько
подкоманд последовательно, каждой из которых будет после создания
передан экземпляр текущего Оповещения.

Класс Command из конструктора вызывает свой метод
initializeSubCommands. Вы должны переопределить его в своем классе
макрокоманды, для вызова метода addSubCommand для каждой команды,
которую вы ходите добавить в макрокоманду. Вы можете добавлять любые
<em>Команды</em> или <em>Макрокоманды</em>.

Для того, чтобы кастомная команда была "Простой", достаточно переопределить метод
execute, который принимает в качестве параметра экземпляр INotification.
Вписываете вашу функциональность в метод execute и все готово к работе.

## Слабое связывание Команд с Медиаторами и Прокси
<em>Команды</em> выполняются <em>Контроллером</em> в результате отправки <em>Оповещения</em>.
<em>Команды</em> не должны быть созданы и выполнены никем кроме <em>Контроллера</em>.

Чтобы общаться и взаимодействовать с другими частями системы, <em>Команды</em>
могут:

* Регистрировать, удалять или проверять существуют ли <em>Медиаторы</em>,
<em>Прокси</em> и <em>Команды</em>.
* Посылать <em>Оповещения</em>, для получения ответной реакции от других
команд или <em>Медиаторов</em>.
* Получать экземпляры <em>Прокси</em> и <em>Медиаторов</em> и управлять ими
напрямую.

<em>Команды</em> позволяют нам легко переключать элементы <em>Представления</em>
между различными состояниями (через <em>Медиаторы</em>), или передавать
данные к различным частям этих элементов.

Они могут быть использованы для осуществления транзакционного
взаимодействия с <em>Моделью</em>, которую охватывают несколько <em>Прокси</em>,
требовать отправки <em>Оповещения</em> по окончанию транзакции, или
обрабатывать непредвиденные ситуации (exceptions) и принимать
соответствующие действия.

## Взаимодействие сложных действий и бизнес-логики
местах вашего приложения, где вы могли бы разместить код (<em>Команд</em>,
<em>Медиаторов</em> и <em>Прокси</em>) неизбежно и периодически будет возникать вопрос:

Какой код и где писать? Что конкретно должна делать <em>Команда</em>?

Первое разделение логики в вашем приложении коснется бизнес-логики и
логики предметной области.

В командах находится бизнес-логика нашего приложения; ожидается, что
техническая реализация сценариев использования нашего приложения
будет выполняться на уровне модели предметной области (Domain Model).
Это подразумевает координацию <em>Модели</em> и состояниями <em>Представления</em>.

Модель поддерживает свою целостность, используя <em>Прокси</em>, которые
размещены в логике предметной области (Domain Logic), открывая API для
работы с объектами данных. Они инкапсулируют весь доступ к моделям
данных, находящимся на клиенте или на сервере, для того чтобы остальная
часть приложения которая работает с данными, могли иметь к ним
синхронный или асинхронный доступ.

<em>Команды</em> могут быть использованы для управления рядом действий в
системе, которые должны происходить в определенном порядке, с
возможностью того что результат предыдущего действия может быть
использован для последующего.

<em>Медиаторы</em> и <em>Прокси</em> должны предоставлять крупномодульные интерфейсы
<em>Командам</em> (и наоборот), которые скрывают реализацию объектов данных и
компонентов представления, которыми они управляют.

Заметьте, что когда мы говорим про компонент представления, мы имеем в
виду кнопку или виджет, с которым непосредственно взаимодействует
пользователь. Когда мы говорим об объекте данных, то подразумеваем
произвольные структуры данных, а также удаленные сервисы, которые
могут быть использованы для хранения или получения данных.

<em>Команды</em> взаимодействуют с <em>Медиаторами</em> и <em>Прокси</em>, но должны быть
изолированы от граничных реализаций. Вот пример того как <em>Команда</em>
используется для подготовки приложения к работе:

```js
import type { NotificationInterface } from '../interfaces/NotificationInterface';

export default (Module) => {
  const {
    STARTUP, STARTUP_COMPLETE,
    Command,
    PrepareControllerCommand,
    PrepareModelCommand,
    PrepareViewCommand,
    initialize, partOf, meta, method, nameBy
  } = Module.NS;

  @initialize
  @partOf(Module)
  class StartupCommand extends Command {
    @nameBy static  __filename = __filename;
    @meta static object = {};

    @method initializeSubCommands(): void {
      this.addSubCommand(PrepareControllerCommand);
      this.addSubCommand(PrepareModelCommand);
      this.addSubCommand(PrepareViewCommand);
    }

    @method execute<T = ?any>(note: NotificationInterface<T>): void {
      super.execute(note);
      this.facade.removeCommand(STARTUP);
      this.send(STARTUP_COMPLETE);
    }
  }
}
```

Это <em>макрокоманда</em>, которая содержит три подкоманды, которые при вызове
макрокоманды исполняются в порядке очереди (FIFO).

Это создает 'очередь' верхнего уровня из действий, которые должны быть
выполнены на старте приложения. Но что конкретно должны мы сделать, и
в каком порядке?

Прежде чем пользователь увидит или сможет взаимодействовать с
приложением и его данными, <em>Модель</em> должна быть надлежащим образом
подготовлена. Как только это сделано, <em>Представление</em> может быть
подготовлено для отображения данных <em>Модели</em> и позволить пользователю
взаимодействовать с ними.

Следовательно, процесс старта обычно состоит из трех обширных групп
операций — подготовка <em>Контроллер</em>, <em>Модели</em>, и последующая подготовка
<em>Представления</em>.

```js
import type { NotificationInterface } from '../interfaces/NotificationInterface';

export default (Module) => {
  const {
    MSG_FROM_CONSOLE, CLEAR_CONSOLE,
    Command,
    initialize, partOf, meta, method, nameBy
  } = Module.NS;

  @initialize
  @partOf(Module)
  class PrepareControllerCommand extends Command {
    @nameBy static  __filename = __filename;
    @meta static object = {};

    @method execute<T = ?any>(note: NotificationInterface<T>): void {
      this.facade.addCommand(MSG_FROM_CONSOLE, 'SimpleCommand');
      this.facade.addCommand(CLEAR_CONSOLE, 'SimpleScript');
    }
  }
}
```

Подготовка <em>Контроллера</em>, обычно, является простым созданием и регистрацией
всех <em>Команд</em>, в которых приложение будет нуждаться при запуске.

Пример команды PrepareControllerCommand, это Простая команда, которая
подготавливает <em>Контроллер</em> к дальнейшей работе. Это первая из подкоманд
макрокоманды, и поэтому она будет выполнена первой.

Через <em>конкретный Фасад</em>, она регистрирует те <em>Команды</em>, которые
система будет использовать при запуске.

```js
import type { NotificationInterface } from '../interfaces/NotificationInterface';
import type { ApplicationInterface } from '../interfaces/ApplicationInterface';

export default (Module) => {
  const {
    APPLICATION_PROXY, SIMPLE_PROXY,
    Command,
    initialize, partOf, meta, method, nameBy
  } = Module.NS;

  @initialize
  @partOf(Module)
  class PrepareModelCommand extends Command {
    @nameBy static  __filename = __filename;
    @meta static object = {};

    @method execute<T = ?any>(note: NotificationInterface<T>): void {
      const app: ApplicationInterface = note.getBody();
      this.facade.addProxy(APPLICATION_PROXY, 'ApplicationProxy', app.initialState);
      this.facade.addAdapter('SimpleAdapter');
      this.facade.addProxy(SIMPLE_PROXY, 'SimpleProxy');
    }
  }
}
```

Подготовка <em>Модели</em>, обычно, является простым созданием и регистрацией
всех <em>Прокси</em>, в которых приложение будет нуждаться при запуске.

Пример команды PrepareModelCommand, это Простая команда, которая
подготавливает <em>Модель</em> к дальнейшей работе.

Через <em>конкретный Фасад</em>, она создает и регистрирует те <em>Прокси</em>, которые
система будет использовать при запуске. Заметьте, что <em>Команда</em> не делает
никаких манипуляций или инициализаций с данными <em>Модели</em>. <em>Прокси</em>
отвечает за любое получение данных, создание или инициализацию
необходимых <em>Объектов Данных</em> для использования в системе.

```js
import type { NotificationInterface } from '../interfaces/NotificationInterface';
import type { ApplicationInterface } from '../interfaces/ApplicationInterface';

export default (Module) => {
  const {
    APPLICATION_MEDIATOR, SHELL, LOGGER_MODULE, SIGNALS_GENERATOR,
    Command,
    initialize, partOf, meta, method, nameBy
  } = Module.NS;

  @initialize
  @partOf(Module)
  class PrepareViewCommand extends Command {
    @nameBy static  __filename = __filename;
    @meta static object = {};

    @method execute<T = ?any>(note: NotificationInterface<T>): void {
      console.log('PrepareViewCommand execute()');
      const app: ApplicationInterface = note.getBody();

      this.facade.addMediator(LOGGER_MODULE, 'LoggerModuleMediator');
      this.facade.addMediator(SHELL, 'ShellJunctionMediator');
      this.facade.addMediator(APPLICATION_MEDIATOR, 'ApplicationMediator', app);

      this.facade.activateMediator(APPLICATION_MEDIATOR);
      this.facade.activateMediator(LOGGER_MODULE);
      this.facade.activateMediator(SHELL);

      if (!app.isLightweight) {
        this.facade.addMediator(SIGNALS_GENERATOR, 'SignalsMediator');
        this.facade.activateMediator(SIGNALS_GENERATOR);
        this.facade.addMediator('SimpleMediator');
        this.facade.activateMediator('SimpleMediator');
      }
    }
  }
}
```

Это простая <em>команда</em> которая подготавливает <em>Представление</em> для работы.
Это последняя из подкоманд <em>макрокоманды</em>, следовательно, будет
выполнена последней.

Отметьте, что создается и регистрируется только <em>Медиатор</em>
ApplicationMediator, который обслуживает компонент представления
приложения.

В дальнейшем, тело Оповещения передается в конструктор медиатора. Это
ссылка на приложение, переданная самим приложением вместе с
<em>Оповещением</em>, когда первоначальное <em>Оповещение</em> STARTUP было послано.
(Согласно предыдущему примеру приложения MyApp.)

Приложение это в некоторой степени специальный компонент
<em>Представления</em>, в котором реализуются и находятся в качестве потомков
все другие компоненты <em>Представления</em>, которые инициализируются при
запуске приложения.

Для взаимосвязи с остальной частью системы, компоненты <em>Представления</em>
должны обладать <em>Медиаторами</em>. И создание этих <em>Медиаторов</em> требует
ссылку на компоненты <em>Представления</em>, с которыми они будут работать, а
это на данном этапе известно только приложению.

<em>Медиатор</em> приложения - это единственный класс, которому допускается
знать все про реализацию <em>Представления</em> приложения, так что создание
оставшихся <em>Медиаторов</em> будет размещена внутри его конструктора.

Используя эти три команды, мы обеспечили последовательную
инициализацию <em>Модели</em> и <em>Представления</em>. При этом <em>Команды</em> не должны
знать много о <em>Модели</em> или о <em>Представлении</em>.

При изменении <em>Модели</em> или реализации <em>Представления</em>, <em>Прокси</em> и
<em>Медиаторы</em> должны быть изменены соответствующим образом.
Бизнес-логика внутри Команд не должна зависеть от изменений,
происходящих в областях применения.

<em>Модель</em> должна формировать «логику предметной области», поддерживая
целостность данных внутри <em>Прокси</em>. <em>Команды</em> выполняют
«транзакционную» или «бизнес» логику в <em>Модели</em>, формируя координацию
транзакций <em>мульти-Прокси</em> или обрабатывая и сообщая об исключительных
ситуациях.
