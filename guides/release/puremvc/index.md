![Schema](/images/puremvc/gestalt/schema.jpg)

Фреймворк PureMVC преследует очень узкую цель. Она в том, чтобы помочь
вам разделить интересы кода вашего приложения на три отдельных уровня:
<em>Модель</em> (Model), <em>Представление</em> (View) и <em>Контроллер</em> (Controller).

Для создания масштабируемых и легко поддерживаемых приложений
высоким приоритетом являются разделение интересов, а так же
герметичность и направление связей между уровнями MVC

В данной реализации классического мета-паттерна MVC эти три уровня
приложения управляются тремя синглтонами (классами, для которых
возможно существование одного и только одного экземпляра), называемыми
просто: <em>Модель</em> (Model), <em>Представление</em> (View) и <em>Контроллер</em> (Controller). Все
вместе они называются <em>Базовыми классами</em> (Core actors).

Четвертый синглтон, <em>Фасад</em> (Facade), упрощает разработку, предоставляя
единый интерфейс для сообщения с <em>Базовыми классами</em>.

## Оказали влияние
![Design patterns book](/images/puremvc/gestalt/design_patterns_book.jpg)

PureMVC — это фреймворк, основанный на шаблонах
проектирования. Он появился из насущной необходимости
проектирования высокопроизводительных RIA-клиентов.
Сейчас он уже портирован на другие языки и платформы,
включая серверные среды.

Хотя интерпретация и реализация имеют свои особенности
для каждой поддерживаемой
PureMVC платформы, используемые паттерны описаны в
известной книге ‘Gang of Four’: Design Patterns: Elements
of Reusable Object-Oriented Software (GoF)
(ISBN 0-201-63361-2)

![Clean Architecture](/images/puremvc/gestalt/clean_architecture.jpg)

The Clean Architecture описывает основные общие правила построения архитектуры приложения.
Как сделать разработку тестируемой, удобной, понятной, а части системы взаимозаменяемыми.
[Оригинал статьи](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)

![SOLID](/images/puremvc/gestalt/solid.jpg)

При создании программных систем использование принципов SOLID способствует созданию
такой системы, которую будет легко поддерживать и расширять в течение долгого времени.
Принципы SOLID — это руководства, которые также могут применяться во время работы
над существующим программным обеспечением для его улучшения, например,
для удаления «дурно пахнущего кода».
[Wiki](https://en.wikipedia.org/wiki/SOLID)

![InversifyJS](/images/puremvc/gestalt/inversifyjs.jpg)

[InversifyJS](https://github.com/inversify/InversifyJS) —
это [IoC](https://en.wikipedia.org/wiki/Inversion_of_control)-контейнер.
Мы можем использовать IoC-контейнер для внедрения значений в компоненты,
не передавая их явно через каждый компонент и не используя контекст.
InversifyJS поддерживает два вида внедрений:

* внедрение через constructor
* внедрение через свойство

Однако LeanES фреймворк не является эталонной реализацией спецификации PureMVC на
языке JavaScript. Наша команда портировала спецификацию PureMVC фреймворка в LeanES
в качестве отдельного слоя. Несомненно это самый важный слой LeanES, т.к. предоставляет
программисту основные идиомы, с помощью которых можно построить любое приложение.

Однако нужно отметить несколько отличий от спецификации PureMVC:

* Добавлены короткие алиасы для основных методов в акторах PureMVC (Model, View,
Controller, Mediator, Proxy, Command) для написания более компактного кода.
Эталонные названия методов сохранены для обратной совместимости или для легкой миграции
программиста с другой платформы или языка программирования, где он уже использовал PureMVC.
* Классы SimpleCommand и MacroCommand объединены в один класс Command, по существу с сохранением
всей функциональности это MacroCommand, но если переопределить в унаследованном классе
метод execute() - это будет просто SimpleCommand.
* Добавлены отсутствующие методы для безопасного удаления созданных сингелтонов в случае, когда
мультитон удаляется. В оригинальной спецификации предусмотрено только создание мультитонов,
но не их удаление.
* Интегрированы дополнительные сущности и методы для работы с ними через <em>Фасад</em>
в рамках концепции "Clean Architecture" by Robert C. Martin (Uncle Bob).
Эти сущности <em>Кейс</em> (Case), <em>Сьюит</em> (Suite) и <em>Адаптер</em> (Adapter)
только расширяют уровни абстракций в составе PureMVC с сохранением обратной совместимости
с эталонной спецификацией.
* В базовые классы ядра (Model, View, Controller, Facade) интегрирована библиотека InversifyJS.
Не смотря на то, что <em>Фасад</em> по существу реализует возможность для инъекции
зависимостей через вызов метода `this.facade.retrieveProxy()` или `this.facade.retrieveMediator()`,
однако в этом случае конкретные классы <em>Медиатора</em>, <em>Команды</em> и <em>Прокси</em> становятся зависимы
от самого Фасада - что является примером антипатерна <em>Сервис-локатор</em> (Service Locator).
Поэтому в состав LeanES на уровне PureMVC интегрирована библиотека InversifyJS, которая
предоставляет возможность описания в классах <em>Медиаторов</em>, <em>Команд</em>
и <em>Прокси</em> а так же в <em>Кейсов</em>, <em>Сьюитов</em> и <em>Адаптеров</em>
"классической" инъекции зависимостей, т.е. через конструктор или через проперти.
Подробнее об этом можно прочитать в разделе "Инверсия зависимости".

Наша команда выражает благодарность создателям PureMVC за возможность портирования
их решения в наш фреймворк LeanES. Ниже приводим сноску из оригинальной документации
PureMVC:

```
PureMVC является бесплатным фреймворком с открытым кодом от Futurescale, Inc.
Copyright © 2006-09. Некоторые права защищены. Использование ограничено лицензией
Creative Commons 3.0. Документация, обучающие материалы и примеры кода с сайта
Futurescale's предоставляются «как есть», без всяких гарантий и включая, но,
не ограничиваясь ими, подразумеваемые гарантии пригодности для целей, или гарантий
ненарушения прав. Implementation Idioms & Best Practices.doc
```

Вся нижеследующая документация для сущностей PureMVC в большей степени базируется на
оригинальной документации PureMVC. Однако примеры кода и отличительные особенности
портированной версии описываются в нижеследующей документации в соответствие с
реальной имплементацией в LeanES фремворке, в том числе и мплементация всех базовых
классов PureMVC.

## Модель и Прокси (Model & Proxies)
<em>Модель</em> просто кэширует именованные ссылки к <em>Прокси</em>. Код <em>Прокси</em>
манипулирует моделью данных, связываясь с удаленными сервисами, если
нужно сохранить или запросить данные.
Таким образом, <em>Модель</em> данных изолирована от контроллеров и
представления. Это приводит к переносимому коду <em>Модели</em>.

## Представление и Медиаторы (View & Mediators)
<em>Представление</em> в первую очередь кэширует именованные ссылки на
<em>Медиаторы</em>. Код <em>Медиатора</em> обслуживает компонент(ы) <em>Представления</em>,
добавляя к ним <em>Слушателей событий</em> и от их имени отправляя и получая
оповещения к и от остальной системы, при этом непосредственно управляя
их состоянием.
Это отделяет определение <em>Вида</em> от управляющей им логики.

## Контроллер и Команды (Controller & Commands)
<em>Контроллер</em> кеширует ссылки на классы <em>Команд</em>, создавая экземпляры
класса команды в тот момент, когда возникает необходимость выполнения
этой команды и уничтожая после выполнения.

Команды могут запрашивать <em>Прокси</em> и взаимодействовать с ними,
отправлять <em>Оповещения</em>, выполнять другие <em>Команды</em>, и часто используются
для <em>дирижирования</em> сложными, охватывающими всю или почти всю систему
действиями, такими, как запуск или остановка приложения. Это альмаматер бизнес-логики вашего приложения.

## Фасад и Ядро (Facade & Core)
<em>Фасад</em> (Facade), еще один синглтон, инициализирует <em>Базовые классы</em>
(Модель, Представление и Контроллер) и предоставляет единую точку
доступа ко всем их публичным методам.

Расширяя <em>Фасад</em>, ваше приложение получает в распоряжение весь
функционал <em>Базовых классов</em> без необходимости их импорта и прямой
работы с ними. Вы реализуете конкретный <em>Фасад</em> в своем приложении
только один раз, и это делается очень просто.

<em>Прокси</em>, <em>Медиаторы</em> и <em>Команды</em> могут использовать <em>конкретный
Фасад</em> вашего приложения для того, чтобы получать доступ и связываться
друг с другом.

## Наблюдатели и Оповещения (Observers & Notifications)
PureMVC-приложения могут выполняться в различных средах,
так что фреймворк реализует схему оповещений
<em>Наблюдатель</em> (Observer) для сообщения между <em>Базовыми классами</em> MVC и
другими частями системы в манере слабого связывания.

Вам не нужно беспокоиться о деталях реализации
<em>Наблюдателя/Оповещения</em> (Observer/Notification) в PureMVC; это
внутренняя часть фреймворка. Вам нужно только использовать простой
метод для отправки <em>Оповещений</em> от <em>Прокси</em>, <em>Медиаторов</em>, <em>Команд</em> и <em>Фасада</em>,
который даже не требует создавать экземпляр <em>Оповещения</em>.

## Оповещения можно использовать для запуска Команд
<em>Команды</em> связаны с именами <em>Оповещений</em> в вашем конкретном <em>Фасаде</em> и
автоматически выполняются <em>Контроллером</em>, когда отправляются
назначенные им <em>Оповещения</em>. <em>Команды</em> обычно дирижируют сложным
взаимодействием между интересами <em>Представления</em> и <em>Модели</em>, при этом
зная о них настолько мало, насколько это возможно.

## Медиаторы отправляют и получают Оповещения, а так же заявляют о заинтересованности в них
При регистрации в <em>Представлении</em> <em>Медиаторы</em> опрашиваются на предмет их
заинтересованности в <em>Оповещениях</em>, для чего вызывается метод
listNotifications, и должны возвращать массив имен <em>Оповещений</em>, в которых
они заинтересованы.

Позже, когда кто-то в системе отправляет одноименное <em>Оповещение</em>,
заинтересованные <em>Медиаторы</em> будут оповещены через вызов их метода
handleNotification, которому будет передана ссылка на <em>Оповещение</em>.

## Прокси отправляют, но не получают Оповещений
<em>Прокси</em> могут отправлять <em>Оповещения</em> по различным поводам. Например,
<em>Прокси</em> для удаленного сервиса может оповестить систему о том, что он
получил результат с сервера. Или другой <em>Прокси</em> может оповестить систему
о том, что изменились его данные.

Для <em>Прокси</em> слушать <em>Оповещения</em> — это слишком сильное связывание с
уровнями <em>Вида</em> и <em>Контроллера</em>.

Эти уровни обязаны слушать <em>Оповещения</em> от <em>Прокси</em>, так как их функция
заключается в визуальном представлении и обеспечении взаимодействия
пользователя с данными <em>Модели</em>, за которые отвечают <em>Прокси</em>.

Тем не менее, уровни <em>Вида</em> и <em>Контроллера</em> должны иметь возможность
изменений, не влияющих на уровень <em>Модели данных</em>.

Например, административное приложение и связанное с ним
пользовательское приложение могут иметь общие классы уровня <em>Модели</em>.
Если отличаются только сценарии использования, то эти отличия можно
реализовать за счет различных комбинаций <em>Представления</em> и <em>Контроллера</em>,
работающих с одной и той же <em>Моделью</em>.
