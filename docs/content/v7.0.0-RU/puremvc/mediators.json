{"data":{"type":"contents","id":"puremvc/mediators","attributes":{"content":"<em>Медиаторы</em> используются для взаимодействия пользователей с одним или\nболее компонентами <em>Представления</em>, (например DOM elements, UI Component,\nHTTP request, RabbitMQ message, ...) в браузере или для обработки <em>Запросов</em>,\n<em>Событий</em>, <em>Сообщений</em> на NodeJS, и остальными частями PureMVC приложения.\n\nВо Frontend-приложении <em>Медиатор</em> является местом, где обычно устанавливают\nобработчики событий <em>Представления</em> для обработки пользовательских\nдействий и запросов данных от компонента. Он посылает и принимает\n<em>Оповещения</em> (Notifications) для взаимодействия c приложением.\n\n## Задачи конкретного Медиатора\nФреймворки для Frontend включают немало компонент для\nпостроения графических интерфейсов. Вы можете использовать\nстандартные компоненты, либо реализовывать свои для представления\nмодели данных пользователю, и позволять ему взаимодействовать с ними.\n\nТак же для NodeJS - существует не мало библиотек для работы с различными каналами\nданных, протоколами передачи данных или через непосредственную работу с UNIX-сокетами.\n\nЗадача PureMVC - оставаться нейтральным к используемым технологиям в\nприложении, предоставляя простые идиомы для работы с любыми\nкомпонентами графического интерфейса, каналами и протоколами данными или Моделью Данных.\n\nДля PureMVC-приложения компонент <em>Представления</em> это любой элемент\nуправления графического интерфейса, либо контейнер с несколькими\nкомпонентами, независимо от конкретной платформы, а в случае NodeJS -\nлюбой источник <em>Событий</em> или канал данных.\n<em>Представление</em> должно инкапсулировать как можно больше собственных\nсостояний и операций, предоставляя простой интерфейс для\nвзаимодействия с ним.\n\n<em>Конкретный Медиатор</em> позволяет использовать один или более компонентов\n<em>Представления</em> в приложении используя только ссылки и предоставленное\nAPI.\n\nОсновная задача <em>Медиатора</em> - обработка событий (Events), инициированных\nкомпонентом <em>Представления</em> и касающихся его <em>Оповещений</em> (Notifications).\n\n<em>Медиаторы</em> также часто взаимодействуют с <em>Прокси</em>. Довольно\nраспространенная практика получения и хранения локальных ссылок на\nчасто используемые экземпляры <em>Прокси</em> в конструкторе. Это уменьшает\nмногочисленные вызовы retrieveProxy для получения одних и тех же\nссылок.\n\n## Неявное преобразование типов компонентов Представления\nБазовый класс <em>Медиатор</em> реализованный в PureMVC принимает в качестве\nаргументов своего конструктора имя и объект <em>Представления</em> типа Object.\n\nКонструктор вашего конкретного <em>Медиатора</em> будет принимать компонент\n<em>Представления</em>, делая его сразу же доступным в защищенном (protected)\nсвойстве класса viewComponent, обычно типа Object.\n\nВы также можете, используя метод setViewComponent, динамически\nустанавливать экземпляр <em>Представления</em> в <em>Медиаторе</em> после вызова\nконструктора.\n\nПосле присвоения вы часто будете приводить этот объект к конкретному\nтипу, что может быть неудобно, а также способствовать распространению\nповторяемого кода.\n\nЯзык JavaScript предоставляет возможность называемую геттеры и\nсеттеры (getters/setters). Геттер выглядит как метод, но используется как\nсвойство класса. Эта возможность очень полезна для решения проблемы\nчастого приведения типа.\n\nПолезная идиома применяемая в вашем конкретном <em>Медиаторе</em>, -\nиспользование геттера для приведения типа <em>Представления</em> к его\nнастоящему типу с понятным именем.\n\nНапример так:\n\n```js\n@property get controlBar(): MyAppControlBar {\n  return this.getViewComponent();\n}\n```\n\nЗатем, в любом месте вашего Медиатора чем делать это так:\n\n```js\nconst vc: MyAppControlBar = this.getViewComponent();\nvc.searchSelection = MyAppControlBar.NONE_SELECTED;\n```\n\nМы вместо этого делаем так:\n\n```js\nthis.controlBar.searchSelection = MyAppControlBar.NONE_SELECTED;\n```\n\n## Взаимодействие с Представлением\n<em>Медиатор</em> обычно имеет только один компонент <em>Представления</em>, но может\nвзаимодействовать и с несколькими, например: с ApplicationToolBar и\nсодержащимися в нем кнопками, либо другими аналогичными\nкомпонентами. Мы можем иметь группу связанных компонентов (как\nформа) в одном <em>Представлении</em> и обращаться <em>Медиатором</em> к её элементам\nкак к свойствам. Но лучше инкапсулировать в <em>Представлении</em> как можно\nбольше компонентов. Иметь специализированный объект для обмена\nданными тоже хорошая практика.\n\n<em>Медиатор</em> отвечает за взаимодействие уровня <em>Контроллера</em> и <em>Модели</em>,\nобновляя <em>Представление</em> когда получает соответствующие <em>Оповещения</em>\n(Notifications).\nВо Flash, мы обычно подписываем слушателей событий к компоненту\n<em>Представления</em>, в момент создания <em>Медиатора</em> или по вызову метода\nsetViewComponent, определяя метод обработчика:\n\n```js\n@method onRegister() {\n  super.onRegister();\n  // The STDOUT pipe from the shell to all modules\n  this._junction.registerPipe(STDOUT, OUTPUT, TeeSplit.new());\n  // The STDIN pipe to the shell from all modules\n  this._junction.registerPipe(STDIN, INPUT, TeeMerge.new());\n  this._junction.addPipeListener(STDIN, this, this.handlePipeMessage);\n  // The STDLOG pipe from the shell to the logger\n  this._junction.registerPipe(STDLOG, OUTPUT, Pipe.new());\n  this.send(CONNECT_SHELL_TO_LOGGER, this._junction);\n}\n```\n\nДействия <em>Медиатора</em>, в ответ на возникшее <em>Событие</em>, определяется\nтребованиями логики.\n\nОбычно, конкретный метод обработчика <em>События</em> <em>Медиатора</em> выполняет\nтакие действия:\n* Изучает тип <em>События</em> либо поля специализированного типа <em>События</em>,\nкоторый ожидается.\n* Читает или модифицирует доступные свойства (либо вызывает\nметоды) компоненты <em>Представления</em>.\n* Читает или модифицирует доступные свойства (либо вызывает\nметоды) <em>Прокси</em>.\n* Шлет одно или более <em>Оповещение</em>, на которое будут реагировать\n<em>Медиаторы</em> и <em>Команды</em>.\n\nНесколько хороших правил:\n\n* Если несколько других <em>Медиаторов</em> должно быть вовлечено в\nобработку ответа на <em>Событие</em>, изменяйте общие <em>Прокси</em> либо\nотсылайте <em>Оповещения</em>, которые обработают соответствующие\n<em>Медиаторы</em>.\n* Если требуется большое количество согласованных взаимодействий,\nхорошая практика использовать <em>Команду</em>, локализируя шаги в одном\nместе.\n* Плохой практикой считается получение других <em>Медиаторов</em>, либо\n<em>Медиаторов</em> с открытыми методами для непосредственной\nманипуляции.\n* Для манипулирования и распространения информации о состоянии\nприложения к <em>Медиаторам</em>, устанавливайте значения свойств\n<em>Медиатора</em>, или вызывайте методы <em>Прокси</em>, созданные для установки\nсостояния. Пусть медиатор будет заинтересован в оповещениях,\nотправляемых <em>Прокси</em>, хранящих состояние приложения.\n\n## Обработка оповещений в Медиаторе\nВместо явного добавления слушателей событий для <em>Представления</em>,\nможно очень просто и почти автоматически связать между собой <em>Медиатор</em>\nи PureMVC.\n\nПосле регистрации <em>Представления</em>, <em>Медиатор</em> опрашивается на наличие\nзаинтересованных оповещений и в ответ возвращает массив имен\n<em>Оповещений</em> (Notifications name), которые он хотел бы обрабатывать.\n\nОтвет проще всего реализовать с помощью одного простого выражения,\nкоторое будет возвращать массив с именами оповещений, которые должны\nбыть определены как статические константы, обычное это делается в\n<em>Фасаде</em> приложения.\n\nСоздать список заинтересованных <em>Оповещений</em> (Notification Interests) для\nконкретного <em>Медиатора</em> можно следующим образом:\n\n```js\n@method listNotificationInterests(): string[] {\n  return [ CONNECT_MODULE_TO_LOGGER, CONNECT_SHELL_TO_LOGGER ];\n}\n```\n\nПеречисленные оповещения, будут сразу обрабатываться <em>Медиатором</em> как\nтолько они будет отосланы любым из игроков системы.\n\nВнутри обработчика оповещений, для удобства и читабельности кода\nвместо «if / else if» лучше использовать конструкцию «switch / case».\n\nПо сути, для каждого оповещения достаточно небольшого обработчика, а\nвся нужная информация должна находиться в самом объекте оповещения.\nПравда иногда информация может быть получена от <em>Посредника</em>,\nоснованная на данных из объекта оповещения. Желательно избегать\nнагромождения логики в одном обработчике, иначе это верный признак\nтого, что вы стараетесь перенести бизнес логику из <em>Команды</em> (Command) в\nобработчик оповещений (notification) медиатора.\n\n```js\n@method handleNotification<T = ?any>(note: NotificationInterface<T>): ?Promise<void> {\n  switch (note.getName()) {\n    // Connect any Module's STDLOG to the logger's STDIN\n    case (CONNECT_MODULE_TO_LOGGER):\n      const module = note.getBody();\n      const pipe = Pipe.new();\n      module.acceptOutputPipe(STDLOG, pipe);\n      this.logger.acceptInputPipe(STDIN, pipe);\n      break;\n    // Bidirectionally connect shell and logger on STDLOG/STDSHELL\n    case (CONNECT_SHELL_TO_LOGGER):\n      // The junction was passed from ShellJunctionMediator\n      const junction = note.getBody();\n      // Connect the shell's STDLOG to the logger's STDIN\n      const shellToLog = junction.retrievePipe(STDLOG);\n      this.logger.acceptInputPipe(STDIN, shellToLog);\n      // Connect the logger's STDSHELL to the shell's STDIN\n      const logToShell = Pipe.new();\n      const shellIn = junction.retrievePipe(STDIN);\n      shellIn.connectInput(logToShell);\n      this.logger.acceptOutputPipe(STDSHELL, logToShell);\n      break;\n  }\n}\n```\n\nПрактика показывает, что лучше всего обрабатывать 4-5 оповещений в\nодном обработчике.\n\nЕсли оповещений больше, желательно разбить этот обработчик на\nнесколько менее громоздких. Создавая <em>медиаторы</em> для отдельных\nкомпонентов <em>Представления</em>, можно избежать накопления оповещений в\nодном обработчике.\n\nИспользование единого, заранее определенного метода оповещения,\nявляется главной отличительной чертой <em>Медиатора</em>, как он обрабатывает\nсобытия и оповещения.\n\nДля событий мы можем определить целый ряд обработчиков, но обычно для\nкаждого события есть свой единственный обработчик. Эти методы не\nдолжны быть слишком сложными, или заниматься слишком мелкими\nзадачами по работе с каждым компонентом <em>Представления</em>, поскольку\n<em>Представление</em> должен быть написан так, чтобы включать в себя детали\nсвоей реализации, предоставляя <em>Медиатору</em> четко разделенный по\nнаправлениям интерфейс.\n\nИспользуя <em>Оповещения</em>, у вас есть единственный метод-обработчик, в\nкотором вы обрабатываете все <em>Оповещения</em> нужные для <em>Медиатора</em>.\n\nЛучше всего обрабатывать все оповещения в одном методе, используя\nswitch конструкцию для различия оповещения по именам.\n\nБыло много обсуждений по поводу использования switch конструкции,\nмногие разработчики считают, что эта конструкция ограничивает одним\nспособом обработки. Однако рекомендуемая практика это использования\nодного метода обработчика оповещения и switch-конструкция.\n\nМедиатор является посредником между <em>Представлением</em> и остальной\nчастью системы.\n\nРассмотрим роль переводчицы беседы между послом и остальными членами\nконференции ООН. Она редко делает что-либо большее чем перевод и\nполучение сообщений, разве что иногда подбирая подходящие метафоры\nили факты. Тоже самое можно сказать о роли <em>Медиатора</em> в рамках PureMVC.\n\n## Связка Медиатора с Прокси и другими Медиаторами\nВ конечном счете, <em>Представление</em> наполняется данными <em>Модели</em> для\nграфического их отображения, взаимодействия с данными через <em>Прокси</em>.\n\n<em>Представление</em> должно знать о <em>Модели</em>, но <em>Модель</em>, в свою очередь, не\nдолжна знать о <em>Представлении</em>.\n\n<em>Медиатор</em> может легко получить доступ к <em>Прокси</em> через <em>Модель</em> и читать и\nманипулировать данными, используя программный интерфейс <em>Прокси</em>. Если\nвыполнять те же операции с помощью <em>Команд</em>, будет потеряна связь между\n<em>Моделью</em> и <em>Представлением</em>. - Однако это можно рассматривать и\nс положительной точки зрения, т.к. уменьшается связность между\n<em>Моделью</em> и <em>Представлением</em>. Чтобы понять, как поступить в этой ситуации,\nстоит руководствоваться правилом <em>Данные вниз - Экшены ввер (DDAU)</em>,\nт.е. можно использовать <em>Прокси</em> непосредственно в <em>Медиаторе</em>\nтолько для отображения данных (только на чтение), а для изменения каких либо данных\nв ответ на <em>Событие</em> в <em>Представлении</em> менять данные в <em>Прокси</em>\nтолько внутри <em>Команды</em> через отправку <em>Оповещения</em>.\n\nТак же <em>Медиатор</em> может получить ссылки на другие <em>Медиаторы</em> из\n<em>Представления</em> и манипулировать данным уже из других <em>Медиаторов</em>.\n\nОднако это не очень хорошая практика, потому что может привести к\nзависимости между частями <em>Представления</em>, что негативно повлияет на\nрефакторинг одной части <em>Представления</em> без затрагивания других частей.\n\nМедиатор, желающий взаимодействовать с другим областям <em>Представления</em>,\nдолжен послать <em>Оповещение</em>, а не манипулировать <em>Представлением</em>\nнапрямую.\n\n<em>Медиатор</em> не должен раскрывать методы для манипулирования своими\nкомпонентами - вместо этого он должен отвечать на оповещения и\nвыполнять свою работу.\n\nЕсли большая часть поведения <em>Компонентов Представления</em> реализована в\n<em>Медиаторе</em> (в ответ на <em>Событие</em> или <em>Оповещение</em>), желательно часть из них\nперенести в само <em>Представление</em>, так чтобы в дальнейшем можно было\nповторно использовать.\n\nЕсли большинство взаимодействий с <em>Прокси</em> или их данными реализованы в\n<em>Медиаторе</em>, перенос этой функциональности в <em>Команду</em> упростит <em>Медиатор</em>.\nТакже перенос бизнес логики в <em>Команды</em> позволяет использовать ее\nдругими <em>Представлениями</em> без потери связки <em>Представление – Модель</em>.\n\n## Взаимодействие пользователя с Представлением и Медиаторами\nРассмотрим медиатор SimpleMediator, инкапсулирующий в себе инстанс `readline`,\nдля взаимодействия с пользователем через консоль.\n\nВзаимодействие инстанса `readline` и <em>Медиатора</em> SimpleMediator\nзаключается в том, что утилита запускает обработчик на событие 'line', когда\nпользователь ввел текст. Медиатор\nSimpleMediator обрабатывает событие, отсылая <em>Оповещение</em> `MSG_FROM_CONSOLE` с\nвведенными данными.\n\n```js\nimport readline from 'readline';\n\nexport default (Module) => {\n  const {\n    START_CONSOLE, MSG_FROM_CONSOLE, MSG_TO_CONSOLE,\n    Mediator,\n    initialize, partOf, meta, property, method, nameBy\n  } = Module.NS;\n\n  @initialize\n  @partOf(Module)\n  class SimpleMediator extends Mediator {\n    @nameBy static __filename = __filename;\n    @meta static object = {};\n\n    @method listNotificationInterests(): string[] {\n      const interests = super.listNotificationInterests(... arguments);\n      interests.push(START_CONSOLE);\n      interests.push(MSG_TO_CONSOLE);\n      return interests;\n    }\n\n    @method handleNotification<T = ?any>(note: NotificationInterface<T>): ?Promise<void> {\n      switch (note.getName()) {\n        case (START_CONSOLE):\n          this.stdinStart();\n          break;\n        case (MSG_TO_CONSOLE):\n          this.stdinComplete(note.getBody());\n          break;\n        default:\n          super.handleNotification(note);\n      }\n    }\n\n    @method onRegister() {\n      super.onRegister();\n      this.rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout,\n        prompt: '... waiting new text ...\\n'\n      });\n      this.rl.setMaxListeners(Number.MAX_SAFE_INTEGER);\n    }\n\n    @method async onRemove(): Promise<void> {\n      await super.onRemove();\n      this.rl.close()\n    }\n\n    @method stdinStart() {\n      console.log('Start: ');\n      this.rl.prompt();\n      this.rl.on('line', (input) => {\n        console.log(`Received: ${input}`);\n        this.send(MSG_FROM_CONSOLE, input);\n      });\n    }\n\n    @method stdinComplete(body) {\n      console.log('Complete: ', body);\n      this.rl.prompt();\n    }\n  }\n}\n```\n\nМетод onRegister вызывается при инстанцировании <em>Медиатора</em>, в нем мы\nсоздаем компонент консольного интерфейса с пользователем.\n\nВся логика компонента находится в <em>Медиаторе</em>, где обрабатывается\nсобытие 'line' и отсылается `MSG_FROM_CONSOLE` <em>Оповещение</em>ю\n\n```js\nimport type { NotificationInterface } from '../interfaces/NotificationInterface';\nimport type { SimpleProxyInterface } from '../interfaces/SimpleProxyInterface';\n\nexport default (Module) => {\n  const {\n    SIMPLE_PROXY, MSG_TO_CONSOLE,\n    Command,\n    initialize, partOf, meta, method, property, nameBy, inject,\n  } = Module.NS;\n\n  @initialize\n  @partOf(Module)\n  class SimpleCommand extends Command {\n    @nameBy static  __filename = __filename;\n    @meta static object = {};\n\n    @inject(`Factory<${SIMPLE_PROXY}>`)\n    @property _simpleProxyFactory: () => SimpleProxyInterface;\n    @property get _simpleProxy(): SimpleProxyInterface {\n      return this._simpleProxyFactory()\n    }\n\n    @method execute<T = ?any>(note: NotificationInterface<T>): void {\n      this._simpleProxy.setData(note.getBody())\n      this.send(MSG_TO_CONSOLE, this._simpleProxy.getData());\n    }\n  }\n}\n```\n\nMы зарегистрировали команду SimpleCommand для этого <em>Оповещения</em>.\nЭта команда будет вызывать метод setData <em>Прокси</em> SimpleProxy,\nпередавая объект, полученный от медиатора.\n\n<em>Медиатор</em> SimpleMediator имеет список заинтересованных оповещений,\nв который входят `START_CONSOLE` и `MSG_TO_CONSOLE`. <em>Оповещение</em>\n`START_CONSOLE` отправляется после запуска приложения, чтобы активировать утилиту\nвнутри этого медиатора, а `MSG_TO_CONSOLE` - это <em>Оповещение</em>, на которое\nподписан <em>Медиатор</em>, чтобы вывести на консоль пользователю некоторое сообщение.","description":"Медиаторы используются для взаимодействия пользователей с одним или более компонентами Представления, (например DOM elements, UI Component, HTTP request, RabbitMQ message, …) в браузере или для обработки Запросов, Событий, Сообщений на NodeJS, и остальными..."}}}