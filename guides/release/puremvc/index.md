Фреймворк PureMVC преследует очень узкую цель. Она в том, чтобы помочь
вам разделить интересы кода вашего приложения на три отдельных уровня:
<em>Модель</em> (Model), <em>Представление</em> (View) и <em>Контроллер</em> (Controller).

Для создания масштабируемых и легко поддерживаемых приложений
высоким приоритетом являются разделение интересов, а так же
герметичность и направление связей между уровнями MVC

В данной реализации классического мета-паттерна MVC эти три уровня
приложения управляются тремя синглтонами (классами, для которых
возможно существование одного и только одного экземпляра), называемыми
просто: <em>Модель</em> (Model), <em>Представление</em> (View) и <em>Контроллер</em> (Controller). Все
вместе они называются <em>Базовыми классами</em> (Core actors).

Четвертый синглтон, Фасад (Façade), упрощает разработку, предоставляя
единый интерфейс для сообщения с <em>Базовыми классами</em>.

## Модель и Прокси (Model & Proxies)
<em>Модель</em> просто кэширует именованные ссылки к <em>Прокси</em>. Код <em>Прокси</em>
манипулирует моделью данных, связываясь с удаленными сервисами, если
нужно сохранить или запросить данные.
Таким образом, <em>Модель</em> данных изолирована от контроллеров и
представления. Это приводит к переносимому коду <em>Модели</em>.

## Представление и Медиаторы (View & Mediators)
<em>Представление</em> в первую очередь кэширует именованные ссылки на
<em>Медиаторы</em>. Код <em>Медиатора</em> обслуживает компонент(ы) <em>Представления</em>,
добавляя к ним <em>Слушателей событий</em> и от их имени отправляя и получая
оповещения к и от остальной системы, при этом непосредственно управляя
их состоянием.
Это отделяет определение <em>Вида</em> от управляющей им логики.

## Контроллер и Команды (Controller & Commands)
<em>Контроллер</em> кеширует ссылки на классы <em>Команд</em>, создавая экземпляры
класса команды в тот момент, когда возникает необходимость выполнения
этой команды и уничтожая после выполнения.

Команды могут запрашивать <em>Прокси</em> и взаимодействовать с ними,
отправлять <em>Оповещения</em>, выполнять другие <em>Команды</em>, и часто используются
для <em>дирижирования</em> сложными, охватывающими всю или почти всю систему
действиями, такими, как запуск или остановка приложения. Это альмаматер бизнес-логики вашего приложения.

## Фасад и Ядро (Façade & Core)
<em>Фасад</em> (Façade), еще один синглтон, инициализирует <em>Базовые классы</em>
(Модель, Представление и Контроллер) и предоставляет единую точку
доступа ко всем их публичным методам.

Расширяя <em>Фасад</em>, ваше приложение получает в распоряжение весь
функционал <em>Базовых классов</em> без необходимости их импорта и прямой
работы с ними. Вы реализуете конкретный <em>Фасад</em> в своем приложении
только один раз, и это делается очень просто.

<em>Прокси</em>, <em>Медиаторы</em> и <em>Команды</em> могут использовать <em>конкретный
Фасад</em> вашего приложения для того, чтобы получать доступ и связываться
друг с другом.

## Наблюдатели и Оповещения (Observers & Notifications)
PureMVC-приложения могут выполняться в различных средах,
так что фреймворк реализует схему оповещений
<em>Наблюдатель</em> (Observer) для сообщения между <em>Базовыми классами</em> MVC и
другими частями системы в манере слабого связывания.

Вам не нужно беспокоиться о деталях реализации
<em>Наблюдателя/Оповещения</em> (Observer/Notification) в PureMVC; это
внутренняя часть фреймворка. Вам нужно только использовать простой
метод для отправки <em>Оповещений</em> от <em>Прокси</em>, <em>Медиаторов</em>, <em>Команд</em> и <em>Фасада</em>,
который даже не требует создавать экземпляр <em>Оповещения</em>.

## Оповещения можно использовать для запуска Команд
<em>Команды</em> связаны с именами <em>Оповещений</em> в вашем конкретном <em>Фасаде</em> и
автоматически выполняются <em>Контроллером</em>, когда отправляются
назначенные им <em>Оповещения</em>. <em>Команды</em> обычно дирижируют сложным
взаимодействием между интересами <em>Представления</em> и <em>Модели</em>, при этом
зная о них настолько мало, насколько это возможно.

## Медиаторы отправляют и получают Оповещения, а так же заявляют о заинтересованности в них
При регистрации в <em>Представлении</em> <em>Медиаторы</em> опрашиваются на предмет их
заинтересованности в <em>Оповещениях</em>, для чего вызывается метод
listNotifications, и должны возвращать массив имен <em>Оповещений</em>, в которых
они заинтересованы.

Позже, когда кто-то в системе отправляет одноименное <em>Оповещение</em>,
заинтересованные <em>Медиаторы</em> будут оповещены через вызов их метода
handleNotification, которому будет передана ссылка на <em>Оповещение</em>.

## Прокси отправляют, но не получают Оповещений
<em>Прокси</em> могут отправлять <em>Оповещения</em> по различным поводам. Например,
<em>Прокси</em> для удаленного сервиса может оповестить систему о том, что он
получил результат с сервера. Или другой <em>Прокси</em> может оповестить систему
о том, что изменились его данные.

Для <em>Прокси</em> слушать <em>Оповещения</em> — это слишком сильное связывание с
уровнями <em>Вида</em> и <em>Контроллера</em>.

Эти уровни обязаны слушать <em>Оповещения</em> от <em>Прокси</em>, так как их функция
заключается в визуальном представлении и обеспечении взаимодействия
пользователя с данными <em>Модели</em>, за которые отвечают <em>Прокси</em>.

Тем не менее, уровни <em>Вида</em> и <em>Контроллера</em> должны иметь возможность
изменений, не влияющих на уровень <em>Модели данных</em>.

Например, административное приложение и связанное с ним
пользовательское приложение могут иметь общие классы уровня <em>Модели</em>.
Если отличаются только сценарии использования, то эти отличия можно
реализовать за счет различных комбинаций <em>Представления</em> и <em>Контроллера</em>,
работающих с одной и той же <em>Моделью</em>.
