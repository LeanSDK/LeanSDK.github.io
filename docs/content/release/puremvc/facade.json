{"data":{"type":"contents","id":"puremvc/facade","attributes":{"content":"Три <em>Базовых класса</em> мета-паттерна MVC представлены в PureMVC\nклассами <em>Модели</em>, <em>Представления</em> и <em>Контроллера</em>. Чтобы упростить процесс\nразработки приложения, PureMVC задействует паттерн <em>Фасад</em>.\n\n<em>Фасад</em> распределяет ваши запросы к <em>Модели</em>, <em>Представлению</em> и <em>Контроллеру</em>,\nтак что ваш код не нуждается в импорте этих классов и вам не нужно\nработать с ними индивидуально. Класс <em>Фасада</em> автоматически создает\nэкземпляры базовых синглтонов MVC в своем конструкторе.\n\nОбычно <em>Фасад</em> самого фреймворка становится над-классом вашего\nприложения и используется для инициализации <em>Контроллера</em> с назначениями\n<em>Команд</em>. Подготовка <em>Модели</em> и <em>Представления</em> затем дирижируется\n<em>Командами</em>, выполняемыми <em>Контроллером</em>.\n\n## Что такое Конкретный Фасад (Concrete Façade)?\nХотя <em>Базовые классы</em> являются завершенными, готовыми к использованию\nреализациями, <em>Фасад</em> предоставляет реализацию, которую следует\nрассматривать как <em>абстрактную</em> в том смысле, что вы никогда не создаете\nего экземпляр непосредственным образом.\n\nВместо этого вы наследуете <em>Фасад</em> из фреймворка и / или переопределяете\nнекоторые его методы, чтобы сделать их полезными конкретно для вашего\nприложения. (вы конкретизируете абстрактный\n<em>Фасад</em> фреймворка в конкретный <em>Фасад</em> своего приложения).\n\nЭтот конкретный <em>Фасад</em> затем используется для доступа и оповещения\n<em>Команд</em>, <em>Медиаторов</em> и <em>Прокси</em>, которые делают свою работу в системе. По\nсоглашению, он называется ‘ApplicationFacade’, но вы можете назвать его\nкак хотите.\n\nВ общем случае иерархия <em>Представления</em> вашего приложения\nбудет создаваться согласно принятого для вашей платформы\nпроцесса. Как только построена иерархия <em>Представления</em> приложения,\nстартует аппарат PureMVC и регионы <em>Модели</em> и <em>Вида</em>\nготовятся к использованию.\n\nВаш <em>конкретный Фасад</em> также используется для облегчения процесса\nстарта приложения, в том смысле, что он освобождает основной код\nприложения от необходимости глубокой осведомленности об аппарате\nPureMVC, к которому это приложение будет подключено. Приложение\nпросто передает ссылку на себя в метод ‘startup’ синглтон-экземпляра\nвашего конкретного <em>Фасада</em>.\n\n## Создание Конкретного Фасада для вашего приложения\nВашему конкретному <em>Фасаду</em> не обязательно прилагать много усилий,\nчтобы передать приложению силу PureMVC. Рассмотрим следующую\nреализацию:\n\n```js\nexport default (Module) => {\n  const {\n    STARTUP,\n    Facade,\n    initialize, partOf, meta, property, method, nameBy\n  } = Module.NS;\n\n  @initialize\n  @partOf(Module)\n  class ApplicationFacade extends Facade {\n    @nameBy static  __filename = __filename;\n    @meta static object = {};\n\n    @property _isInitialized: boolean = false;\n\n    @method startup(app) {\n      if (!this._isInitialized) {\n        this._isInitialized = true;\n        this.send(STARTUP, app);\n      }\n    }\n\n    @method initializeFacade(): void {\n      super.initializeFacade(... arguments)\n      this.rebind('ApplicationModule').toConstructor(this.Module);\n      this.addCommand(STARTUP, 'StartupCommand');\n    }\n  }\n}\n```\n\nОтметим несколько моментов в приведенном выше коде:\n\n* Он расширяет класс Facade PureMVC, который в свою очередь\nреализует интерфейс IFacade.\n* Он не переопределяет конструктор. Если бы он это делал, то нужно\nбыло бы вызвать конструктор суперкласса прежде, чем делать чтолибо.\n* Он определяет константы для имен <em>Оповещений</em> (STARTUP). Поскольку это\nигрок, используемый всеми другими участинками системы для\nдоступа и связи друг с другом, <em>конкретный Фасад</em> является\nидеальным местом для определения констант, общих для всех\nучастников обмена оповещениями.\n* Он инициализирует <em>Контроллер</em> <em>Командами</em>, которые будут\nвыполняться при отправке соответствующих <em>Оповещений</em>.\n* Он предоставляет метод startup, который принимает один аргумент (в\nданном случае) типа MyApp, который с помощью <em>Оповещения</em>\nпередается <em>Команде</em> StartupCommand (зарегистрированной на имя\nоповещения STARTUP).\n\nС этими простыми требованиями реализации ваш <em>конкретный Фасад</em>\nунаследует ощутимую часть функциональности своего абстрактного класса-родителя.\n\n## Инициализация вашего Конкретного Фасада\nКонструктор <em>Фасада</em> PureMVC вызывает защищенные методы для\nинициализации экземпляров <em>Модели</em>, <em>Представления</em> и <em>Контроллера</em> и\nкэширует их ссылки на них.\n\nЗатем по композиции <em>Фасад</em> реализует и делает доступными возможности\n<em>Модели</em>, <em>Представления</em> и <em>Контроллера</em>; агрегируя их функциональность и\nзащищая разработчика от прямого взаимодействия с <em>Базовыми\nклассами</em> фреймворка.\n\nИтак, где и как <em>Фасад</em> внедряется в реальное положение вещей\nконкретного приложения? Рассмотрим упрощенный пример из реального приложения:\n\n```js\nexport default (Module) => {\n  const {\n    LIGHTWEIGHT,\n    initialize, partOf, meta, property, method, nameBy,\n    Utils: { uuid }\n  } = Module.NS;\n\n  @initialize\n  @partOf(Module)\n  class Application extends CoreObject {\n    @nameBy static  __filename = __filename;\n    @meta static object = {};\n\n    @property isLightweight: boolean = false;\n    @property name: string = null;\n\n    @method start(): void {\n      this.facade.startup(this);\n    }\n\n    @method async finish(): Promise<void> {\n      await this.facade.remove();\n    }\n\n    constructor(name: string, ApplicationFacade: Class<*>, symbol: ?Symbol) {\n      const isLightweight = symbol === LIGHTWEIGHT;\n      if (isLightweight) {\n        const appName = `${name}|>${uuid.v4()}`\n        super(ApplicationFacade.getInstance(appName));\n        this.name = appName;\n      } else {\n        super(ApplicationFacade.getInstance(name));\n        this.name = name;\n      }\n      this.isLightweight = isLightweight;\n    }\n  }\n}\n```\n\nВот и все. Достаточно просто.\n\nСоздайте эту начальную иерархию вида, получите\nэкземпляр ApplicationFacade и вызовите его метод startup.\n\nКлючевые моменты этого примера:\n\n* Поскольку мы инициализируем переменную вызовом\nстатического метода ApplicationFacade.getInstance, то это\nозначает, что в момент создания Application\nбудет создан <em>Фасад</em>, а вместе с ним и <em>Модель</em>, <em>Представление</em> и\n<em>Контроллер</em>, хотя ни <em>Медиаторы</em>, ни <em>Прокси</em> не будут пока\nсозданы.\n* В отдельном методе start инстанса Application мы\nвызываем метод startup, передавая ему ссылку на главное\nприложение в качестве аргумента.\n\nЗаметьте, что обычные компоненты <em>Представления</em> не нуждаются в знании\nтого, как им нужно взаимодействовать с Фасадом, но объект верхнего\nуровня Application является исключением для этого правила.\n\nВерхнеуровневый объект Application строит\nиерархию <em>Вида</em>, инициализирует <em>Фасад</em>, а затем запускает аппарат\nPureMVC.","description":"Три Базовых класса мета-паттерна MVC представлены в PureMVC классами Модели, Представления и Контроллера. Чтобы упростить процесс разработки приложения, PureMVC задействует паттерн Фасад. \n\nФасад распределяет ваши запросы к Модели, Представлению и..."}}}