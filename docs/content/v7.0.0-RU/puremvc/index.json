{"data":{"type":"contents","id":"puremvc/index","attributes":{"content":"Фреймворк PureMVC преследует очень узкую цель. Она в том, чтобы помочь\nвам разделить интересы кода вашего приложения на три отдельных уровня:\n<em>Модель</em> (Model), <em>Представление</em> (View) и <em>Контроллер</em> (Controller).\n\nДля создания масштабируемых и легко поддерживаемых приложений\nвысоким приоритетом являются разделение интересов, а так же\nгерметичность и направление связей между уровнями MVC\n\nВ данной реализации классического мета-паттерна MVC эти три уровня\nприложения управляются тремя синглтонами (классами, для которых\nвозможно существование одного и только одного экземпляра), называемыми\nпросто: <em>Модель</em> (Model), <em>Представление</em> (View) и <em>Контроллер</em> (Controller). Все\nвместе они называются <em>Базовыми классами</em> (Core actors).\n\nЧетвертый синглтон, Фасад (Façade), упрощает разработку, предоставляя\nединый интерфейс для сообщения с <em>Базовыми классами</em>.\n\n## Модель и Прокси (Model & Proxies)\n<em>Модель</em> просто кэширует именованные ссылки к <em>Прокси</em>. Код <em>Прокси</em>\nманипулирует моделью данных, связываясь с удаленными сервисами, если\nнужно сохранить или запросить данные.\nТаким образом, <em>Модель</em> данных изолирована от контроллеров и\nпредставления. Это приводит к переносимому коду <em>Модели</em>.\n\n## Представление и Медиаторы (View & Mediators)\n<em>Представление</em> в первую очередь кэширует именованные ссылки на\n<em>Медиаторы</em>. Код <em>Медиатора</em> обслуживает компонент(ы) <em>Представления</em>,\nдобавляя к ним <em>Слушателей событий</em> и от их имени отправляя и получая\nоповещения к и от остальной системы, при этом непосредственно управляя\nих состоянием.\nЭто отделяет определение <em>Вида</em> от управляющей им логики.\n\n## Контроллер и Команды (Controller & Commands)\n<em>Контроллер</em> кеширует ссылки на классы <em>Команд</em>, создавая экземпляры\nкласса команды в тот момент, когда возникает необходимость выполнения\nэтой команды и уничтожая после выполнения.\n\nКоманды могут запрашивать <em>Прокси</em> и взаимодействовать с ними,\nотправлять <em>Оповещения</em>, выполнять другие <em>Команды</em>, и часто используются\nдля <em>дирижирования</em> сложными, охватывающими всю или почти всю систему\nдействиями, такими, как запуск или остановка приложения. Это альмаматер бизнес-логики вашего приложения.\n\n## Фасад и Ядро (Façade & Core)\n<em>Фасад</em> (Façade), еще один синглтон, инициализирует <em>Базовые классы</em>\n(Модель, Представление и Контроллер) и предоставляет единую точку\nдоступа ко всем их публичным методам.\n\nРасширяя <em>Фасад</em>, ваше приложение получает в распоряжение весь\nфункционал <em>Базовых классов</em> без необходимости их импорта и прямой\nработы с ними. Вы реализуете конкретный <em>Фасад</em> в своем приложении\nтолько один раз, и это делается очень просто.\n\n<em>Прокси</em>, <em>Медиаторы</em> и <em>Команды</em> могут использовать <em>конкретный\nФасад</em> вашего приложения для того, чтобы получать доступ и связываться\nдруг с другом.\n\n## Наблюдатели и Оповещения (Observers & Notifications)\nPureMVC-приложения могут выполняться в различных средах,\nтак что фреймворк реализует схему оповещений\n<em>Наблюдатель</em> (Observer) для сообщения между <em>Базовыми классами</em> MVC и\nдругими частями системы в манере слабого связывания.\n\nВам не нужно беспокоиться о деталях реализации\n<em>Наблюдателя/Оповещения</em> (Observer/Notification) в PureMVC; это\nвнутренняя часть фреймворка. Вам нужно только использовать простой\nметод для отправки <em>Оповещений</em> от <em>Прокси</em>, <em>Медиаторов</em>, <em>Команд</em> и <em>Фасада</em>,\nкоторый даже не требует создавать экземпляр <em>Оповещения</em>.\n\n## Оповещения можно использовать для запуска Команд\n<em>Команды</em> связаны с именами <em>Оповещений</em> в вашем конкретном <em>Фасаде</em> и\nавтоматически выполняются <em>Контроллером</em>, когда отправляются\nназначенные им <em>Оповещения</em>. <em>Команды</em> обычно дирижируют сложным\nвзаимодействием между интересами <em>Представления</em> и <em>Модели</em>, при этом\nзная о них настолько мало, насколько это возможно.\n\n## Медиаторы отправляют и получают Оповещения, а так же заявляют о заинтересованности в них\nПри регистрации в <em>Представлении</em> <em>Медиаторы</em> опрашиваются на предмет их\nзаинтересованности в <em>Оповещениях</em>, для чего вызывается метод\nlistNotifications, и должны возвращать массив имен <em>Оповещений</em>, в которых\nони заинтересованы.\n\nПозже, когда кто-то в системе отправляет одноименное <em>Оповещение</em>,\nзаинтересованные <em>Медиаторы</em> будут оповещены через вызов их метода\nhandleNotification, которому будет передана ссылка на <em>Оповещение</em>.\n\n## Прокси отправляют, но не получают Оповещений\n<em>Прокси</em> могут отправлять <em>Оповещения</em> по различным поводам. Например,\n<em>Прокси</em> для удаленного сервиса может оповестить систему о том, что он\nполучил результат с сервера. Или другой <em>Прокси</em> может оповестить систему\nо том, что изменились его данные.\n\nДля <em>Прокси</em> слушать <em>Оповещения</em> — это слишком сильное связывание с\nуровнями <em>Вида</em> и <em>Контроллера</em>.\n\nЭти уровни обязаны слушать <em>Оповещения</em> от <em>Прокси</em>, так как их функция\nзаключается в визуальном представлении и обеспечении взаимодействия\nпользователя с данными <em>Модели</em>, за которые отвечают <em>Прокси</em>.\n\nТем не менее, уровни <em>Вида</em> и <em>Контроллера</em> должны иметь возможность\nизменений, не влияющих на уровень <em>Модели данных</em>.\n\nНапример, административное приложение и связанное с ним\nпользовательское приложение могут иметь общие классы уровня <em>Модели</em>.\nЕсли отличаются только сценарии использования, то эти отличия можно\nреализовать за счет различных комбинаций <em>Представления</em> и <em>Контроллера</em>,\nработающих с одной и той же <em>Моделью</em>.","description":"Фреймворк PureMVC преследует очень узкую цель. Она в том, чтобы помочь вам разделить интересы кода вашего приложения на три отдельных уровня: Модель (Model), Представление (View) и Контроллер (Controller). \n\nДля создания масштабируемых и легко..."}}}