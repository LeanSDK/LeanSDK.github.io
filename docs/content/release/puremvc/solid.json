{"data":{"type":"contents","id":"puremvc/solid","attributes":{"content":"![SOLID](/images/puremvc/gestalt/solid.jpg)\n\nSOLID является акронимом от следующих пяти принципов:\n\n![SOLID](/images/puremvc/solid/first.png)\n\n## Принцип единственной ответственности\n\n> Класс должен иметь только одну ответственность. (более точная формулировка, звучит так: \"Класс должен иметь одну и только одну причину для изменений\")\n\nСамый эффективный способ \"сломать\" приложение — создание божественного класса.\n\n> Божественный класс — класс, знающий и делающий слишком много. Этот подход является хорошим примером анти-паттерна\n\nБожественный класс отслеживает большое количество информации и имеет несколько ответственностей. Одна правка кода, с большой вероятностью, может повлиять на другие части класса и опосредованно повлиять на остальные классы, которые используют его. Это приводит к проблемам развития и обслуживания кода, поскольку никто не осмеливается вносить изменения, кроме добавления нового функционала.\n\nСледующий пример представляет класс TypeScript описывающий персону. Этот класс не должен включать валидацию email, так как она не относится к поведению персоны.\n\n\n```javascript\nclass Person {\n    public name : string;\n    public surname : string;\n    public email : string;\n    constructor(name : string, surname : string, email : string){\n        this.surname = surname;\n        this.name = name;\n        if(this.validateEmail(email)) {\n          this.email = email;\n        }\n        else {\n            throw new Error(\"Invalid email!\");\n        }\n    }\n    validateEmail(email : string) {\n        var re = /^([\\w-]+(?:\\.[\\w-]+)*)@((?:[\\w-]+\\.)*\\w[\\w-]{0,66})\\.([a-z]{2,6}(?:\\.[a-z]{2})?)$/i;\n        return re.test(email);\n    }\n    greet() {\n        alert(\"Hi!\");\n    }\n}\n```\n\nМы можем улучшить этот класс путем вынесения ответственности за валидацию email в новый класс Email:\n\n```javascript\nclass Email {\n    public email : string;\n    constructor(email : string){\n        if(this.validateEmail(email)) {\n          this.email = email;\n        }\n        else {\n            throw new Error(\"Invalid email!\");\n        }        \n    }\n    validateEmail(email : string) {\n        var re = /^([\\w-]+(?:\\.[\\w-]+)*)@((?:[\\w-]+\\.)*\\w[\\w-]{0,66})\\.([a-z]{2,6}(?:\\.[a-z]{2})?)$/i;\n        return re.test(email);\n    }\n}\n\nclass Person {\n    public name : string;\n    public surname : string;\n    public email : Email;\n    constructor(name : string, surname : string, email : Email){\n        this.email = email;\n        this.name = name;\n        this.surname = surname;\n    }\n    greet() {\n        alert(\"Hi!\");\n    }\n}\n```\n\nРеализация классов с единственной ответственностью, по умолчанию, упрощает его понимание, а также расширение/улучшение.\n\n## Принцип открытости/закрытости\n\n> Программные сущности должны быть открыты для расширения и закрыты для модификации.\n\nСледующий пример кода является примером кода, написанного без соблюдения принципа открытости/закрытости:\n\n```javascript\nclass Rectangle {\n    public width: number;\n    public height: number;\n}\n\nclass Circle {\n    public radius: number;\n}\n\nfunction getArea(shapes: (Rectangle|Circle)[]) {\n    return shapes.reduce(\n        (previous, current) => {\n            if (current instanceof Rectangle) {\n                return current.width * current.height;\n            } else if (current instanceof Circle) {\n                return current.radius * current.radius * Math.PI;\n            } else {\n                throw new Error(\"Unknown shape!\")\n            }\n        },\n        0\n    );\n}\n```\n\nДанный код позволяет нам вычислить площадь двух фигур (прямоугольника и круга). Если мы попытаемся добавить новую фигуру, мы будем расширять программу. Конечно, мы можем добавить поддержку новой фигуры (наше приложение открыто для расширения), проблема в том, что нам понадобится изменять функцию getArea, что говорит о том, что наше приложение также открыто и для модификации.\n\nДля решения данной проблемы, мы можем использовать преимущества полиморфизма в ООП, например так:\n\n```javascript\ninterface Shape {\n    area(): number;\n}\n\nclass Rectangle implements Shape {\n\n    public width: number;\n    public height: number;\n\n    public area() {\n        return this.width * this.height;\n    }\n}\n\nclass Circle implements Shape {\n\n    public radius: number;\n\n    public area() {\n        return this.radius * this.radius * Math.PI;\n    }\n}\n\nfunction getArea(shapes: Shape[]) {\n    return shapes.reduce(\n        (previous, current) => previous + current.area(),\n        0\n    );\n}\n```\n\nДанное решение позволяет нам добавить поддержку новой фигуры (открыто для расширения) без необходимости изменения существующего кода (закрыто для модификации).\n\n## Принцип подстановки Барбары Лисков\n\n> Объекты в программе должны быть заменяемыми на экземпляры их подтипов без изменения правильности выполнения программы.\n\nДанный принцип, также, призывает нас использовать полиморфизм. В предыдущем примере кода:\n\n```javascript\nfunction getArea(shapes: Shape[]) {\n    return shapes.reduce(\n        (previous, current) => previous + current.area(),\n        0\n    );\n}\n```\n\nМы использовали интерфейс <em>Shape</em> для уверенности в том, что наша программа открыта к расширению и закрыта к модификации. Принцип подстановки Барбары Лисков говорит нам, что мы должны иметь возможность передать в функцию getArea экземпляр любого класса, реализующего интерфейс Shape без влияния на работоспособность программы. В языках со статической типизацией, таких как TypeScript, компилятор проверяет корректность имплементации подтипов (например, если в имплементация интерфейса Shape будет отсутствовать метод area, возникнет ошибка компиляции. Это означает, что мы не должны делать много ручной работы для того, чтобы быть уверенными в соответствии кода принципу подстановки Барбары Лисков.\n\n## Принцип разделения интерфейса\n\n> Много интерфейсов, специально предназначенных для клиентов, лучше, чем один интерфейс общего назначения.\n\nПринцип разделения интерфейсов помогает нам избегать нарушения принципа единственной ответственности и принципа разделения ответственности.\nПредставим, что вы имеете две доменных сущности: <em>Rectangle</em> и <em>Circle</em>. Вы используете эти сущности в доменных сервисах для вычисления их площади и этот подход работает отлично, но только до тех пор, пока не появляется необходимость сериализовать их в одном из инфраструктурных уровней. Мы можем добавить дополнительный метод в интерфейс <em>Shape</em>:\n\n```javascript\ninterface Shape {\n    area(): number;\n    serialize(): string;\n}\n\nclass Rectangle implements Shape {\n\n    public width: number;\n    public height: number;\n\n    public area() {\n        return this.width * this.height;\n    }\n\n    public serialize() {\n        return JSON.stringify(this);\n    }\n}\n\nclass Circle implements  Shape {\n\n    public radius: number;\n\n    public area() {\n        return this.radius * this.radius * Math.PI;\n    }\n\n    public serialize() {\n        return JSON.stringify(this);\n    }\n\n}\n```\n\nНаш доменный слой нуждается в методе вычисления площади, но ему нет необходимости ничего знать про сериализацию:\n\n```javascript\nfunction getArea(shapes: Shape[]) {\n    return shapes.reduce(\n        (previous, current) => previous + current.area(),\n        0\n    );\n}\n```\n\nИ, напротив, наш инфраструктурный слой нуждается в методе сериализации, но ничего не знает про вычисление площади:\n\n```javascript\n// ...\nreturn rectangle.serialize();\n```\n\nПроблема в том, что добавление метода `serialize` в интерфейс <em>Shape</em> нарушает принципы разделения ответственности и единственной ответственности. Фигура является бизнес-концепцией, а его сериализация — инфраструктурной концепцией. Мы не должны смешивать эти концепции в одном интерфейсе.\n\nПринцип разделения интерфейсов говорит нам, что много клиенто-ориентированных интерфейсов лучше, чем один интерфейс общего назначения, таким образом, мы должны разделить наши интерфейсы:\n\n```javascript\ninterface RectangleInterface {\n    width: number;\n    height: number;\n}\n\ninterface CircleInterface {\n    radius: number;\n}\n\ninterface Shape {\n    area(): number;\n}\n\ninterface Serializable {\n    serialize(): string;\n}\n```\n\nПри помощи новых интерфейсов, мы полностью изолируем доменный слой от инфраструктурных концепций.\n\n```javascript\nclass Rectangle implements RectangleInterface, Shape {\n\n    public width: number;\n    public height: number;\n\n    public area() {\n        return this.width * this.height;\n    }\n}\n\nclass Circle implements CircleInterface, Shape {\n\n    public radius: number;\n\n    public area() {\n        return this.radius * this.radius * Math.PI;\n    }\n}\n\nfunction getArea(shapes: Shape[]) {\n    return shapes.reduce(\n        (previous, current) => previous + current.area(),\n        0\n    );\n}\n```\n\nТеперь в инфраструктурном слое мы можем использовать новый набор сущностей, имеющих функционал сериализации.\n\n```javascript\nclass RectangleDTO implements RectangleInterface, Serializable {\n    public width: number;\n    public height: number;\n\n    public serialize() {\n        return JSON.stringify(this);\n    }\n}\n\nclass CircleDTO implements CircleInterface, Serializable {\n    public radius: number;\n\n    public serialize() {\n        return JSON.stringify(this);\n    }\n}\n```\n\nИспользование нескольких интерфейсов вместо одного интерфейса общего назначения, позволяет избежать нарушения принципов Разделения ответственности (бизнес слой ничего не знает про сериализацию) и Единой ответственности (мы не имеем божественного класса, который знает и о вычислении площади фигур и об их сериализации).\n\nМы можем спорить о том, что <em>RectangleDTO</em> и <em>Rectangle</em> почти идентичны и был нарушен принцип Не повторяйся (DRY). Мы думаем, что это другой случай. Потому что, эти классы выглядят похожими, но являются выражением разных концепций. Далеко не всегда, похожий код является дублированием.\n\nДаже в случае нарушения принципа DRY, мы будем выбирать между нарушением DRY или SOLID. Мы считаем, что принцип DRY менее важен, нежели принципы SOLID в таком случае.\n\n## Принцип инверсии зависимостей\n\n> Зависимость на Абстракциях. Нет зависимости на что-то конкретное.\n\nПринцип инверсии зависимостей велит нам всегда стараться использовать в качестве зависимостей интерфейсы, а не конкретные их реализации. Важно понимать, что Инверсия зависимостей и Инъекция зависимостей являются разными понятиями.\n\nК сожалению, принцип инверсии зависимостей представлен в аббревиатуре SOLID буквой D. И всегда к объяснению этого принципа переходят в последнюю очередь, несмотря на то, что он является самым важным в SOLID. Без применения этого принципа, большинство других принципов SOLID применять невозможно. Если мы оглянемся назад и вспомним все принципы, которые мы затронули выше, мы придем к выводу, что использование интерфейсов является ключевым элементом в каждом принципе:\n\n* Зависимость на интерфейсы, которая следует из принципа разделения ответственности, позволяет нам изолировать одни уровни приложения от деталей реализации других и помогает избежать нарушения принципа единственной ответственности.\n* Использование интерфейсов позволяет нам заменять одну реализацию другой (принцип подстановки Барбары Лисков).\n* С использованием интерфейсов мы можем создавать приложения, открытые к расширению, но закрытые к модификации (принцип открытости/закрытости).\n\nРеализация принципов SOLID в языках программирования. которые не поддерживают интерфейсы или в программных парадигмах, не поддерживающих полиморфизм, является очень неестественным. Например, в JavaScript ES5 или даже ES6, реализация SOLID может быть крайне неестественной. Тем не менее, в TypeScript или Flow это может быть реализовано вполне естественно.","description":"SOLID является акронимом от следующих пяти принципов: \n\n Принцип единственной ответственности  \n\nКласс должен иметь только одну ответственность. (более точная формулировка, звучит так: \"Класс должен иметь одну и только одну причину для изменений\")  \n\nСамый..."}}}