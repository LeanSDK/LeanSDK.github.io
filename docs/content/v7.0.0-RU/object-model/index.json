{"data":{"type":"contents","id":"object-model/index","attributes":{"content":"С этой главы начинается описание внутреннего устройства фреймворка LeanES и\nпримеров его использования для построения приложений.\n\nБыл пройден долгий путь и не одна реализация концепций, положенных в основу фреймворка LeanES.\nNote: когда появится время и душевные силы, можно вернуться к этой главе и\nдобавить ретроспективу этапов разработки, однако на данный момент сфокусируемся\nна текущих реалиях.\n\nПредыдушие реализации испытали на себе влияние многих других технологий, языков\nпрограммирования и фреймворков, по сути фреймворк LeanES является воплощением \"в камне\"\nнакопленного за годы работы опыта, поэтому старался впитывать в себя все смое лучшее.\n\nТак сложилось что путь становления начинается с языка программирования Ruby и фреймворка\nRuby on Rails - это прекрасный ЯП, содержащий в себе огромное количество полезных и\nудобных концепций, фич, реализаций, подходов, библиотек.\nИ так как спустя несколько лет, после того как мы его уже перестали использовать\nв коммерческой разработке и решили начать сохранять накопленный опыт в виде\nреиспользуемого программного кода, для описания базовых сущностей - Классов\nмы обратились к базовым концепциям Ruby чтобы воплотить некоторые удобные вещи на CoffeeScript.\n\nДа, именно CoffeeScript. На тот момент только недавно выпустили стандарт ES5,\nмыслей о ES6 даже в воздухе не витало, JavaScript пестрил \"проблемными местами\",\nа CoffeeScript был наиболее технологичным решением, для написания серьезных программ.\n\nПоэтому многие семантические и синтаксические концепции из Ruby были преемлимо\nреализованы средставми языка CoffeeScript:\n\n![coffee example](/images/object-model/coffee-example.png)\n\n`RC::CoreObject` - это базовый класс, в котором собрана основная низкоуровневая\nлогика объявления атрибутов и методов инстанса класса и самого класса (статических),\nа так же логика, позволяющая работать механизмам примесей и интерфейсов.\n\nКлассы разрабатываемых модулей (приложений) должны наследоваться от класса `RC::Module`,\nпо сути он объявляет неймспейс в рамках которого можно обратиться к любому объявленному\nклассу из любого другого (центральная точка, регистр классов модуля).\n\nКласс `RC::Mixin` нужен для того, чтобы от него можно было унаследовать классы \"примесей\",\nв которых может объявляться общий код, который может быть подмешан в несколько\nдругих классов. Концепция примесей взята из языка программирования Ruby и\nрешает проблему \"Множественного наследования\" в тех языках программирования\nгде это запрещено. На самом деле эта идея является более продвинутой, лаконичной,\nпростой, детерминированной и лишена язъянов присущих подходу с \"Множественным наследованием\".\n\nКласс `RC::Interface` нужен для того, чтобы от него можно было унаследовать классы \"интерфейсов\".\nДанная идея не присуща классам в языках CoffeeScript или Ruby, а превалирует в\nстроготипизированных языках (например TypeScript, ActionScript, Dart, C++, Haxe, JAVA, PHP, Scala),\nв частных случаях например в C++ и Ruby реализуется через абстрактные классы с\nвиртуальными методами (виртуальным метод - метод инстанса класса, который объявлен\nв классе с некоторым именем и возможно с типами входных и выходных аргументов,\nно в нем отсутствует тело-реализация. Класс который содержит хотябы один виртуальный\nметод инстанса автоматически считается виртуальным. От виртуальных классов\nнельзя инстанцировать объекты, но можно унаследовать дочерний класс в котором\nбудет объявлена реализация виртуального метода, после чего от него можно инстанцировать объекты).\nОднако паттерн \"Интерфейс\" является одним из самых базовых паттернов проектирования\nПО (мета-паттерн), т.к. позволяет дать описание класса в общем (мета) виде без\nконкретной реализации и является самым мощным инструментом при описании нескольких\nклассов со схожим функционалом (поведением), реализуя таким образом один из базовых\nпринципов ООП - \"Полиморфизм\".\n(этот принцип позволяет делать классы, или целые модули, взаимозаменяемыми,\nчто повышает компонуемость приложения - огромные приложения можно писать из небольших\nчастей-компонентов, главное условие которых - они должны удовлетворять заявленному интерфейсу)\n\nКласс `RC::Class` так же является базовым и нужен для конструирования классов \"на лету\",\nесли это необходимо. Так же он нужен чтобы близко соответствовать объектной модели в ЯП Ruby -\nт.е. все классы в приложении и в т.ч. базовые являются инстансами класса RC::Class.\nПоэтому он может быть использовать при объявлении типов, если аргумент функции\nили проперти в качестве value будут содержать не объект (или примитив), а некоторый класс.\n\nКласс `RC::MetaObject` - это служебный класс, от него не требудется наследоваться, единственная его задача - это сохранение всей мета- информаци класса в виде связанных между собой \"словарей\". Когда имеет место быть \"Наследование\", инстанс класса `RC::MetaObject` в классе-наследнике получает ссылку на инстанс класса `RC::MetaObject` в классе-родителе. Когда необходимо получить любую мета- информацию, происходит поиск этой информации по всей цепочке связанных мета-объектов в цепочке наследования конкретного класса.\n\n## Базовый класс CoreObject\n\nТак как вся магия скрыта именно в этом классе, а принципы внутренней организации не существенны, покажем простой пример унаследования целевого класса от CoreObject, а так же попутно покажем как использовать \"примеси\" и \"интерфейсы\"\n\nНо сперва надо отметить какие фичи реализованы в CoreObject:\n\n* Объявление публичных, приватных и защищенных проперти и методов инстанса класса\n* Объявление статических проперти и методов класса\n* Объявление виртуальных проперти и методов\n* Обеспечение статической типизации как для проперти и методов, так и для входящих и выходящих аргументов методов. (проверка типов)\n* Наследование защищенных проперти и методов\n* Подмешивание примесей к классам\n* Безопасный вызов \"super\" - реализации метода из родительского класса\n* Использование указателей для приватных и защищенных проперти и методов (обращение к ним только через указатели доступные только в области видимости текущего класса)\n* Непереопределяемость проперти и методов извне класса (\"защита от дурака\")\n* Расширяемость класса в будущем полезными методами из класса Object в ЯП Ruby\n\nПример объявления интерфейса\n\n![coffee interface](/images/object-model/coffee-interface.png)\n\nЗдесь мы видим, что класс интерфейса надо унаследовать от `RC::Interface`, после чего вызвать специальный метод, для наследования защищенных проперти и методов `@inheritProtected()` \n\nТак же надо не забыть прокинуть ссылку на модуль внутырь класса `@Module: App`\n\nЗатем объявляем нужные методы или проперти. В интерфейсе можно объявлять только публичные виртуальные методы и проперти, однако могут быть объявлены не только методы инстанса, но и статические методы самого класса.\n\nСледует обратить внимание что первый аргумент это объект где `key` - имя объявляемого проперти/метода, а `value` - это тип. (отсылка к строгой типизации) \n\nПри объявлении методов, тип всегда `Function`, а во втором аргументе обязательно должны быть объявлены ключи `args` и `return`. В `args` всегда массив типов аргументов, в `return` - всегда одно значение типа выходного аргумента (т.к. в js и в coffeescript функция всегда возвращает одно значение)\n\nКак и любой класс унаследованный от CoreObject в конце после объявления он должен быть проинициализирован вызовом метода `initialize()`\n\nПример объявления примеси\n\n![coffee mixin](/images/object-model/coffee-mixin.png)\n\nЗдесь мы видим схожее с интерфейсом объявление, однако миксины могут содержать только <b>НЕ</b> виртуальные объявления методов и пропертей (для виртуальных существуют интерфейсы), а так же объявления в них могут быть только публичные и защищенные. Если объявляемый метод не объявлен в подключенном к миксину интерфейсу, или если миксин не имплементирует интерфейс в котором есть объявление этого метода, то при объявлении в нем обязательно наличие ключей `args` и `return`\n\nПример целевого класса\n\n![coffee example](/images/object-model/coffee-example.png)\n\nДериктива `@implements APP::TestInterface` сообщает классу, что он имплементирует Некоторый интерфейс.\n\nДериктива `@include App::TestMixin` подмешивает в класс Некоторую примесь.\n\n### API класса CoreObject\n\nИсходя из описанного выше можно сделать вывод - <em>CoreObject</em> как минимум\nреализует весь необходимый функционал, так что после объявления классов в коде\nприкладного приложения, все будет работать \"из-коробки\" (достаточно использовать\nвсе эти `@inheritProtected`, `@Module`, `@public`, `@static`, `@protected`, `@initialize`\nв прикладном коде, а <em>CoreObject</em> сделает всю остальную работу за сценой).\n\nОднако надо отметить какими еще методами из <em>CoreObject</em> программист может\nвоспользоваться в коде своего приложения:\n\n* `@super()` - внутри методов инстанса и внутри статических методов\n* `@wrap()` - статический и метод инстанса - чтобы обернуть любую функцию, так что она будет выполняться с текущим контекстом\n* `@inheritProtected()` - статический метод чтобы корректно закончить операцию наследования в т.ч. приватных и защищенных методов и свойств\n* `@new()` - статический метод эквивалентный оператору new, т.е. MyClass.new() === new MyClass()\n* `@include()` - статический метод для подмешивания примесей\n* `@implements()` - статический метод, чтобы указать какой нитерфейс имплементирует класс\n* `@freeze()` - статический метод чтобы указать классу, что он \"заморожен\", т.е. больше не может быть изменен как снаружи так и изнутри\n* `@isSupersetOf()` - статический метод, возвращает true если текущий класс имеет совместимый интерфейс (наследник в \"широком смысле\")\n* `@subtypeOf()` - статический метод, возвращает true если подтип некоторого более абстрактного типа\n* `@initialize()` - статический метод, вызывается последним в теле объявления <b>класса</b> чтобы указать классу, что его объявление закончено.\n* `@initializeMixin()` - статический метод, вызывается последним в теле объявления <b>миксина</b> чтобы указать, что его объявление закончено.\n* `@async()` - статический метод чтобы указать что объявляемая функция асинхронная\n* `@static()` - статический метод чтобы указать что объявляемая функция статическая\n* `@public()` - статический метод чтобы определить публичный метод класса (как статический так и инстанса)\n* `@protected()` - статический метод чтобы определить защищенный метод класса (как статический так и инстанса)\n* `@private()` - статический метод чтобы определить приватный метод класса (как статический так и инстанса)\n* `@const()` - статический метод чтобы определить в классе константу\n* `@module()` - статический метод, используется в теле класса, чтобы явно указать классу, что он находится в неймспейсе конкретного модуля.\n* `@moduleName()` - статический и метод инстанса - возвращает имя модуля\n* `@superclass()` - только статический метод класса, возвращает ссылку на родительский класс\n* `@class()` - статический и метод инстанса - возвращает ссылку на конструктор\n* `@restoreObject()` - чтобы восстановить инстанс данного класса из снапшота\n* `@replicateObject()` - чтобы на основе инстанса данного класса создать json-снапшот\n\n* `init()` - во всех унаследованных классах определение кода, который должен быть в конструкторе, необходимо определять в этом методе вместо `constructor`\n\n* `Module` - свойство класса и инстанса, возвращает ссылку на текущий модуль (неймспейс) в котором находится класс\n* `mixins` - статическое свойство возвращает массив подмешенных <b>миксинов</b> (на протяжение всей цепочки наследования)\n* `interfaces` - статическое свойство возвращает массив имплементированных <b>интерфейсов</b> (на протяжение всей цепочки наследования)\n* `classMethods` - статическое свойство возвращает массив <b>методов класса</b> (на протяжение всей цепочки наследования)\n* `instanceMethods` - статическое свойство возвращает массив <b>методов инстанса</b> (на протяжение всей цепочки наследования)\n* `classVirtualMethods` - статическое свойство возвращает массив <b>виртуальный методов класса</b> (на протяжение всей цепочки наследования)\n* `instanceVirtualMethods` - статическое свойство возвращает массив <b>виртуальный методов инстанса</b> (на протяжение всей цепочки наследования)\n* `classImplemenedMethods` - статическое свойство возвращает массив <b>имплементированных методов класса</b> (на протяжение всей цепочки наследования)\n* `instanceImplemenedMethods` - статическое свойство возвращает массив <b>имплементированных методов инстанса</b> (на протяжение всей цепочки наследования)\n* `constants` - статическое свойство возвращает массив определенных <b>констант</b> (на протяжение всей цепочки наследования)\n* `instanceVariables` - статическое свойство возвращает массив <b>свойств инстанса</b> (на протяжение всей цепочки наследования)\n* `classVariables` - статическое свойство возвращает массив <b>свойств класса</b> (на протяжение всей цепочки наследования)\n* `instanceVirtualVariables` - статическое свойство возвращает массив <b>виртуальных свойств инстанса</b> (на протяжение всей цепочки наследования)\n* `classVirtualVariables` - статическое свойство возвращает массив <b>виртуальных свойств класса</b> (на протяжение всей цепочки наследования)\n* `instanceImplemenedVariables` - статическое свойство возвращает массив <b>имплементированных свойств инстанса</b> (на протяжение всей цепочки наследования)\n* `classImplemenedVariables` - статическое свойство возвращает массив <b>имплементированных свойств класса</b> (на протяжение всей цепочки наследования)\n\n## Использование всех этих методов обеспечивает следующие основные функции:\n\n1. Полная интроспекция всей кодовой базы как \"снаружи\", так и в runtime.\n2. В runtime есть полный доступ ко всем объявленным методам и свойствам, типам аргументов и типам результатов методов\n3. Полная проверка типов в процессе выполнения в development окружении, проверки типов опускаются когда код приложения работает в production окружении. Реализованы следующие типы: `AnyT`, `ArrayT`, `AsyncFunctionT`, `BooleanT`, `BufferT`, `ClassT`, `DateT`, `DictT`, `EnumT`, `ErrorT`, `EventEmitterT`, `FunctionT`, `FunctorT`, `GeneratorFunctionT`, `GeneratorT`, `GenericT`, `IntegerT`, `InterfaceT`, `IntersectionT`, `LambdaT`, `ListT`, `MapT`, `MaybeT`, `MixinT`, `ModuleT`, `NilT`, `NumberT`, `ObjectT`, `PointerT`, `PromiseT`, `RegExpT`, `SetT`, `StreamT`, `StringT`, `StructT`, `SymbolT`, `TupleT`, `TypeT`, `UnionT`\n4. Полная проверка интерфейсов так же в development окружении\n5. Реализованы модификаторы доступа `private`, `public`, `protected`, что позволяет организовать полную инкапсуляцию методов и свойств.\n6. Кодовая база может быть организована в <em>Модули</em>, обращение к классам, константам и утилитам модуля происходит непосредственно через <em>Модуль</em>. Что так же решает проблему циклических зависимостей, позволяет организовать кеширование и ленивую подгрузку любых сущностей внутри модуля.\n7. Каждая единица (класс) <em>Модуля</em> экспортируется в виде шаблонной функции, принимающей в качестве аргумента <em>Модуль</em> - `by design`. Это обеспечивает <b>полную</b> компонуемость (подключаемость) любых единиц (классов) <em>Модуля</em> внутырь любых других модулей, иными словами - можно любой класс подключить в любой прикладной модуль, из любого подгруженного модуля.\n8. Базовый модуль библиотеки можно унаследовать в прикладной модуль приложения и иметь сразу все классы, находящиеся в составе базового модуля. так же в прикладной модуль приложения можно импортировать и подключать любыми модули расширений (плагинов), чтобы потом использовать их в программном коде.\n9. Помимо <em>Интерфейсов</em> в библиотеке реализованы специальные методы объявления <em>Типов</em> и <em>Генериков</em>, в том числе готовые специальные генерики: `Declare`, `Generic`, `Mixin` и генерики общего назначения: `AccordG`, `AsyncFuncG`, `FuncG`, `DictG`, `EnumG`, `InterfaceG`, `IntersectionG`, `IrreducibleG`, `ListG`, `MapG`, `MaybeG`, `NotSampleG`, `SampleG`, `SetG`, `StructG`, `SubsetG`, `SubtypeG`, `TupleG`, `UnionG`\n\n### Так же в базовом модуле имплементировано несколько концепций:\n\n1. Машина состояний - при разработке практически каждого приложения рано или поздно встает задача \"реализовать некоторый функционал через машину состояний\", это может быть \"управление соединениями к базе данных\" или \"оплата ордера\" или \"отправка письма\", это может быть что угодно. Но так как задание подразумевает переходы между некоторым оганиченным набором состояний и выполнение некоторой логики в момент перехода, то самым простым решением для такой задачи является именно Машина состояний. В библиотеке реализован <em>Миксин</em> для подключения Машины состояний с несколькими служемными классами. Подробнее это будет описано в отдельной главе.\n2. Очень часто инверсию управления, в некотором классе, удобнее всего реализовать через такую концепцию как `Hook`. Что требуется сделать программисту - всего лишь определить имена \"Хуков\" в данном классе, по сути будут созданы пустые методы, которые могут быть переопределены в унаследованном классе, либо могут быть инъектированны извне. Концепция \"Хуков\" предоставляет так же еще один инструмент, если при объявлении куков указать имена методов класса, которые должны быть вызваны при выполнении \"Хуков\". Таким образом мы всего лишь описываем декларативное представление последовательного выполения некоторых методов класса, композиция выполнения будет произведена за \"сценой\", а программисту достаточно лишь описать \"поштучно\" эти методы в коде класса. Подробнее это будет описано в отдельной главе.\n\n### Модуль \"расширенной логики\" содержит следующие несколько концепций:\n\n1. Имплементация спецификации фреймворка PureMVC\n2. Pipes для коммуникации между микро-ядрами мультитонами в составе PureMVC\n3. Концепция DelayedJob чтобы можно было назначать любой метод класса для обработки в фоновом потоке.\n4. В чстности DelayedJob реализован как частный случай концепции Resque. Можно определять такую абстракцию как Очередь и Обработчик очереди. Черед подмешивание миксина Очередь и Обработчик могут работать с конкретным бекэндом хранения очередей (база данных, менеджер очередей,...)\n5. Концепция Switch-медиатора в котором запускается http-сервер и он посылает приложению сигнал на обработку приходящего к серверу запроса\n6. Концепция прокси-Коллекции, как абстракция надо работой с таблицей в базе данных\n7. Конецпция Data-Mapper для работы с сериализацией записей из таблицы в базе данных\n8. Концепция Router класса содержащего декларативную карту роутов-урлов, которые может обрабатывать http-сервер\n9. Концепция Миграций, для проведения изменений с таблицами в базе данных и/или изменения данных в таблицах\n10. Концепция прокси-Конфигуркции - как центральной точки в приложении, хранящей все конфиги (получающей конфиги из файла на жестком диске, из переменных окружения или любым другим способом)\n11. Концепция прокси-Гейтвея хранящего все описания эндпоинтов http-сервера для предоставления json- метаданных в SwaggerUI в формате OpenAPI\n12. Концепция Query-объекта, он в декларативном виде содержит описание запроса в формате MongoQuery для того чтобы формат запроса не зависил от того, с какой базой данных идет работа в приложении\n13. Концепция Курсора как абстракция над итератором списка данных, возвращаемых из базы данных. Если возвращается массив за один раз, курсор предоставляет то же самое API для итерации по этому списку, но если возвращается поток данных, может быть создан полиморфный курсор с тем же интерфейсом для работы с потоком чанков - в программном коде приложения ничего менять не требуется.\n14. Концепция полиморфного Рендерера, по умолчанию все ответы от http-сервера проходят через дефолтный json- рендерер, который всего лишь делать `JSON.stringify(result)`, но могут быть объявлены любые другие рендереры и они будут использоваться в зависимости от accept type в реквесте к серверу. Иными словами, если это html запрос, то рендеринг будет делегирован html- рендереру, если xml запрос, то xml- рендереру, ...\n15. Концепция Ресурса реализует стандартный класс, который содержит обработчики запросов http-сервера. Именно к нему делегируется обработка запросов, которые получает Switch-медиатор.\n16. Концепция Application класса как входной точки для запуска всего приложения. Этот класс унаследован от PipeAwareModule класса в составе Pipes из PureMVC - таким образом Application класс является еще и Shell медиатором, через который происходит коммуникация через Pipes cо всеми другими мультитонами в составе приложения. Таким образом \"большое\" приложение может состоять из независимых микро- приложений, коммуницирующих только через Pipes.\n17. Реализовано большое количество миксинов для подмешивания специальной расширенной логики по необходимости.\n\n## Появление ES6 и последующих стандартов\n\nНичто не вечно под луной. К 2015 году в черновик ES6 стандарта перенесли очень большое количество удобных языковых конструкций из CoffeeScript, некоторые частично, некоторые не перенесены до сих пор. Однако это повлияло на экосистему JavaScript координальным образом и ускорило как внедрение новых стандартов, так и пополнение рядов девелоперов, которые стали переходить на JavaScript из других языков и диалектов.\nК сожалению на данный момент CoffeeScript скорее мертв, чем жив. Продолжается его использование в закрытых корпоративных экосистемах, но скорее как legacy, новые фичи давно уже не внедряются в этот язык программирования.\n\nПоэтому было принято решение адаптировать/переписать старую кодовую базу с CoffeeScript на современный JavaScript.\nСтатическую/статическую в рантайме типизацию было принято решение не переносить, чтобы не загромождать прикладной код обвязками в функциональном стиле, как это было в CoffeeScript варианте (там за счет более лаконичного синтаксиса это не вызывало никаких проблем).\nДля статической проверки типов был выбран Flow.js, так как не вызывает обременения и просто вырезается Babel'ом в момент компиляции оставляя чистый JavaScript. Через дополнительный плагин к Babel все Flow типы превращаются в проверки черезе `assert()` в runtime - что так же удобно как на CoffeeScript и не требуется изобретать велосипед.\n\nТак же к Babel'у был подключен плагин для использования в коде приложений декораторов, потому как они предоставляют прекрасный виразительный языковой инструмент, с помощью которого можно реализовать весь тот функционал, который был ранее реализован в CoffeeScript.\n\nТак же было принято решение объедитить Базовый модуль и Расширяющий модуль в одной библиотеке - фреймворке, тк. показала практика Базовый модуль (предоставляющий только Объектную модель) практически не используется отдельно и проще сконцентрировать свои силы на одной библиотеке-фреймворке и проще сопровождать.\n\nОднако Расширяющий модуль сильно перегружен заточенной под серверную разработку логикой, поэтому было решено произвести декомпозицию и вынести специализированный функционал в отдельные подключаемые модули - чтобы их можно было подключать по необходимости. Это положительно сказалось на архитектуре - были выявлены проблемные места с подключением плагинов и откровенные баги - и то и другое было исправлено. Отдельные модули так же стали легче и проще, как для понимания функционала так и для покрытия тестов и использования.\n\nБыло решено исправить ситуацию с использованием `this.facade.retrive...`, т.к. это вырождалось в использование фасада в качестве ServiceLocator, поэтому была проделана работа, по внедрению библиотеки inversifyJS в ядро фреймворка, чтобы инъектировать зависимости через геттер (или конструктор).\nТаким образом больше не требуется предоставлять сложный перегруженный фасад в тестах, а код классов с использованием инструкций для инъекции стал по-настоящему гибким и изолированным.\nТак же стоит отметить, что добавление inversifyJS было выполнено с сохранением обратной совместимости с API PureMVC, т.е. при написании кода в старом \"стиле\" все будет так же работать без ошибок. Это стало возможным за счет внедрения механизмов inversifyJS \"под капотом\". Для инъекции любых \"старых\" или \"новых\" классов, были добавлены специальные фабрики, они инъектируют нужные инстансы (а в некоторых случаях и классы) только в момент необходимого использования в runtime.\n\nК сожалению, на последних этапах реализации было обнаружено, что в Flow.js нет возможности объявить интерфейсы для проверки статических методов классов, т.е.\n\n* можно проверить итерфейсом инстанс класса\n* можно указать $Class в качестве типа аргумента\n\nНО нельзя:\n\n* сделать проверку интерфейсом самого класса (проверить статические методы)\n* срезы и \"простые\" структуры с публичными методами тоже не могут выполнить проверку класса\n\nС одной стороны понятно, что необходимость в проверке интерфейса и самих статических методов классов возникает в том случае, когда классы активно передаются как значения, однако Flow.js позиционирует классы как вспомогательный инструмент - для проверки инстансов (оъектов).\nС другой стороны программисту \"виднее\" как он хочет спроектировать классы и нужны ли ему статические методы, а если возникает потребность в передаче классов по значению (как объектов класса Class), то все таки у него должна быть возможность описать проверки, тем более что JavaScript явно позволяет передавать в качестве значений что-угодно, в т.ч. и классы.\n\nНа данный момент нет никаких сил и времени что либо переписывать, тем более настолько масштабно.\nОднако если появятся желающие внести свою лепту в общее дело создания и поддержки фреймворка - стратегически и меньше всего потребует ресурсов - адаптировать имеющуюся кодовую базу на TypeScript. В нынешнем состоянии она более чем на 99% должна быть совместима с TypeScript. Обратить внимание стоит на использование специальных директив Flow.js, начинающихся с `$`, т.к. в TypeScript для них будут скорее всего другие аналогии.\n\nНа данный момент каждый модуль покрыт типами и внутри себя самодостаточно типизирован. Сборка каждого модуля в development режиме так же сохраняет все проверки типов в runtime. А следовательно при разработке любого прикладного приложения при использовании development сборок модулей - все проверки аргументов выполняются и в runtime приложения.\nВсе модули покрыты тестами (или почти все), а следовательно все модули можно безопасно использовать в разработке приложений.","description":"С этой главы начинается описание внутреннего устройства фреймворка LeanES и примеров его использования для построения приложений. \n\nБыл пройден долгий путь и не одна реализация концепций, положенных в основу фреймворка LeanES. Note: когда появится время и..."}}}