{"data":{"type":"contents","id":"puremvc/proxies","attributes":{"content":"Вообще говоря, паттерн <em>Прокси</em> (<em>Proxy</em>, далее <em>Прокси</em>) используется для\nобеспечения хранения любого объекта в целях контроля доступа к нему. В\nприложениях, основанных на PureMVC, класс <em>Proxy</em> используется\nспециально для управления частями <em>Модели Данных</em> приложения.\n\n<em>Прокси</em> могут управлять доступом к созданным локально структурам\nданных произвольной сложности. Они называются <em>Объектами Данных</em>\n<em>Прокси</em> (<em>Proxy’s Data Object</em>).\n\nВ этом случае, идиома для взаимодействия с <em>Прокси</em> связана с синхронной\nустановкой (setting) и получением (getting) данных. <em>Объекты Данных</em> могут\nподвергаться полному или частичному обновлению свойств, или же может\nменяться ссылка на сам <em>Объект Данных</em>. Когда выполняются методы для\nобновления данных, <em>Прокси</em> может отправлять <em>Оповещение</em> в остальную\nчасть системы, что его данные изменились.\n\n<em>Прокси Удаленного Сервиса</em> (<em>Remote Proxy</em>, далее <em>Прокси Удаленного\nСервиса</em>) используется для инкапсуляции взаимодействия с удаленными\nсервисами, для сохранения или получения данных. <em>Прокси</em> может хранить\nобъект, который взаимодействует с удаленным сервисом, а также\nконтролировать доступ к данным, переданным и полученным от этого\nсервиса.\n\nТаким образом, можно просто устанавливать данные или же вызывать\nметоды <em>Прокси</em> и дожидаться асинхронного <em>Оповещения</em>, отправляемого\n<em>Прокси</em> когда данные от удаленного сервиса получены.\n\n## Обязанности конкретного Прокси\n<em>Конкретные Прокси</em> позволяют нам инкапсулировать фрагменты модели\nданных, независимо откуда они получены и их типа, а так же необходимы\nдля управления <em>Объектами Данных</em> и организации доступа приложения к\nним.\n\nРеализация класса <em>Прокси</em>, который входит в PureMVC, является простым\nконтейнером для <em>Объектов Данных</em>, и может быть зарегистрирована в\n<em>Модели</em>.\n\nЧтобы полностью использовать возможности в данной форме, мы, обычно,\nсоздаем подкласс класса <em>Proxy</em> и добавляем функциональность,\nхарактерную для конкретного <em>Прокси</em>.\n\nОбщие варианты использования <em>Прокси</em> включают в себя:\n\n* <em>Прокси Удаленного Сервиса</em> - данные, управляемые конкретным\n<em>Прокси</em>, находится на удаленном сервере, и могут быть доступны\nчерез удаленный сервис.\n* <em>Прокси</em> и <em>Делегат</em> (Proxy and Delegate) - доступ к объекту,\nобеспечивающему удаленный доступ, должен быть распределен\nмежду несколькими <em>Прокси</em>. Класс <em>Делегат</em> поддерживает объект\nудаленного доступа и контролирует доступ к нему, обеспечивая\nпередачу ответов тем, кто послал запрос.\n* <em>Защищенный Прокси</em> (Protection Proxy) - используется когда игроки\nсистемы должны иметь разные права доступа к <em>Объекту Данных</em>.\n* <em>Виртуальный Прокси</em> - создает <em>Объекты Данных</em> по запросу.\n* <em>Умный Прокси</em> - загружает объекты данных в память при первом\nдоступе, осуществляет ведение учета ссылок, позволяет блокировать\nобъект, чтобы другой объект не смог изменить его.\n\n## Неявное приведение типа объекта данных\nРеализация базового класса <em>Proxy</em>, которая поставляется с PureMVC\nпринимает имя <em>Прокси</em> и основной <em>Объект Данных</em> в качестве аргумента\nконструктора. Вы можете динамически устанавливать <em>Объект\nДанных</em> <em>Прокси</em> после того, как он создан, вызывая метод setData.\n\nКак и в случае с <em>Медиатором</em> и его <em>Компонентом Представления</em>, вы будете\nчасто приводить <em>Объект Данных</em> к фактическому типу, для того, чтобы\nполучить доступ к свойствам и методам, которые он предоставляет; это\nутомительная и однообразная практика, но следование идиомам позволяют\nоткрывать больше о реализации <em>Объекта Данных</em>, чем это может\nпотребоваться.\n\nКроме того, поскольку <em>Объект Данных</em> обычно имеет сложную структуру,\nчасто необходимо иметь под рукой ссылки на несколько частей структуры,\nв дополнении к приведенной к типу ссылки на всю структуру.\n\nВ языке JavaScript функции называемые геттерами (getters) и\nсеттерами (setter) оказываются очень полезными в решении приведения\nтипа и устранении проблем неуместного применения типов.\n\nПолезная практика - использовать в <em>конкретном Прокси</em> getter,\nкоторый возвращает <em>Объект Данных</em> фактического типа и имеет\nосмысленное название.\n\nДополнительно, вы можете указать несколько геттеров, возвращающих\nопределенные части <em>Объекта Данных</em>.\n\nНапример:\n\n```js\n@property get searchResultAC(): ArrayCollection {\n  return this.getData();\n}\n\n@method resultEntry(index: number): SearchResultVO {\n  return this.searchResultAC[index];\n}\n```\n\nВ каком-то Медиаторе вам пришлось бы делать так:\n\n```js\nconst data: ArrayCollection = searchProxy.getData();\nconst item: SearchResultVO = data[1];\n```\n\nОднако, используя практику, описанную выше, можно сделать так:\n\n```js\nconst item: SearchResultVO = searchProxy.resultEntry(1);\n```\n\n## Запрет на привязку к медиаторам\nУ <em>Прокси</em> не запрашивают список интересующих его <em>Оповещений</em> как у\n<em>Медиатора</em>, да он и не получает <em>Оповещений</em>, потому что он не должен\nзаботиться о состоянии <em>Вида</em>. Вместо этого <em>Прокси</em> предоставляет методы и\nсвойства, позволяющие другим участникам манипулировать им.\n\n<em>Конкретный Прокси</em> не должен извлекать и использовать <em>Медиаторы</em> для\nтого, чтобы информировать систему об изменении своего <em>Объекта Данных</em>.\n\nВместо этого <em>Прокси</em> должен отправлять <em>Оповещения</em>, которые получат\n<em>Команды</em> или <em>Медиаторы</em>. От <em>Прокси</em> не должно зависеть, как эти\n<em>Оповещения</em> повлияют на систему.\n\nВ связи с тем, что уровень <em>Модели Данных</em> не содержит каких-либо знаний\nо системе реализации, уровни <em>Представления</em> и <em>Контроллера</em> могут быть\nотрефакторены без вмешательства в уровень <em>Модели Данных</em>.\n\nОбратное не совсем верно. Очень трудно изменить уровень <em>Модели\nДанных</em>, не изменяя уровень <em>Представления</em> и, скорее всего, уровень\n<em>Контроллера</em>. В конце концов, эти уровни существуют только чтобы\nпозволить пользователю взаимодействовать с уровнем <em>Модели Данных</em>.\n\n## Инкапсуляция предметной области в прокси\nИзменения на уровне <em>Модели Данных</em> почти всегда приводит к некоторому\nрефакторингу уровней <em>Контроллера</em> и <em>Представления</em>.\n\nМы увеличили разделение между уровнем <em>Модели Данных</em> и общих\nинтересов уровней <em>Представления</em> и <em>Контроллера</em> путем максимального\nперемещения предметной области в <em>Прокси</em>.\n\n<em>Прокси</em> может использоваться не только для контроля доступа к данным, но\nи выполнять операции над данными, которые могут быть необходимы для\nподдержания некоторого их валидного состояния.\n\nНапример, расчет налога с продаж является функцией предметной области\nи поэтому она должна находится в <em>Прокси</em>, а не в <em>Медиаторе</em> или <em>Команде</em>.\n\nНесмотря на то, что эта функция может быть реализована в любом из этих\nмест, размещение её в <em>Прокси</em> не только логично, но и облегчает другие\nуровни и упрощает рефакторинг.\n\n<em>Медиатор</em> может получить <em>Прокси</em>; вызвать функцию вычисления налога с\nпродаж, и возможно, поместить результат в какую-либо форму. Но\nразмещение фактического расчета в <em>Медиаторе</em> реализует в нем, с точки\nзрения уровня, <em>Предметную Область</em>. Вычислений налога является\nправилом относящемся к <em>Предметной Области</em>. <em>Представлению</em> оно может\nбыть известно как свойство <em>Предметной Области</em>, доступное, если\nсоответствующий <em>Объект Данных</em> присутствует.\n\nПредставьте, что вы в настоящее время работаете над RIA приложением\nдля запуска в размерах рабочего стола персонального компьютера. Новая\nверсия должна запускаться на КПК с соответствующим разрешением с\nсокращением сценариев использования, но по-прежнему использовать\nполную <em>Модель Данных</em> существующего приложения.\n\nПри правильном разделении интересов, мы можем использовать уровень\n<em>Модели Данных</em> во всей ее полноте и просто подгонять новые уровни\n<em>Представления</em> и <em>Контролера</em> к нему.\n\nРазмещение фактического расчета налога с продаж в <em>Медиаторе</em> может\nпоказаться эффективным и простым в момент реализации; например, вы\nтолько что получили данные из формы, и вы хотите рассчитать налог с\nпродаж, и отправить его в <em>Модель</em> уже вычисленным.\n\nОднако в каждой версии своего приложения вам теперь придется\nдублировать ваши усилия или копировать код вычисления налога с продаж\nв новый, совершенно другой уровень <em>Представления</em>, хотя эта логика могла\nбы появляться автоматически, как часть вашей <em>Модели Данных</em>.\n\n## Взаимодействие с Прокси Удаленного Сервиса\n<em>Прокси Удаленного Сервиса</em> - это обычный <em>Прокси</em>, который получает свои\n<em>Объекты Данных</em> из удаленного местоположения. Это значит, что мы\nвзаимодействуем с ним в асинхронном режиме.\n\nКаким образом <em>Прокси</em> получает данные - зависят от платформы клиента,\nреализации удаленного взаимодействия, а также предпочтений\nразработчиков. Mы можем использовать XMLHttpRequest, WebSocket, fetch(), ... для осуществления\nзапросов из <em>Прокси</em>.\n\nВ зависимости от потребностей, <em>удаленный Прокси</em> может направлять\nзапросы динамически, в ответ на вызов сеттеров или методов; или же\nможет делать единственный запрос во время создания и обеспечивать\nдоступ к данным впоследствии.\n\nЕсть ряд оптимизаций, которые могут быть применены в <em>Прокси</em> для\nповышения эффективности взаимодействия с удаленной службой.\n\nПрокси может кешировать данные, и, таким образом, сократить количество\nзапросов в сеть, или же отсылать обновления только тех частей структуры\nданных, которые были изменены, уменьшая сетевой трафик.\n\nЕсли запрос динамически вызывается на <em>Прокси Удаленного Сервиса</em>\nдругим игроком в системе, <em>Прокси</em> необходимо отправить <em>Оповещение</em>,\nкогда будет получен ответ.\n\nЗаинтересованным в получении <em>Оповещения</em> может быть или не быть тот\nже игрок, что и инициировал запрос.\n\nНапример, для осуществления процесса поиска, происходящего на\nудаленном сервере и отображения результатов, возможна следующая\nпоследовательность действия:\n\n* <em>Представление</em> инициирует поиск вызовом события (Event).\n* Его <em>Медиатор</em> получает соответствующий <em>удаленный прокси</em> и\nустанавливает свойство \"критерии поиска\".\n* Свойство \"критерий поиска\" в <em>Прокси</em> - это на самом деле неявный\nсеттер, который сохраняет значение и инициирует поиск запросом\nчерез внутренний fetch().\n* Затем <em>Прокси</em> отправляет <em>Оповещение</em>, информирующее об успехе\nпоиска и содержащее ссылку на свой <em>Объект Данных</em> в качестве\nтела <em>Оповещения</em>.\n* Другой <em>Медиатор</em>, выразивший заинтересованность в этом\n<em>Оповещении</em>, и, соответственно, принимающий его, устанавливает\nтело <em>Оповещения</em> как dataProvider своего <em>Компонента Представления</em>.\n\nИли же рассмотрим LoginProxy, который содержит LoginVO (Value Object;\nпростой класс-контейнер данных).\n\nLoginProxy содержит методы для установления полномочий, входа и выхода\nпользователя, и получения метки авторизации, которая будет включена в\nпоследующие удаленные вызовы для опознания пользователя в данной\nконкретной схеме аутентификации.\n\nПодробные примеры будут в следующих разделах.","description":"Вообще говоря, паттерн Прокси (Proxy, далее Прокси) используется для обеспечения хранения любого объекта в целях контроля доступа к нему. В приложениях, основанных на PureMVC, класс Proxy используется специально для управления частями Модели Данных..."}}}