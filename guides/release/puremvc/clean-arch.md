![Clean Architecture](/images/puremvc/gestalt/clean_architecture.jpg)

<b>The Clean Architecture</b> описывает основные общие правила построения архитектуры приложения.
Как сделать разработку тестируемой, удобной, понятной, а части системы взаимозаменяемыми.

За последние несколько лет было предложено множество идей построения архитектуры.

Например:

* [Hexagonal Architecture](http://alistair.cockburn.us/Hexagonal+architecture)
(или Ports and Adapters) от Alistair Cockburn адаптированная Steve Freeman
и Nat Pryce в их замечательной книге Growing Object Oriented Software
* [Onion Architecture](http://jeffreypalermo.com/blog/the-onion-architecture-part-1/) от Jeffrey Palermo
* [Screaming Architecture](https://8thlight.com/blog/uncle-bob/2011/09/30/Screaming-Architecture.html) из блога Robert Martin
* [DCI](http://www.amazon.com/Lean-Architecture-Agile-Software-Development/dp/0470684208/) от James Coplien и Trygve Reenskaug.
* [BCE](http://www.amazon.com/Object-Oriented-Software-Engineering-Approach/dp/0201544350) от Ivar Jacobson из его книги Object Oriented Software Engineering: A Use-Case Driven Approach

Несмотря на то, что детали, предложенные в этих архитектурах сильно варьируются,
все же, они очень похожи.

Все они разбивают проблему на схожие задачи. Они все добиваются этого разделения
разложением кода на слои. Каждая имеет как минимум один слой для бизнес логики
и другой - для интерфейсов.

Каждая из этих архитектур создает систему, которая:

1. Независимость от фреймворка. Архитектура не должна зависеть от какого-либо
фреймворка или библиотеки, релиазующей какую-либо фичу. Такой подход позволяет
использовать фреймворки как инструмент, нежели, подгонять ваш код под возможности фреймворка.
2. Тестируемость. Бизнес-логика должна быть тестируема без UI, баз данных,
веб-сервисов и прочих сторонник элементов.
3. Независимость от UI. Должна быть возможность легко изменить UI без затрагивания
других частей системы. Веб интерфейс может быть заменен на консольный без изменения бизнес-логики.
4. Независимость от Базы Данных. Должна быть возможность заменить Oracle или
SQL Server на Mongo, BigTable, CouchDB или что-либо еще. Бизнес-логика не зависит от Базы Данных
5. Независимость от внешних сервисов. Бизнес-логика просто не знает о существовании чего-либо во внешнем мире.

На диаграме представлена попытка изобразить общую концепцию представленных архитектур.

## Правило зависимости (Dependency rule)
Каждый слой на диаграме представляет разный слой кода. В целом, чем глубже
вы двигаетесь внутрь диаграмы, тем на более высокий уровень абстракции попадаете.
Внешние слои это реализация, внутренние - правила.

Основное правило, благодаря которому эта архитектура работает - Правило Зависимости.
Правило звучит так: внешние слои знают о внутренних, но не наоборот. Н
ичего из внутреннего слоя не должно знать о существовании внешнего.
В частности, имена, объявленные во внешних слоях не должны даже упоминаться во
внутренних. Это касается функций, классов, переменных и любых других сущностей.

Точно также, форматы данных, используемые во внешних слоях не должны быть
использованы где-либо во внутренних слоях. Особенно, если эти данные
сгенерированы фреймворком, используемым во внешних слоях. Мы не хотим никаким
образом влиять на внутренние слои из внешних.

## Слои

### Entities
Entities содержат бизнес-логику используемую во всем приложении. Entities может
быть объектом с методами или может быть просто набором структур данных и функций.
Не имеет значения, в каком виде представлена Entity, пока она может быть
использована различными модулями проекта.

Если вы разрабатываете одно небольшое приложение, то Entities являются
бизнес-объектами этого приложения. Они содержат в себе основную высокоуровневую
логику. При каких-либо внешних изменениях, Entities - последнее, чего могут
коснуться эти изменения. Например, изменения навигации или настроек безопасности
никак не должны повлиять на них. Ни одно изменение модуля приложения не должно
затронуть Entities.

### Use Cases
Код этого уровня содержит бизнес-правила конкретного приложения. Он содержит и
реализовывает все возможные варианты использования системы. Use cases отвечают за
поток данных в/из Entities и используют Entities для выполнения необходимых действий.

Изменения этого слоя не должны влиять на Entities. Также, изменения внених слоев,
таких как, Базы Данных, никак не должны влиять на Use Cases.

Однако, код Use Cases будет изменен при изменении логики работы приложения. Если
изменится какой-либо случай использования приложения, эти изменения будут
реализованы в этом слое.

### Interface Adapters
Этот слой представляет из себя набор адаптеров, которые конвертируют данные, из
формата, который удобен для использования в Entities и Use Cases в формат, более
удобный для внешних сервисов, таких как Базы Данных или Web-сервисы. Например,
в этом слое должен содержаться полностью весь GUI MVC. Контроллеры, Презентеры,
Представления, все находится здесь. Модели, пожалуй, это всего лишь структуры
данных, которые передаются из Контролеров в Use Cases и обратно из Use Cases в
Представления и Презентеры.

По аналогии, в этом слое данные должны быть конвертированы из формата, удобного
для использования в Entities и Use Cases в форматы, удобные для хранения, например
в Базах Данных. Код изнутри этого слоя не должен что-либо знать о Базах Данных.
Если используется SQL база данных, то все SQL запросы должны быть обработаны именно
на уровне этого слоя.

Также, в этом слое должны находиться все другие возможные адаптеры, конвертирующие
данные в формат удобный для использования в любых других внешних сервисах и
наоборот в форматы, используемые в Entities и Use Cases.

### Frameworks and Drivers
Самый дальний, внешний слой, состоящий из фреймворков и различных инструментов,
таких как Базы Данных, Web-сервисы. В общем, вы не должны писать здесь много кода,
кроме связующего кода с внутренними слоями.

На этом слое реализованы все детали. Связь с Web-сервисами - это детали. Базы
Данных - это детали. Мы оставили все это снаружи, чтобы не причинять вреда внутренним слоям.

## И это все?
Нет. Эти слои - схематичны. Вероятно, вам понадобится что-либо, не вписывающие
в эти четыре слоя. Нет такого правила, которое говорит, что вы должны использовать
только эти четыре слоя. Однако, Правило Зависимостей (Dependency Rule) должно
выполняться всегда. Исходный код на любом слое должны ссылаться на внутренний.
При движение вовнутрь, уровень абстракции увеличивается. Внешний слой - низкоуровневая
реализация деталей. Чем дальше вы продвигаетесь вовнутрь, тем более абстрактным
становится код и более высокоуровневую логику реализовывает. Самый внутренний слой
отвечает за общую логику.

## Пересечение границ слоев
На диаграмме справа-снизу представлено, как можно пересечь границы слоя. Там показано,
как Контроллеры и Представления общаются с Use Cases. Обратите внимание на поток
управления. Он начинается в Контроллере, проходит через Use Case и заканчивается
в Презентере. Также обратите внимание на зависимости исходного кода. Каждый из них
указывает на Use Case.

Обычно мы решает это противоречие при помощи Принципа Инверсии Зависимостей.
В таких языках, как Java, мы должны настроить интерфейсы и наследования, так,
чтобы зависимости исходного кода были противоположны потоку управления в точках
пересечения границ слоев.

Допустим, Use Case должен обратиться к Презентеру. Это обращение не должно быть
реализовано напрямую, чтобы не нарушать Правило Зависимостей (Dependency Rule):
внутренние слои не должны знать о реализации внешних. В таком случае, Use Case
обратится к интерфейсу (изображено на диаграмме как Use Case Output Port) внутреннего
слоя, а Презентер из внешнего слоя должен его реализовать.

Подобная техника используется для пересечения остальных границ архитектуры.
Мы используем преумещества динамического полиморфизма, чтобы зависимости исходного
кода были противоположны потоку управления. Таким образом мы не нарушаем правило
зависимостей (Dependency Rule) вне зависимости от направления потока управления.

## Какие данные должны пересекать границы
Обычно, данные, пересекаемые границы, являются обычными структурами данных.
Вы можете пользоваться основными структурами или Data Transfer объектами. Или
данные могут быть аргументами вызова функций. Или вообще можно представлять данные
в виде hashmap или засунуть в объект. Важно, чтобы данные, пересекаемые границы,
были простыми и изолированными. Мы же не хотим читерить и передавать Entities или
строки из Базы Данных. Также передаваемые данные не должны иметь какие-либо
зависимости и нарушать правило зависимостей (Dependency Rule).

Например, множество фреймворков возвращает из Базы Данных данные в очень удобном
формате. Назовем это RowStructure. Однако нельзя передавать RowStructure через
границы слоев. Это нарушает правило зависимостей (Dependency Rule) потому что
таким образом мы можем дать внутреннему слою информацию о реализации и структуре
используемых данных внешнего.

В общем, при передаче данных через границу, они должны быть представлены в формате,
наиболее удобном для использования во внутреннем слое.

## В нашем случае
Следовать этим простым правилам не так сложно, однако это сохранит вас от головной
боли в будущем. Разделением кода на слои и следованием правилу зависимостей
(Dependency Rule) можно создать систему, которая будет действительно тестируемой
со всеми вытекающими из этого плюсами. Если какая-то внешняя часть системы устареет
(например, База Данных или фреймворк), заменить его будет достаточно легко без каких-либо проблем.

На первый взгляд, <em>Clean Architecture</em> – довольно простой набор рекомендаций
к построению приложений. Но и я, и многие мои коллеги, осознали эту архитектуру не сразу.
<b>Ниже мы попытаемся лучше понять Clean Architecture и избавиться от распространенных заблуждений</b>.

Сразу хочу оговориться, заблуждения – это дело личное. Каждый в праве заблуждаться.
И если это его устраивает, то я не хочу мешать. Но всегда хорошо услышать мнения других людей,
а зачастую люди не знают даже мнений тех, кто стоял у истоков.

### Истоки

В 2011 году [Robert C. Martin](https://en.wikipedia.org/wiki/Robert_C._Martin),
также известный как Uncle Bob, опубликовал статью [Screaming Architecture](https://8thlight.com/blog/uncle-bob/2011/09/30/Screaming-Architecture.html),
в которой говорится, что архитектура должна «кричать» о самом приложении, а не о том,
какие фреймворки в нем используются. Позже вышла [статья](https://8thlight.com/blog/uncle-bob/2011/11/22/Clean-Architecture.html),
в которой Uncle Bob даёт отпор высказывающимся против идей чистой архитектуры.
А в 2012 году он опубликовал статью «[The Clean Architecture](https://8thlight.com/blog/uncle-bob/2012/08/13/the-clean-architecture.html)»,
которая и является основным описанием этого подхода. Кроме этих статей я также
очень рекомендую посмотреть видео выступления Дяди Боба.


Оригинальная схема из статьи, которая первой всплывает в голове разработчика,
когда речь заходит о Clean Architecture представлена под заголовком страницы.

В Android-сообществе Clean стала быстро набирать популярность после статьи
[Architecting Android...The clean way?](https://fernandocejas.com/2014/09/03/architecting-android-the-clean-way/),
написанной Fernando Cejas. В этой статье Fernando приводит такую схему слоёв:

![android-the-clean-way](/images/puremvc/clean-arch/9ac65cf9ba3849db8532914040bd89b8.png)

То, что на этой схеме другие слои, а в domain слое лежат ещё какие-то Interactors
и Boundaries, сбивает с толку. Оригинальная картинка тоже не всем понятна.
В статьях многое неоднозначно или слегка абстрактно. А видео не все смотрят
(обычно из-за недостаточного знания английского). И вот, из-за недопонимания,
люди начинают что-то выдумывать, усложнять, заблуждаться...

## Давайте разбираться!

Clean Architecture объединила в себе идеи нескольких других архитектурных подходов,
которые сходятся в том, что архитектура должна:

* быть тестируемой;
* не зависеть от UI;
* не зависеть от БД, внешних фреймворков и библиотек.

Это достигается разделением на слои и следованием Dependency Rule (правилу зависимостей).

## Dependency Rule

<b>Dependency Rule говорит нам, что внутренние слои не должны зависеть от внешних</b>.
То есть наша бизнес-логика и логика приложения не должны зависеть от презентеров, UI,
баз данных и т.п. На оригинальной схеме это правило изображено стрелками, указывающими внутрь.

В статье сказано: имена сущностей (классов, функций, переменных, чего угодно),
объявленных во внешних слоях, не должны встречаться в коде внутренних слоев.

Это правило позволяет строить системы, которые будет проще поддерживать, потому
что изменения во внешних слоях не затронут внутренние слои.

## Слои

Uncle Bob выделяет 4 слоя:

* Entities. Бизнес-логика общая для многих приложений.
* Use Cases (Interactors). Логика приложения.
* Interface Adapters. Адаптеры между Use Cases и внешним миром. Сюда попадают
Presenter'ы из MVP, а также Gateways (более популярное название репозитории).
* Frameworks. Самый внешний слой, тут лежит все остальное: UI, база данных, http-клиент, и т.п.

Подробнее, что из себя представляют эти слои, мы рассмотрим по ходу. А пока остановимся на передаче данных между ними.

## Переходы

<b>Переходы между слоями осуществляются через Boundaries</b>, то есть через два
интерфейса: один для запроса и один для ответа. Их можно увидеть справа на
оригинальной схеме (Input/OutputPort). Они нужны, чтобы внутренний слой не
зависел от внешнего (следуя Dependency Rule), но при этом мог передать ему данные.

![Flow of control](/images/puremvc/clean-arch/afbef2e40b7b4f87939dcde0b1ab6bae.png)

Оба интерфейса относятся к внутреннему слою (обратите внимание на их цвет на картинке).

Смотрите, Controller вызывает метод у InputPort, его реализует UseCase, а затем
UseCase отдает ответ интерфейсу OutputPort, который реализует Presenter. То есть
данные пересекли границу между слоями, но при этом все зависимости указывают
внутрь на слой UseCase'ов.

<em>Чтобы зависимость была направлена в сторону обратную потоку данных</em>, применяется
[принцип инверсии зависимостей](https://en.wikipedia.org/wiki/Dependency_inversion_principle)
(буква D из аббревиатуры [SOLID](https://en.wikipedia.org/wiki/SOLID)). То есть, вместо
того чтобы UseCase напрямую зависел от Presenter'a (что нарушало бы Dependency Rule),
он зависит от интерфейса в своём слое, а Presenter должен этот интерфейс реализовать.

Точно та же схема работает и в других местах, например, при обращении UseCase к
Gateway/Repository. Чтобы не зависеть от репозитория,
выделяется интерфейс и кладется в слой UseCases.

Что же касается данных, которые пересекают границы, то это должны быть <b>простые структуры</b>.
Они могут передаваться как [DTO](https://en.wikipedia.org/wiki/Data_transfer_object)
или быть завернуты в HashMap, или просто быть аргументами при вызове метода.
Но они обязательно должны быть в форме более удобной для внутреннего слоя (лежать во внутреннем слое).

## Особенности мобильных приложений

Надо отметить, что <b>Clean Architecture была придумана с немного иным типом
приложений на уме</b>. Большие серверные приложения для крупного бизнеса, а не
мобильные клиент-серверные приложения средней сложности, которые не нуждаются
в дальнейшем развитии (конечно, бывают разные приложения, но согласитесь, в
большей массе они именно такие). Непонимание этого может привести к [overengineering'у](https://en.wikipedia.org/wiki/Overengineering).

На оригинальной схеме есть слово Controllers. Оно появилось на схеме из-за
frontend'a, в частности из Ruby On Rails. Там зачастую разделяют Controller,
который обрабатывает запрос и отдает результат, и Presenter, который выводит
этот результат на View. Многие не сразу догадываются,
но <em>в android-приложениях Controllers не нужны</em>.

Ещё в статье Uncle Bob говорит, что <em>слоёв</em> не обязательно <em>должно быть 4</em>.
Может быть любое количество, но Dependency Rule должен всегда применяться.

Глядя на схему из статьи Fernando Cejas, можно подумать, что автор воспользовался
как раз этой возможностью и уменьшил количество слоев до трёх. Но это не так.
Если разобраться, то в Domain Layer у него находятся как Interactors (это другое
название UseCase'ов), так и Entities.

Все мы благодарны Fernando за его статьи, которые дали хороший толчок развитию
Clean в Android-сообществе, но его схема также породила и заблуждение.

## Слои и линейность

Сравнивая оригинальную схему от Uncle Bob'a и cхему Fernando Cejas'a многие начинают
путаться. Линейная схема воспринимается проще, и люди начинают неверно понимать
оригинальную. А не понимая оригинальную, начинают неверно толковать и линейную.
Кто-то думает, что расположение надписей в кругах имеет сакральное значение,
или что надо использовать Controller, или пытаются соотнести названия слоёв на
двух схемах. <b>Смешно и грустно, но основные схемы стали основными источниками заблуждения</b>!

Постараемся это исправить. Для начала давайте <em>очистим основную схему</em>,
убрав из нее лишнее для нас. И переименуем Gateways в Repositories,
т.к. это более распространенное название этой сущности.

![cicles schema](/images/puremvc/clean-arch/42cf44b37d614d2785444057af7273e8.png)

Стало немного понятнее. Теперь мы сделаем вот что: <em>разрежем слои на части</em> и превратим
эту схему в блочную, где цвет будет по-прежнему обозначать принадлежность к слою.

![cicles-liner schema](/images/puremvc/clean-arch/fe8c82a32b1548b1a297187e24ae755a.png)

Как я уже сказал выше, цвета обозначают слои. А стрелка внизу обозначает Dependency Rule.

На получившейся схеме уже проще представить себе течение данных от UI к БД или серверу
и обратно. Но давайте сделаем еще один шаг к линейности, расположив слои <em>по категориям</em>:

![liner schema](/images/puremvc/clean-arch/9869dbe34b5649e28be40bff6bee3147.png)

Я намеренно не называю это разделение слоями, в отличие от Fernando Cejas. Потому что
мы и так делим слои. Я называю это категориями или частями. Можно назвать как угодно,
но повторно использовать слово «слои» не стоит.

А теперь давайте сравним то, что получилось, со схемой Fernando.

![two liner schemas](/images/puremvc/clean-arch/cbe3fdad2be24de3bd4dda6c66d56d76.png)

Надеюсь теперь вcё начало вставать на свои места. Выше я говорил, что, по моему мнению,
у Fernando всё же 4 слоя. Думаю теперь это тоже стало понятнее. В Domain части
у нас находятся и UseCases и Entities.


Такая схема воспринимается проще. Ведь обычно события и данные в наших приложениях
ходят от UI к backend'у или базе данных и обратно. Давайте изобразим этот процесс:

![both schema](/images/puremvc/clean-arch/53104c89d9cf44a59c95e351b7485574.png)

Красными стрелками показано <em>течение данных</em>.

Событие пользователя идет в Presenter, тот передает в Use Case. Use Case делает
запрос в Repository. Repository получает данные где-то, создает Entity, передает
его в UseCase. Так Use Case получает все нужные ему Entity. Затем, применив их и
свою логику, получает результат, который передает обратно в Presenter. А тот, в
свою очередь, отображает результат в UI.

На переходах между слоями (не категориями, а слоями, отмеченными разным цветом)
используются Boundaries, описанные ранее.

Теперь, когда мы <b>поняли, как соотносятся две схемы</b>, давайте рассмотрим
следующее заблуждение.

## Слои, а не сущности

Как понятно из заголовка, кто-то думает, что на схемах изображены сущности (особенно
это затрагивает UseCases и Entities). Но это не так.

<b>На схемах изображены слои, в них может находиться много сущностей</b>. В них будут
находиться интерфейсы для переходов между слоями (Boundaries), различные DTO, основные
классы слоя (Interactors для слоя UseCases, например).


Не будет лишним взглянуть на схему, собранную из частей, показанных в видео выступления
Uncle Bob'a. На ней изображены <em>классы и зависимости</em>:

![classes and dependencies](/images/puremvc/clean-arch/bb3430769e6c4e8fbca757a8bc071f2e.png)

Видите двойные линии? Это границы между слоями. Разделение между слоями Entities
и UseCases не показаны, так как в видео основной упор делался на том, что вся
логика (приложения и бизнеса) отгорожена от внешнего мира.

C Boundaries мы уже знакомы, интерфейс Gateway – это то же самое.
Request/ResponseModel – просто DTO для передачи данных между слоями. По правилу
зависимости они должны лежать во внутреннем слое, что мы и видим на картинке.

Про Controller мы тоже уже говорили, он нас не интересует. Его функцию у нас
выполняет Presenter.

А ViewModel на картинке – это не ViewModel из [MVVM](https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93viewmodel)
и не ViewModel из [Architecture Components](https://developer.android.com/topic/libraries/architecture/viewmodel.html).
Это просто DTO для передачи данных View, чтобы View была тупой и просто сетила
свои поля. Но это уже детали реализации и будет зависеть от выбора презентационного
паттерна и личных подходов.

В слое UseCases находятся не только Interactor'ы, но также и Boundaries для работы
с презентером, интерфейс для работы с репозиторием, DTO для запроса и ответа.
<em>Отсюда можно сделать вывод, что на оригинальной схеме отражены всё же слои</em>.

## Entities

<em>Entities по праву занимают первое место по непониманию.</em>

Мало того, что почти никто (включая меня до недавнего времени) не осознает,
что же это такое на самом деле, так их ещё и путают с DTO.

```
Однажды в чате возник спор, в котором оппонент доказывал, что Entity – это объекты,
полученные после парсинга JSON в data-слое, а DTO – объекты, которыми оперируют Interactor'ы...
```

Постараемся хорошо разобраться, чтобы таких заблуждений больше не было ни у кого.

Что же такое Entities?

Чаще всего они воспринимаются как POJO-классы, с которыми работают Interactor'ы.
Но это не так. По крайней мере не совсем.

В статье Uncle Bob говорит, что <b>Entities инкапсулируют логику бизнеса</b>,
<em>то есть всё то, что не зависит от конкретного приложения, а будет общим для многих</em>.
Но если у вас отдельное приложение и оно не заточено под какой-то существующий бизнес,
то Entities будут являться <em>бизнес-объектами приложения, содержащими самые
общие и высокоуровневые правила</em>.

Я думаю, что именно фраза: «Entities это бизнес объекты», – запутывает больше всего.
Кроме того, на приведенной выше схеме из видео Interactor получает Entity из Gateway.
Это также подкрепляет ощущение, что это просто POJO объекты.

Но в статье также говорится, что <em>Entity может быть объектом с методами или
набором структур и функций</em>. То есть упор делается на то, что важны методы, а не данные.

Это также подтверждается в [разъяснении](https://groups.google.com/forum/#!topic/clean-code-discussion/mvP_NR2MUPc)
от Uncle Bob'а, которое я нашел недавно:

Uncle Bob говорит, что для него Entities содержат бизнес-правила, независимые от приложения.
И они <em>не просто объекты с данными. Entities могут содержать ссылки на объекты
с данными, но основное их назначение в том, чтобы реализовать методы бизнес-логики,
которые могут использоваться в различных приложениях</em>.

А по-поводу того, что Gateways возвращают Entities на картинке, он поясняет следующее:

Реализация Gаteway получает данные из БД, и использует их, чтобы создать структуры
данных, которые будут переданы в Entities, которые Gateway вернет. Реализовано это может быть композицией

```java
class MyEntity { private MyDataStructure data;}
```

или наследованием

```java
class MyEntity extends MyDataStructure {...}
```

И в конце ответа фраза, которая меня очень порадовала:

```
And remember, we are all pirates by nature; and the rules I'm talking about here
are really more like guidelines...
(И запомните: мы все пираты по натуре, и правила, о которых я говорю тут,
на самом деле, скорее рекомендации...)
```

Действительно, не надо слишком буквально всё воспринимать, надо искать компромиссы и не делать лишнего. Все-таки любая архитектура призвана помогать, а не мешать.

Итак, <b>слой Entities содержит</b>:

* Entities – функции или объекты с методами, которые реализуют логику бизнеса, общую для многих приложений (а если бизнеса нет, то самую высокоуровневую логику приложения);
* DTO, необходимые для работы и перехода между слоями.

Кроме того, когда приложение отдельное, то надо стараться находить и выделять в Entities высокоуровневую логику из слоя UseCases, где зачастую она оседает по ошибке.
