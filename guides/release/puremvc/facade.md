Три <em>Базовых класса</em> мета-паттерна MVC представлены в PureMVC
классами <em>Модели</em>, <em>Представления</em> и <em>Контроллера</em>. Чтобы упростить процесс
разработки приложения, PureMVC задействует паттерн <em>Фасад</em>.

<em>Фасад</em> распределяет ваши запросы к <em>Модели</em>, <em>Представлению</em> и <em>Контроллеру</em>,
так что ваш код не нуждается в импорте этих классов и вам не нужно
работать с ними индивидуально. Класс <em>Фасада</em> автоматически создает
экземпляры базовых синглтонов MVC в своем конструкторе.

Обычно <em>Фасад</em> самого фреймворка становится над-классом вашего
приложения и используется для инициализации <em>Контроллера</em> с назначениями
<em>Команд</em>. Подготовка <em>Модели</em> и <em>Представления</em> затем дирижируется
<em>Командами</em>, выполняемыми <em>Контроллером</em>.

## Что такое Конкретный Фасад (Concrete Façade)?
Хотя <em>Базовые классы</em> являются завершенными, готовыми к использованию
реализациями, <em>Фасад</em> предоставляет реализацию, которую следует
рассматривать как <em>абстрактную</em> в том смысле, что вы никогда не создаете
его экземпляр непосредственным образом.

Вместо этого вы наследуете <em>Фасад</em> из фреймворка и / или переопределяете
некоторые его методы, чтобы сделать их полезными конкретно для вашего
приложения. (вы конкретизируете абстрактный
<em>Фасад</em> фреймворка в конкретный <em>Фасад</em> своего приложения).

Этот конкретный <em>Фасад</em> затем используется для доступа и оповещения
<em>Команд</em>, <em>Медиаторов</em> и <em>Прокси</em>, которые делают свою работу в системе. По
соглашению, он называется ‘ApplicationFacade’, но вы можете назвать его
как хотите.

В общем случае иерархия <em>Представления</em> вашего приложения
будет создаваться согласно принятого для вашей платформы
процесса. Как только построена иерархия <em>Представления</em> приложения,
стартует аппарат PureMVC и регионы <em>Модели</em> и <em>Вида</em>
готовятся к использованию.

Ваш <em>конкретный Фасад</em> также используется для облегчения процесса
старта приложения, в том смысле, что он освобождает основной код
приложения от необходимости глубокой осведомленности об аппарате
PureMVC, к которому это приложение будет подключено. Приложение
просто передает ссылку на себя в метод ‘startup’ синглтон-экземпляра
вашего конкретного <em>Фасада</em>.

## Создание Конкретного Фасада для вашего приложения
Вашему конкретному <em>Фасаду</em> не обязательно прилагать много усилий,
чтобы передать приложению силу PureMVC. Рассмотрим следующую
реализацию:

```js
export default (Module) => {
  const {
    STARTUP,
    Facade,
    initialize, partOf, meta, property, method, nameBy
  } = Module.NS;

  @initialize
  @partOf(Module)
  class ApplicationFacade extends Facade {
    @nameBy static  __filename = __filename;
    @meta static object = {};

    @property _isInitialized: boolean = false;

    @method startup(app) {
      if (!this._isInitialized) {
        this._isInitialized = true;
        this.send(STARTUP, app);
      }
    }

    @method initializeFacade(): void {
      super.initializeFacade(... arguments)
      this.rebind('ApplicationModule').toConstructor(this.Module);
      this.addCommand(STARTUP, 'StartupCommand');
    }
  }
}
```

Отметим несколько моментов в приведенном выше коде:

* Он расширяет класс Facade PureMVC, который в свою очередь
реализует интерфейс IFacade.
* Он не переопределяет конструктор. Если бы он это делал, то нужно
было бы вызвать конструктор суперкласса прежде, чем делать чтолибо.
* Он определяет константы для имен <em>Оповещений</em> (STARTUP). Поскольку это
игрок, используемый всеми другими участинками системы для
доступа и связи друг с другом, <em>конкретный Фасад</em> является
идеальным местом для определения констант, общих для всех
участников обмена оповещениями.
* Он инициализирует <em>Контроллер</em> <em>Командами</em>, которые будут
выполняться при отправке соответствующих <em>Оповещений</em>.
* Он предоставляет метод startup, который принимает один аргумент (в
данном случае) типа MyApp, который с помощью <em>Оповещения</em>
передается <em>Команде</em> StartupCommand (зарегистрированной на имя
оповещения STARTUP).

С этими простыми требованиями реализации ваш <em>конкретный Фасад</em>
унаследует ощутимую часть функциональности своего абстрактного класса-родителя.

## Инициализация вашего Конкретного Фасада
Конструктор <em>Фасада</em> PureMVC вызывает защищенные методы для
инициализации экземпляров <em>Модели</em>, <em>Представления</em> и <em>Контроллера</em> и
кэширует их ссылки на них.

Затем по композиции <em>Фасад</em> реализует и делает доступными возможности
<em>Модели</em>, <em>Представления</em> и <em>Контроллера</em>; агрегируя их функциональность и
защищая разработчика от прямого взаимодействия с <em>Базовыми
классами</em> фреймворка.

Итак, где и как <em>Фасад</em> внедряется в реальное положение вещей
конкретного приложения? Рассмотрим упрощенный пример из реального приложения:

```js
export default (Module) => {
  const {
    LIGHTWEIGHT,
    initialize, partOf, meta, property, method, nameBy,
    Utils: { uuid }
  } = Module.NS;

  @initialize
  @partOf(Module)
  class Application extends CoreObject {
    @nameBy static  __filename = __filename;
    @meta static object = {};

    @property isLightweight: boolean = false;
    @property name: string = null;

    @method start(): void {
      this.facade.startup(this);
    }

    @method async finish(): Promise<void> {
      await this.facade.remove();
    }

    constructor(name: string, ApplicationFacade: Class<*>, symbol: ?Symbol) {
      const isLightweight = symbol === LIGHTWEIGHT;
      if (isLightweight) {
        const appName = `${name}|>${uuid.v4()}`
        super(ApplicationFacade.getInstance(appName));
        this.name = appName;
      } else {
        super(ApplicationFacade.getInstance(name));
        this.name = name;
      }
      this.isLightweight = isLightweight;
    }
  }
}
```

Вот и все. Достаточно просто.

Создайте эту начальную иерархию вида, получите
экземпляр ApplicationFacade и вызовите его метод startup.

Ключевые моменты этого примера:

* Поскольку мы инициализируем переменную вызовом
статического метода ApplicationFacade.getInstance, то это
означает, что в момент создания Application
будет создан <em>Фасад</em>, а вместе с ним и <em>Модель</em>, <em>Представление</em> и
<em>Контроллер</em>, хотя ни <em>Медиаторы</em>, ни <em>Прокси</em> не будут пока
созданы.
* В отдельном методе start инстанса Application мы
вызываем метод startup, передавая ему ссылку на главное
приложение в качестве аргумента.

Заметьте, что обычные компоненты <em>Представления</em> не нуждаются в знании
того, как им нужно взаимодействовать с Фасадом, но объект верхнего
уровня Application является исключением для этого правила.

Верхнеуровневый объект Application строит
иерархию <em>Вида</em>, инициализирует <em>Фасад</em>, а затем запускает аппарат
PureMVC.
