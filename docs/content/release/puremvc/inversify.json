{"data":{"type":"contents","id":"puremvc/inversify","attributes":{"content":"![InversifyJS](/images/puremvc/gestalt/inversifyjs.jpg)\n\n## О InversifyJS\n\nПредставляем в этой главе адаптированный перевод\n[статьи](https://www.codeproject.com/Articles/1085306/Introducing-InversifyJS-A-powerful-lightweight-IoC)\nи этой [статьи](https://www.methodsandtools.com/tools/inversifyjs.php)\n\nInversifyJS is a powerful lightweight (4KB) pico inversion of control (IoC) container for TypeScript and JavaScript apps. A pico IoC container uses a class constructor to identify and inject its dependencies. InversifyJS also uses annotations to identify and inject its dependencies. InversifyJS has a friendly API and encourage the usage of the best OOP and IoC practices.\n\n## Motivation\n\nJavaScript applications are becoming larger and larger day after day. InversifyJS has been designed to allow JavaScript developers to write code that adheres to the SOLID principles.\n\nThe main goal of Inversion of control and Dependency Injection is to remove dependencies of an application. This makes the system more decoupled and maintainable.\n\n* What is Inversion of Control (IoC)\n\nIn traditional programming, the flow of the business logic is determined by objects that are statically assigned to one another. With inversion of control, the flow depends on the object graph that is instantiated by the assembler and is made possible by object interactions being defined through abstractions. The binding process is achieved through dependency injection, although some argue that the use of a service locator also provides inversion of control.\n\nInversion of control as a design guideline serves the following purposes:\n\nThere is a decoupling of the execution of a certain task from implementation. Every module can focus on what it is designed for. Modules make no assumptions about what other systems do but rely on their contracts. Replacing modules has no side effect on other modules.\n\n* What is Dependency Injection (DI)\n\nIoC is a design paradigm with the goal of giving more control to the targeted components of your application, the ones getting the work done. While Dependency injection is a pattern used to create instances of objects that other objects rely on without knowing at compile time which class will be used to provide that functionality. IoC relies on dependency injection because a mechanism is needed in order to activate the components providing the specific functionality.\n\nThe two concepts work together in this way to allow for much more flexible, reusable, and encapsulated code to be written. As such, they are important concepts in designing object-oriented solutions.\n\n* How to implement IoC\n\nIn object-oriented programming, there are several basic techniques to implement inversion of control. These are:\n\n* using a factory pattern\n* using a service locator pattern\n* using a dependency injection of any given below type:\n* a constructor injection\n* a setter injection\n* an interface injection\n\nWe're going to show you an example based on a node demo project which consists of a service class depending on two other classes, and the main file which is utilizing this service.\n\nNow that ECMAScript 2015 version of JavaScript supports classes and that TypeScript brings static types to JavaScript application, the SOLID principles have become more relevant than ever before in the development of JavaScript applications.\n\nAt the time there was some IoC containers available for JavaScript applications but none of them were able to provide a developer experience as rich as We were expecting so We decided to try to develop something that would suit my needs.\n\nThe first commit to the InversifyJS core library took place the 7th of Apr 2015 and the version 1.0.0 was released on npm 10 days later. The version 2.0.0 was released the 11th of Sep 2016, after a year of development. The most recent release (3.3.0 at the time in which this article was published) was published in March 2017. Since the first release the project has earned over 1000 stars on GitHub, over 30 contributors and almost 25K monthly downloads on npm.\n\n## Philosophy\n\nInversifyJS has been developed with 3 main goals:\n\n1. Allow JavaScript developers to write code that adheres to the SOLID principles.\n\n2. Facilitate and encourage the adherence to the best OOP and IoC practices.\n\n3. Add as little runtime overhead as possible.\n\n4. Provide a state of the art development experience.\n\n## Dependencies\n\nInversifyJS requires a modern JavaScript engine with support for:\n\n* [Reflect metadata](https://rbuckton.github.io/reflect-metadata/)\n* [Map](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Map)\n* [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise) (Only required if using [provider injection](https://github.com/inversify/InversifyJS/blob/master/wiki/provider_injection.md))\n* [Proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) (Only required if using [activation handlers](https://github.com/inversify/InversifyJS/blob/master/wiki/activation_handler.md))\n\nCheck out the [Environment support and polyfills](https://github.com/inversify/InversifyJS/blob/master/wiki/environment.md) page in the wiki and the [Basic example](https://github.com/inversify/inversify-basic-example) to learn more.\n\n## The Basics\n\nLet's take a look to the basic usage and APIs of InversifyJS with TypeScript:\n\n### Step 1: Declare your interfaces\n\nOur goal is to write code that adheres to the\n[dependency inversion principle](https://en.wikipedia.org/wiki/Dependency_inversion_principle).\nThis means that we should \"depend upon Abstractions and do not depend upon concretions\". Let's start by declaring some interfaces (abstractions).\n\nThe first we need to add reflect-metadata before all other our code\n```javascript\nimport \"reflect-metadata\";\n```\n\n```javascript\ninterface Warrior {\n    fight(): string;\n    sneak(): string;\n}\n\ninterface Weapon {\n    hit(): string;\n}\n\ninterface ThrowableWeapon {\n    throw();\n}\n```\n\nInversifyJS need to use the type as identifiers at runtime. We use symbols as identifiers but you can also use classes and or string literals.\n\n```js\nconst TYPES = {\n    Warrior: Symbol.for(\"Warrior\"),\n    Weapon: Symbol.for(\"Weapon\"),\n    ThrowableWeapon: Symbol.for(\"ThrowableWeapon\")\n};\nexport { TYPES };\n```\n\n> Note: It is recommended to use Symbols but InversifyJS also support the usage of Classes and string literals (please refer to the features section to learn more).\n\n### Step 2: Implement the interfaces and declare dependencies using the `@inject` decorator\n\nLet's continue by declaring some classes (concretions). The classes are implementations of the interfaces that we just declared. All the classes must be annotated with the `@injectable` decorator.\n\n```javascript\nimport { interfaces, injectable, inject, Container } from \"inversify\";\n\n@injectable()\nclass Katana implements Weapon {\n    public hit() {\n        return \"cut!\";\n    }\n}\n\n@injectable()\nclass Shuriken implements ThrowableWeapon {\n    public throw() {\n        return \"hit!\";\n    }\n}\n\n@injectable()\nclass Ninja implements Warrior {\n\n    private _katana: Weapon;\n    private _shuriken: ThrowableWeapon;\n\n    public constructor(\n      @inject(TYPES.Weapon) katana: Weapon,\n      @inject(TYPES.ThrowableWeapon) shuriken: ThrowableWeapon\n    ) {\n        this._katana = katana;\n        this._shuriken = shuriken;\n    }\n\n    public fight() { return this._katana.hit(); };\n    public sneak() { return this._shuriken.throw(); };\n\n}\n```\n\n### Step 3: Create and configure a Container\n\nWe recommend to do this in a file named inversify.config.ts. This is the only place in which there is some coupling. In the rest of your application your classes should be free of references to other classes.\n\n```javascript\nimport { Container } from \"inversify\";\n\nimport { Ninja } from \"./entities/ninja\";\nimport { Katana } from \"./entities/katana\";\nimport { Shuriken } from \"./entities/shuriken\";\n\nconst myContainer = new Container();\nmyContainer.bind<Warrior>(TYPES.Warrior).to(Ninja);\nmyContainer.bind<Weapon>(TYPES.Weapon).to(Katana);\nmyContainer.bind<ThrowableWeapon>(TYPES.ThrowableWeapon).to(Shuriken);\n\nexport default myContainer;\n```\n\n### Step 4: Resolve dependencies\n\nYou can use the method `get<T>` from the `Container` class to resolve a dependency. Remember that you should do this only in your [composition root](http://blog.ploeh.dk/2011/07/28/CompositionRoot/) to avoid the [service locator anti-pattern](http://blog.ploeh.dk/2010/02/03/ServiceLocatorisanAnti-Pattern/).\n\n```javascript\nimport myContainer = from \"./inversify.config\";\n\nconst ninja = myContainer.get<Warrior>(TYPES.Warrior);\n\nexpect(ninja.fight()).eql(\"cut!\"); // true\nexpect(ninja.sneak()).eql(\"hit!\"); // true\n```\n\nAs we can see the `Weapon` and `ThrowableWeapon` were successfully resolved and injected into `Ninja`.\n\n### The preceding file performs the following of tasks:\n\n1. Import the required dependencies “reflect-metadata” and “inversify”.\n2. Declare some interfaces and some types. Types are unique identifiers used to represent interfaces at runtime. We need these unique identifiers because TypeScript is compiled into JavaScript and JavaScript does not have support for static types like interfaces. We use types to identify which types need to be injected into a class.\n3. Declare some classes that implement the interfaces that we previously declared. These classes will be instantiated by the IoC container and for that reasons they require to be decorated using the “@injectable” decorator. We also need to use the “@inject” decorator to indicate which types need to be injected into a class.\n4. Declare an instance of the “Container” class and then declares some type bindings. A type bindings is a dictionary entry that links an abstraction (type) with an implementation (concrete class).\n5. Use the IoC container instance previously declared to resolve the “Warrior” type. We declared a type binding between the “Warrior” type and the “Ninja” class so we can expect the IoC container to return an instance of the “Ninja” class. Because the “Ninja” class has a dependency in the “Weapon” and “ThrowableWapon” types and we declared some bindings for those types we can expect instances of the “Katana” and “Shuriken” classes to be instantiated and injected into the “Ninja” class.\n6. Use the “log” method from the “console” object to check that instances of the Katana” and “Shuriken” has been correctly injected into the “Ninja” instance.\n\n## The Basics (JavaScript)\n\nIt is recommended to use TypeScript for the best development experience but you can use plain JavaScript if you preffer it. The following code snippet implements the previous example without TypeScript in Node.js v5.71:\n\n```javascript\nconst inversify = require(\"inversify\");\nrequire(\"reflect-metadata\");\n\nvar TYPES = {\n    Ninja: \"Ninja\",\n    Katana: \"Katana\",\n    Shuriken: \"Shuriken\"\n};\n\nclass Katana {\n    hit() {\n        return \"cut!\";\n    }\n}\n\nclass Shuriken {\n    throw() {\n        return \"hit!\";\n    }\n}\n\nclass Ninja {\n    constructor(katana, shuriken) {\n        this._katana = katana;\n        this._shuriken = shuriken;\n    }\n    fight() { return this._katana.hit(); };\n    sneak() { return this._shuriken.throw(); };\n}\n\n// Declare injections\ninversify.inject(TYPES.Katana, TYPES.Shuriken)(Ninja);\n\n// Declare bindings\nconst myContainer = new inversify.Container();\nmyContainer.bind(TYPES.Ninja).to(Ninja);\nmyContainer.bind(TYPES.Katana).to(Katana);\nmyContainer.bind(TYPES.Shuriken).to(Shuriken);\n\n// Resolve dependencies\nconst ninja = myContainer.get(TYPES.Ninja);\nreturn ninja;\n```\n\n## Node.js enterprise patterns\n\nWhat we just saw in the previous section of this article is a basic demo of the core InversifyJS API. When we implement a real world enterprise Node.js application using TypeScript and InversifyJS with Express.js we will end up writing some code that looks as follows:\n\n```javascript\nimport * as express from \"express\";\nimport { Response, RequestParams, Controller, Get, Post, Put } from \"inversify-express-utils\";\nimport { injectable, inject } from \"inversify\";\nimport { interfaces } from \"./interfaces\";\nimport { Type } from \"./types\";\nimport { authorize } from \"./middleware\";\nimport { Feature } from \"./features\";\n\n@injectable()\n@Controller(\n  \"/api/user\",\n  authorize({ feature: Feature.UserManagement })\n)\nclass UserController {\n  @inject(Type.UserRepository) private readonly _userRepository: interfaces.UserRepository;\n  @inject(Type.Logger) private readonly _logger: interfaces.Logger;\n\n  @Get(\"/\")\n  public async get(\n    @Request() req: express.Request,\n    @Response() res: express.Response\n  ) {\n    try {\n      this._logger.info(`HTTP ${req.method} ${req.url}`);\n      return await this._userRepository.readAll();\n    } catch (e) {\n      this._logger.error(`HTTP ERROR ${req.method} ${req.url}`, e);\n      res.status(500).json([]);\n    }\n  }\n\n  @Get(\"/:email\")\n  public async getByEmail(\n    @RequestParams(\"email\") email: string,\n    @Request() req: express.Request,\n    @Response() res: express.Response\n  ) {\n    try {\n      this._logger.info(`HTTP ${req.method} ${req.url}`);\n      return await this._userRepository.readAll({ where: { email: email } });\n    } catch (e) {\n      this._logger.error(`HTTP ERROR ${req.method} ${req.url}`, e);\n      res.status(500).json([]);\n    }\n  }\n}\n```\n\nAs we can see in the preceding code snippet, the inversify-express-utils allow us to implement routing, dependency injection and even apply some Express.js middleware using a very declarative and developer friendly API. This is the kind of developer experience that we want to enable thanks to InversifyJS.\n\n## Features\n\nLet's take a look to the InversifyJS features!\n\nThe core InversifyJS has a rich API and supports many use cases and [features](https://github.com/inversify/InversifyJS/tree/master/wiki#the-inversifyjs-features-and-api) including support for classes, support for Symbols, container API, controlling the scope of the dependencies, injecting a constant or dynamic value, create your own tag decorators, named bindings, circular dependencies\n\nIn top of an extensive list of features, we also want to provide developers with a great user experience and we are working on a serie for side-projects to facilitate the integration of InversifyJS with multiple frameworks and to provide developers with a great development experience : inversify-binding-decorators, inversify-inject-decorators, inversify-express-utils, inversify-restify-utils, inversify-vanillajs-helpers, inversify-tracer, inversify-logger-middleware, inversify-devtools.\n\n### Declaring core modules\n\nKernel modules can help you to manage the complexity of your bindings in very large applications.\n\n```javascript\nlet someModule: IKernelModule = (kernel: IKernel) => {\n    kernel.bind<Warrior>(\"Warrior\").to(Ninja);\n    kernel.bind<Weapon>(\"Weapon\").to(Katana);\n    kernel.bind<ThrowableWeapon>(\"ThrowableWeapon\").to(Shuriken);\n};\n\nlet kernel = new Kernel({ modules: [ someModule ] });\n```\n\n### Controlling the scope of the dependencies\n\nInversifyJS uses transient scope by default but you can also use singleton scope:\n\n```javascript\nkernel.bind<ThrowableWeapon>(\"ThrowableWeapon\").to(Shuriken).inTransientScope(); // Default\nkernel.bind<ThrowableWeapon>(\"ThrowableWeapon\").to(Shuriken).inSingletonScope();\n```\n\n### Injecting a value\n\nBinds an abstraction to a constant value.\n\n```javascript\nkernel.bind<Weapon>(\"Weapon\").toValue(new Katana());\n```\n\n### Injecting a class constructor\n\nBinds an abstraction to a class constructor.\n\n```javascript\n@inject(\"Weapon\", \"ThrowableWeapon\")\nclass Ninja implements Warrior {\n\n    private _katana: Weapon;\n    private _shuriken: ThrowableWeapon;\n\n    public constructor(Katana: INewable<Weapon>, shuriken: ThrowableWeapon) {\n        this._katana = new Katana();\n        this._shuriken = shuriken;\n    }\n\n    public fight() { return this._katana.hit(); };\n    public sneak() { return this._shuriken.throw(); };\n\n}\n```\n\n```javascript\nkernel.bind<INewable<Weapon>>(\"INewable<Weapon>\").toConstructor<Weapon>(Katana);\n```\n\n### Injecting a FactoryInjecting a Factory\n\nBinds an abstraction to a user defined Factory.\n\n```javascript\n@inject(\"Weapon\", \"ThrowableWeapon\")\nclass Ninja implements Warrior {\n\n    private _katana: Weapon;\n    private _shuriken: ThrowableWeapon;\n\n    public constructor(katanaFactory: IFactory<Weapon>, shuriken: ThrowableWeapon) {\n        this._katana = katanaFactory();\n        this._shuriken = shuriken;\n    }\n\n    public fight() { return this._katana.hit(); };\n    public sneak() { return this._shuriken.throw(); };\n\n}\n```\n\n```javascript\nkernel.bind<IFactory<Weapon>>(\"IFactory<Weapon>\").toFactory<Weapon>((context) => {\n    return () => {\n        return context.kernel.get<Weapon>(\"Weapon\");\n    };\n});\n```\n\n### Auto factory\n\nBinds an abstraction to a auto-generated Factory.\n\n```javascript\n@inject(\"Weapon\", \"ThrowableWeapon\")\nclass Ninja implements Warrior {\n\n    private _katana: Weapon;\n    private _shuriken: ThrowableWeapon;\n\n    public constructor(katanaFactory: IFactory<Weapon>, shuriken: ThrowableWeapon) {\n        this._katana = katanaFactory();\n        this._shuriken = shuriken;\n    }\n\n    public fight() { return this._katana.hit(); };\n    public sneak() { return this._shuriken.throw(); };\n\n}\n```\n\n```js\nkernel.bind<IFactory<Weapon>>(\"IFactory<Weapon>\").toAutoFactory<Weapon>();\n```\n\n### Injecting a Provider (asynchronous Factory)\n\nBinds an abstraction to a Provider. A provider is an asynchronous factory, this is useful when dealing with asynchronous I/O operations.\n\n```js\n@inject(\"Weapon\", \"ThrowableWeapon\")\nclass Ninja implements Warrior {\n\n    public katana: Weapon;\n    public shuriken: ThrowableWeapon;\n    public katanaProvider: IProvider<Weapon>;\n\n    public constructor(katanaProvider: IProvider<Weapon>, shuriken: ThrowableWeapon) {\n        this.katanaProvider = katanaProvider;\n        this.katana= null;\n        this.shuriken = shuriken;\n    }\n\n    public fight() { return this._katana.hit(); };\n    public sneak() { return this._shuriken.throw(); };\n\n}\n\nvar ninja = kernel.get<Warrior>(\"Warrior\");\n\nninja.katanaProvider()\n     .then((katana) => { ninja.katana = katana; })\n     .catch((e) => { console.log(e); });\n```\n\n```js\nkernel.bind<IProvider<Weapon>>(\"IProvider<Weapon>\").toProvider<Weapon>((context) => {\n    return () => {\n        return new Promise<Weapon>((resolve) => {\n            let katana = context.kernel.get<Weapon>(\"Weapon\");\n            resolve(katana);\n        });\n    };\n});\n```\n\n### Injecting a proxy\n\nIt is possible to create a [proxy](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy) of a dependency just before it is injected. This is useful to keep our dependencies agnostic of the implementation of crosscutting concerns like caching or logging.\n\n```js\ninterface Weapon {\n    use: () => void;\n}\n\nclass Katana implements Weapon {\n    public use() {\n        console.log(\"Used Katana!\");\n    }\n}\n\ninterface Warrior {\n    katana: Weapon;\n}\n\n@inject(\"Weapon\")\nclass Ninja implements Warrior {\n    public katana: Weapon;\n    public constructor(katana: Weapon) {\n        this.katana = katana;\n    }\n}\n```\n\n```js\nkernel.bind<Warrior>(\"Warrior\").to(Ninja);\n\nkernel.bind<Weapon>(\"Weapon\").to(Katana).proxy((katana) => {\n    let handler = {\n        apply: function(target, thisArgument, argumentsList) {\n            console.log(`Starting: ${new Date().getTime()}`);\n            let result = target.apply(thisArgument, argumentsList);\n            console.log(`Finished: ${new Date().getTime()}`);\n            return result;\n        }\n    };\n    katana.use = new Proxy(katana.use, handler);\n    return katana;\n});\n```\n\n### Multi-injection\n\nWe can use multi-injection When two or more concretions have been bound to the an abstraction. Notice how an array of `IWeapon` is injected into the `Ninja` class via its constructor:\n\n```js\ninterface IWeapon {\n    name: string;\n}\n\nclass Katana implements IWeapon {\n    public name = \"Katana\";\n}\nclass Shuriken implements IWeapon {\n    public name = \"Shuriken\";\n}\n\ninterface Warrior {\n    katana: IWeapon;\n    shuriken: IWeapon;\n}\n\n@inject(\"IWeapon[]\")\nclass Ninja implements Warrior {\n    public katana: IWeapon;\n    public shuriken: IWeapon;\n    public constructor(weapons: IWeapon[]) {\n        this.katana = weapons[0];\n        this.shuriken = weapons[1];\n    }\n}\n```\n\nWe are binding `Katana` and `Shuriken` to `IWeapon`:\n\n```js\nkernel.bind<Warrior>(\"Warrior\").to(Ninja);\nkernel.bind<IWeapon>(\"IWeapon\").to(Katana);\nkernel.bind<IWeapon>(\"IWeapon\").to(Shuriken);\n```\n\n### Tagged bindings\n\nWe can use tagged bindings to fix `AMBIGUOUS_MATCH` errors when two or more concretions have been bound to the an abstraction. Notice how the constructor arguments of the `Ninja` class have been annotated using the `@tagged` decorator:\n\n```js\ninterface IWeapon {}\nclass Katana implements IWeapon { }\nclass Shuriken implements IWeapon {}\n\ninterface Warrior {\n    katana: IWeapon;\n    shuriken: IWeapon;\n}\n\n@inject(\"IWeapon\", \"IWeapon\")\nclass Ninja implements Warrior {\n    public katana: IWeapon;\n    public shuriken: IWeapon;\n    public constructor(\n        @tagged(\"canThrow\", false) katana: IWeapon,\n        @tagged(\"canThrow\", true) shuriken: IWeapon\n    ) {\n        this.katana = katana;\n        this.shuriken = shuriken;\n    }\n}\n```\n\nWe are binding `Katana` and `Shuriken` to `IWeapon` but a `whenTargetTagged` constraint is added to avoid `AMBIGUOUS_MATCH` errors:\n\n```js\nkernel.bind<Warrior>(ninjaId).to(Ninja);\nkernel.bind<IWeapon>(weaponId).to(Katana).whenTargetTagged(\"canThrow\", false);\nkernel.bind<IWeapon>(weaponId).to(Shuriken).whenTargetTagged(\"canThrow\", true);\n```\n\n### Create your own tag decorators\n\nCreating your own decorators is really simple:\n\n```js\nlet throwable = tagged(\"canThrow\", true);\nlet notThrowable = tagged(\"canThrow\", false);\n\n@inject(\"IWeapon\", \"IWeapon\")\nclass Ninja implements Warrior {\n    public katana: IWeapon;\n    public shuriken: IWeapon;\n    public constructor(\n        @notThrowable katana: IWeapon,\n        @throwable shuriken: IWeapon\n    ) {\n        this.katana = katana;\n        this.shuriken = shuriken;\n    }\n}\n```\n\n### Named bindings\n\nWe can use named bindings to fix `AMBIGUOUS_MATCH` errors when two or more concretions have been bound to the an abstraction. Notice how the constructor arguments of the `Ninja` class have been annotated using the `@named` decorator:\n\n```js\ninterface IWeapon {}\nclass Katana implements IWeapon { }\nclass Shuriken implements IWeapon {}\n\ninterface Warrior {\n    katana: IWeapon;\n    shuriken: IWeapon;\n}\n\n@inject(\"IWeapon\", \"IWeapon\")\nclass Ninja implements Warrior {\n    public katana: IWeapon;\n    public shuriken: IWeapon;\n    public constructor(\n        @named(\"strong\")katana: IWeapon,\n        @named(\"weak\") shuriken: IWeapon\n    ) {\n        this.katana = katana;\n        this.shuriken = shuriken;\n    }\n}\n```\n\nWe are binding `Katana` and `Shuriken` to `IWeapon` but a `whenTargetNamed` constraint is added to avoid `AMBIGUOUS_MATCH` errors:\n\n```js\nkernel.bind<Warrior>(\"Warrior\").to(Ninja);\nkernel.bind<IWeapon>(\"IWeapon\").to(Katana).whenTargetNamed(\"strong\");\nkernel.bind<IWeapon>(\"IWeapon\").to(Shuriken).whenTargetNamed(\"weak\");\n```\n\n### Contextual bindings & `@paramNames`\n\nThe `@paramNames` decorator is used to access the names of the constructor arguments from a contextual constraint even when the code is compressed. The `constructor(katana, shuriken) { ...` becomes `constructor(a, b) { ...` after compression but thanks to `@paramNames` we can still refer to the design-time names `katana` and `shuriken`.\n\n```js\ninterface IWeapon {}\nclass Katana implements IWeapon { }\nclass Shuriken implements IWeapon {}\n\ninterface Warrior {\n    katana: IWeapon;\n    shuriken: IWeapon;\n}\n\n@inject(\"IWeapon\", \"IWeapon\")\n@paramNames(\"katana\",\"shuriken\")\nclass Ninja implements Warrior {\n    public katana: IWeapon;\n    public shuriken: IWeapon;\n    public constructor(\n        katana: IWeapon,\n        shuriken: IWeapon\n    ) {\n        this.katana = katana;\n        this.shuriken = shuriken;\n    }\n}\n```\n\nWe are binding `Katana` and `Shuriken` to `IWeapon` but a custom when constraint is added to avoid `AMBIGUOUS_MATCH` errors:\n\n```js\nkernel.bind<Warrior>(ninjaId).to(Ninja);\n\nkernel.bind<IWeapon>(\"IWeapon\").to(Katana).when((request: IRequest) => {\n    return request.target.name.equals(\"katana\");\n});\n\nkernel.bind<IWeapon>(\"IWeapon\").to(Shuriken).when((request: IRequest) => {\n    return request.target.name.equals(\"shuriken\");\n});\n```\n\nThe target fields implement the `IQueryableString` interface to help you to create your custom constraints:\n\n```js\ninterface IQueryableString {\n  startsWith(searchString: string): boolean;\n  endsWith(searchString: string): boolean;\n  contains(searchString: string): boolean;\n  equals(compareString: string): boolean;\n  value(): string;\n}\n```\n\n### Circular dependencies\n\nInversifyJS is able to identify circular dependencies and will throw an exception to help you to identify the location of the problem if a circular dependency is detected:\n\n`<code>Error: Circular dependency found between services: Weapon and Warrior</code>`","description":"О InversifyJS \n\nПредставляем в этой главе адаптированный перевод статьи и этой статьи \n\nInversifyJS is a powerful lightweight (4KB) pico inversion of control (IoC) container for TypeScript and JavaScript apps. A pico IoC container uses a class constructor..."}}}