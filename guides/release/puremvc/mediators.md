<em>Медиаторы</em> используются для взаимодействия пользователей с одним или
более компонентами <em>Представления</em>, (например DOM elements, UI Component,
HTTP request, RabbitMQ message, ...) в браузере или для обработки <em>Запросов</em>,
<em>Событий</em>, <em>Сообщений</em> на NodeJS, и остальными частями PureMVC приложения.

Во Frontend-приложении <em>Медиатор</em> является местом, где обычно устанавливают
обработчики событий <em>Представления</em> для обработки пользовательских
действий и запросов данных от компонента. Он посылает и принимает
<em>Оповещения</em> (Notifications) для взаимодействия c приложением.

## Задачи конкретного Медиатора
Фреймворки для Frontend включают немало компонент для
построения графических интерфейсов. Вы можете использовать
стандартные компоненты, либо реализовывать свои для представления
модели данных пользователю, и позволять ему взаимодействовать с ними.

Так же для NodeJS - существует не мало библиотек для работы с различными каналами
данных, протоколами передачи данных или через непосредственную работу с UNIX-сокетами.

Задача PureMVC - оставаться нейтральным к используемым технологиям в
приложении, предоставляя простые идиомы для работы с любыми
компонентами графического интерфейса, каналами и протоколами данными или Моделью Данных.

Для PureMVC-приложения компонент <em>Представления</em> это любой элемент
управления графического интерфейса, либо контейнер с несколькими
компонентами, независимо от конкретной платформы, а в случае NodeJS -
любой источник <em>Событий</em> или канал данных.
<em>Представление</em> должно инкапсулировать как можно больше собственных
состояний и операций, предоставляя простой интерфейс для
взаимодействия с ним.

<em>Конкретный Медиатор</em> позволяет использовать один или более компонентов
<em>Представления</em> в приложении используя только ссылки и предоставленное
API.

Основная задача <em>Медиатора</em> - обработка событий (Events), инициированных
компонентом <em>Представления</em> и касающихся его <em>Оповещений</em> (Notifications).

<em>Медиаторы</em> также часто взаимодействуют с <em>Прокси</em>. Довольно
распространенная практика получения и хранения локальных ссылок на
часто используемые экземпляры <em>Прокси</em> в конструкторе. Это уменьшает
многочисленные вызовы retrieveProxy для получения одних и тех же
ссылок.

## Неявное преобразование типов компонентов Представления
Базовый класс <em>Медиатор</em> реализованный в PureMVC принимает в качестве
аргументов своего конструктора имя и объект <em>Представления</em> типа Object.

Конструктор вашего конкретного <em>Медиатора</em> будет принимать компонент
<em>Представления</em>, делая его сразу же доступным в защищенном (protected)
свойстве класса viewComponent, обычно типа Object.

Вы также можете, используя метод setViewComponent, динамически
устанавливать экземпляр <em>Представления</em> в <em>Медиаторе</em> после вызова
конструктора.

После присвоения вы часто будете приводить этот объект к конкретному
типу, что может быть неудобно, а также способствовать распространению
повторяемого кода.

Язык JavaScript предоставляет возможность называемую геттеры и
сеттеры (getters/setters). Геттер выглядит как метод, но используется как
свойство класса. Эта возможность очень полезна для решения проблемы
частого приведения типа.

Полезная идиома применяемая в вашем конкретном <em>Медиаторе</em>, -
использование геттера для приведения типа <em>Представления</em> к его
настоящему типу с понятным именем.

Например так:

```js
@property get controlBar(): MyAppControlBar {
  return this.getViewComponent();
}
```

Затем, в любом месте вашего Медиатора чем делать это так:

```js
const vc: MyAppControlBar = this.getViewComponent();
vc.searchSelection = MyAppControlBar.NONE_SELECTED;
```

Мы вместо этого делаем так:

```js
this.controlBar.searchSelection = MyAppControlBar.NONE_SELECTED;
```

## Взаимодействие с Представлением
<em>Медиатор</em> обычно имеет только один компонент <em>Представления</em>, но может
взаимодействовать и с несколькими, например: с ApplicationToolBar и
содержащимися в нем кнопками, либо другими аналогичными
компонентами. Мы можем иметь группу связанных компонентов (как
форма) в одном <em>Представлении</em> и обращаться <em>Медиатором</em> к её элементам
как к свойствам. Но лучше инкапсулировать в <em>Представлении</em> как можно
больше компонентов. Иметь специализированный объект для обмена
данными тоже хорошая практика.

<em>Медиатор</em> отвечает за взаимодействие уровня <em>Контроллера</em> и <em>Модели</em>,
обновляя <em>Представление</em> когда получает соответствующие <em>Оповещения</em>
(Notifications).
Во Flash, мы обычно подписываем слушателей событий к компоненту
<em>Представления</em>, в момент создания <em>Медиатора</em> или по вызову метода
setViewComponent, определяя метод обработчика:

```js
@method onRegister() {
  super.onRegister();
  // The STDOUT pipe from the shell to all modules
  this._junction.registerPipe(STDOUT, OUTPUT, TeeSplit.new());
  // The STDIN pipe to the shell from all modules
  this._junction.registerPipe(STDIN, INPUT, TeeMerge.new());
  this._junction.addPipeListener(STDIN, this, this.handlePipeMessage);
  // The STDLOG pipe from the shell to the logger
  this._junction.registerPipe(STDLOG, OUTPUT, Pipe.new());
  this.send(CONNECT_SHELL_TO_LOGGER, this._junction);
}
```

Действия <em>Медиатора</em>, в ответ на возникшее <em>Событие</em>, определяется
требованиями логики.

Обычно, конкретный метод обработчика <em>События</em> <em>Медиатора</em> выполняет
такие действия:
* Изучает тип <em>События</em> либо поля специализированного типа <em>События</em>,
который ожидается.
* Читает или модифицирует доступные свойства (либо вызывает
методы) компоненты <em>Представления</em>.
* Читает или модифицирует доступные свойства (либо вызывает
методы) <em>Прокси</em>.
* Шлет одно или более <em>Оповещение</em>, на которое будут реагировать
<em>Медиаторы</em> и <em>Команды</em>.

Несколько хороших правил:

* Если несколько других <em>Медиаторов</em> должно быть вовлечено в
обработку ответа на <em>Событие</em>, изменяйте общие <em>Прокси</em> либо
отсылайте <em>Оповещения</em>, которые обработают соответствующие
<em>Медиаторы</em>.
* Если требуется большое количество согласованных взаимодействий,
хорошая практика использовать <em>Команду</em>, локализируя шаги в одном
месте.
* Плохой практикой считается получение других <em>Медиаторов</em>, либо
<em>Медиаторов</em> с открытыми методами для непосредственной
манипуляции.
* Для манипулирования и распространения информации о состоянии
приложения к <em>Медиаторам</em>, устанавливайте значения свойств
<em>Медиатора</em>, или вызывайте методы <em>Прокси</em>, созданные для установки
состояния. Пусть медиатор будет заинтересован в оповещениях,
отправляемых <em>Прокси</em>, хранящих состояние приложения.

## Обработка оповещений в Медиаторе
Вместо явного добавления слушателей событий для <em>Представления</em>,
можно очень просто и почти автоматически связать между собой <em>Медиатор</em>
и PureMVC.

После регистрации <em>Представления</em>, <em>Медиатор</em> опрашивается на наличие
заинтересованных оповещений и в ответ возвращает массив имен
<em>Оповещений</em> (Notifications name), которые он хотел бы обрабатывать.

Ответ проще всего реализовать с помощью одного простого выражения,
которое будет возвращать массив с именами оповещений, которые должны
быть определены как статические константы, обычное это делается в
<em>Фасаде</em> приложения.

Создать список заинтересованных <em>Оповещений</em> (Notification Interests) для
конкретного <em>Медиатора</em> можно следующим образом:

```js
@method listNotificationInterests(): string[] {
  return [ CONNECT_MODULE_TO_LOGGER, CONNECT_SHELL_TO_LOGGER ];
}
```

Перечисленные оповещения, будут сразу обрабатываться <em>Медиатором</em> как
только они будет отосланы любым из игроков системы.

Внутри обработчика оповещений, для удобства и читабельности кода
вместо «if / else if» лучше использовать конструкцию «switch / case».

По сути, для каждого оповещения достаточно небольшого обработчика, а
вся нужная информация должна находиться в самом объекте оповещения.
Правда иногда информация может быть получена от <em>Посредника</em>,
основанная на данных из объекта оповещения. Желательно избегать
нагромождения логики в одном обработчике, иначе это верный признак
того, что вы стараетесь перенести бизнес логику из <em>Команды</em> (Command) в
обработчик оповещений (notification) медиатора.

```js
@method handleNotification<T = ?any>(note: NotificationInterface<T>): ?Promise<void> {
  switch (note.getName()) {
    // Connect any Module's STDLOG to the logger's STDIN
    case (CONNECT_MODULE_TO_LOGGER):
      const module = note.getBody();
      const pipe = Pipe.new();
      module.acceptOutputPipe(STDLOG, pipe);
      this.logger.acceptInputPipe(STDIN, pipe);
      break;
    // Bidirectionally connect shell and logger on STDLOG/STDSHELL
    case (CONNECT_SHELL_TO_LOGGER):
      // The junction was passed from ShellJunctionMediator
      const junction = note.getBody();
      // Connect the shell's STDLOG to the logger's STDIN
      const shellToLog = junction.retrievePipe(STDLOG);
      this.logger.acceptInputPipe(STDIN, shellToLog);
      // Connect the logger's STDSHELL to the shell's STDIN
      const logToShell = Pipe.new();
      const shellIn = junction.retrievePipe(STDIN);
      shellIn.connectInput(logToShell);
      this.logger.acceptOutputPipe(STDSHELL, logToShell);
      break;
  }
}
```

Практика показывает, что лучше всего обрабатывать 4-5 оповещений в
одном обработчике.

Если оповещений больше, желательно разбить этот обработчик на
несколько менее громоздких. Создавая <em>медиаторы</em> для отдельных
компонентов <em>Представления</em>, можно избежать накопления оповещений в
одном обработчике.

Использование единого, заранее определенного метода оповещения,
является главной отличительной чертой <em>Медиатора</em>, как он обрабатывает
события и оповещения.

Для событий мы можем определить целый ряд обработчиков, но обычно для
каждого события есть свой единственный обработчик. Эти методы не
должны быть слишком сложными, или заниматься слишком мелкими
задачами по работе с каждым компонентом <em>Представления</em>, поскольку
<em>Представление</em> должен быть написан так, чтобы включать в себя детали
своей реализации, предоставляя <em>Медиатору</em> четко разделенный по
направлениям интерфейс.

Используя <em>Оповещения</em>, у вас есть единственный метод-обработчик, в
котором вы обрабатываете все <em>Оповещения</em> нужные для <em>Медиатора</em>.

Лучше всего обрабатывать все оповещения в одном методе, используя
switch конструкцию для различия оповещения по именам.

Было много обсуждений по поводу использования switch конструкции,
многие разработчики считают, что эта конструкция ограничивает одним
способом обработки. Однако рекомендуемая практика это использования
одного метода обработчика оповещения и switch-конструкция.

Медиатор является посредником между <em>Представлением</em> и остальной
частью системы.

Рассмотрим роль переводчицы беседы между послом и остальными членами
конференции ООН. Она редко делает что-либо большее чем перевод и
получение сообщений, разве что иногда подбирая подходящие метафоры
или факты. Тоже самое можно сказать о роли <em>Медиатора</em> в рамках PureMVC.

## Связка Медиатора с Прокси и другими Медиаторами
В конечном счете, <em>Представление</em> наполняется данными <em>Модели</em> для
графического их отображения, взаимодействия с данными через <em>Прокси</em>.

<em>Представление</em> должно знать о <em>Модели</em>, но <em>Модель</em>, в свою очередь, не
должна знать о <em>Представлении</em>.

<em>Медиатор</em> может легко получить доступ к <em>Прокси</em> через <em>Модель</em> и читать и
манипулировать данными, используя программный интерфейс <em>Прокси</em>. Если
выполнять те же операции с помощью <em>Команд</em>, будет потеряна связь между
<em>Моделью</em> и <em>Представлением</em>. - Однако это можно рассматривать и
с положительной точки зрения, т.к. уменьшается связность между
<em>Моделью</em> и <em>Представлением</em>. Чтобы понять, как поступить в этой ситуации,
стоит руководствоваться правилом <em>Данные вниз - Экшены ввер (DDAU)</em>,
т.е. можно использовать <em>Прокси</em> непосредственно в <em>Медиаторе</em>
только для отображения данных (только на чтение), а для изменения каких либо данных
в ответ на <em>Событие</em> в <em>Представлении</em> менять данные в <em>Прокси</em>
только внутри <em>Команды</em> через отправку <em>Оповещения</em>.

Так же <em>Медиатор</em> может получить ссылки на другие <em>Медиаторы</em> из
<em>Представления</em> и манипулировать данным уже из других <em>Медиаторов</em>.

Однако это не очень хорошая практика, потому что может привести к
зависимости между частями <em>Представления</em>, что негативно повлияет на
рефакторинг одной части <em>Представления</em> без затрагивания других частей.

Медиатор, желающий взаимодействовать с другим областям <em>Представления</em>,
должен послать <em>Оповещение</em>, а не манипулировать <em>Представлением</em>
напрямую.

<em>Медиатор</em> не должен раскрывать методы для манипулирования своими
компонентами - вместо этого он должен отвечать на оповещения и
выполнять свою работу.

Если большая часть поведения <em>Компонентов Представления</em> реализована в
<em>Медиаторе</em> (в ответ на <em>Событие</em> или <em>Оповещение</em>), желательно часть из них
перенести в само <em>Представление</em>, так чтобы в дальнейшем можно было
повторно использовать.

Если большинство взаимодействий с <em>Прокси</em> или их данными реализованы в
<em>Медиаторе</em>, перенос этой функциональности в <em>Команду</em> упростит <em>Медиатор</em>.
Также перенос бизнес логики в <em>Команды</em> позволяет использовать ее
другими <em>Представлениями</em> без потери связки <em>Представление – Модель</em>.

## Взаимодействие пользователя с Представлением и Медиаторами
Рассмотрим медиатор SimpleMediator, инкапсулирующий в себе инстанс `readline`,
для взаимодействия с пользователем через консоль.

Взаимодействие инстанса `readline` и <em>Медиатора</em> SimpleMediator
заключается в том, что утилита запускает обработчик на событие 'line', когда
пользователь ввел текст. Медиатор
SimpleMediator обрабатывает событие, отсылая <em>Оповещение</em> `MSG_FROM_CONSOLE` с
введенными данными.

```js
import readline from 'readline';

export default (Module) => {
  const {
    START_CONSOLE, MSG_FROM_CONSOLE, MSG_TO_CONSOLE,
    Mediator,
    initialize, partOf, meta, property, method, nameBy
  } = Module.NS;

  @initialize
  @partOf(Module)
  class SimpleMediator extends Mediator {
    @nameBy static __filename = __filename;
    @meta static object = {};

    @method listNotificationInterests(): string[] {
      const interests = super.listNotificationInterests(... arguments);
      interests.push(START_CONSOLE);
      interests.push(MSG_TO_CONSOLE);
      return interests;
    }

    @method handleNotification<T = ?any>(note: NotificationInterface<T>): ?Promise<void> {
      switch (note.getName()) {
        case (START_CONSOLE):
          this.stdinStart();
          break;
        case (MSG_TO_CONSOLE):
          this.stdinComplete(note.getBody());
          break;
        default:
          super.handleNotification(note);
      }
    }

    @method onRegister() {
      super.onRegister();
      this.rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
        prompt: '... waiting new text ...\n'
      });
      this.rl.setMaxListeners(Number.MAX_SAFE_INTEGER);
    }

    @method async onRemove(): Promise<void> {
      await super.onRemove();
      this.rl.close()
    }

    @method stdinStart() {
      console.log('Start: ');
      this.rl.prompt();
      this.rl.on('line', (input) => {
        console.log(`Received: ${input}`);
        this.send(MSG_FROM_CONSOLE, input);
      });
    }

    @method stdinComplete(body) {
      console.log('Complete: ', body);
      this.rl.prompt();
    }
  }
}
```

Метод onRegister вызывается при инстанцировании <em>Медиатора</em>, в нем мы
создаем компонент консольного интерфейса с пользователем.

Вся логика компонента находится в <em>Медиаторе</em>, где обрабатывается
событие 'line' и отсылается `MSG_FROM_CONSOLE` <em>Оповещение</em>ю

```js
import type { NotificationInterface } from '../interfaces/NotificationInterface';
import type { SimpleProxyInterface } from '../interfaces/SimpleProxyInterface';

export default (Module) => {
  const {
    SIMPLE_PROXY, MSG_TO_CONSOLE,
    Command,
    initialize, partOf, meta, method, property, nameBy, inject,
  } = Module.NS;

  @initialize
  @partOf(Module)
  class SimpleCommand extends Command {
    @nameBy static  __filename = __filename;
    @meta static object = {};

    @inject(`Factory<${SIMPLE_PROXY}>`)
    @property _simpleProxyFactory: () => SimpleProxyInterface;
    @property get _simpleProxy(): SimpleProxyInterface {
      return this._simpleProxyFactory()
    }

    @method execute<T = ?any>(note: NotificationInterface<T>): void {
      this._simpleProxy.setData(note.getBody())
      this.send(MSG_TO_CONSOLE, this._simpleProxy.getData());
    }
  }
}
```

Mы зарегистрировали команду SimpleCommand для этого <em>Оповещения</em>.
Эта команда будет вызывать метод setData <em>Прокси</em> SimpleProxy,
передавая объект, полученный от медиатора.

<em>Медиатор</em> SimpleMediator имеет список заинтересованных оповещений,
в который входят `START_CONSOLE` и `MSG_TO_CONSOLE`. <em>Оповещение</em>
`START_CONSOLE` отправляется после запуска приложения, чтобы активировать утилиту
внутри этого медиатора, а `MSG_TO_CONSOLE` - это <em>Оповещение</em>, на которое
подписан <em>Медиатор</em>, чтобы вывести на консоль пользователю некоторое сообщение.
